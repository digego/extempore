;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; to compile xtm.bc file
;;
;; first export module to bitcode:

(define load-libs-for-stdlib-compilation
  (lambda ()
    (sys:load "libs/core/math.xtm")
    (sys:load "libs/external/opengl.xtm")
    (sys:load "libs/external/shaders.xtm")
    (sys:load "libs/external/assimp.xtm")
    (sys:load "libs/core/audio_dsp.xtm")
    (sys:load "libs/core/instruments.xtm")
    (sys:load "libs/external/sndfile.xtm")
    (sys:load "libs/external/instruments.xtm")
    ;; export the module to bitcode
    (llvm:export-module "/tmp/xtm.bc")
    ;; print further instructions
    (print "\nLLVM bitcode for the xtlang standard library exported to \"/tmp/xtm.bc\". To finish compiling the stdlib, enter the following command in a terminal window (inserting the proper path to your LLVM install):\n\n")
    (cond ((string=? (sys:platform) "Linux")
           (print "/path/to/llvm-3.2/Release/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && gcc --shared -g /tmp/xtm.s -o ./xtm.so\n"))
          ((string=? (sys:platform) "OSX")
           (print "/path/to/llvm-3.2/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && clang -O3 -dynamiclib -undefined dynamic_lookup /tmp/xtm.s -o ./xtm.dylib\n"))
          (else (print "Sorry, cannot find the appropriate compilation command for your platform at this time.")))))

;; Here are the shell invocations for

;; Linux:
;; /path/to/llvm-3.2/Release/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && gcc --shared -g /tmp/xtm.s -o ./xtm.so

;; OSX:
;; /usr/local/Cellar/extempore-llvm/3.2/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && clang -O3 -dynamiclib -undefined dynamic_lookup /tmp/xtm.s -o ./xtm.dylib

;; emacs regex for generating the header file:
;; Compiled \(.*\) >>> \(.*\) -> (bind-lib-func stdlib \1 \2)


;; lib-loading config
(sys:load-preload-check 'stdlib)

(define stdlib
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libs/xtm.so"))
          ((string=? platform "Windows") (sys:open-dylib "libs/xtm.dll"))
          ((string=? platform "OSX") (sys:open-dylib "libs/xtm.dylib"))
          (else (print "Unknown platform: " platform) #f))))

(if (or (eq? #f stdlib)
	(not stdlib)) 
    (sys:load-escape "Could not load 'xtm' dynamic library"))

(ascii-print-color 0 6 10)
(println)
(print 'Loading 'xtm 'standard 'lib '...)
(ascii-print-color 0 7 10)
(println)
(suppress-compiler-messages #t)

;;;;;;  MATH SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'math)
(define *xtmlib-math-loaded* #t)

(bind-type cpxd <double,double>)
(bind-type cpxf <float,float>)

(bind-lib-func stdlib deg2rad_f [float,float]*)
(bind-lib-func stdlib deg2rad_d [double,double]*)
(bind-lib-func stdlib rad2deg_f [float,float]*)
(bind-lib-func stdlib rad2deg_d [double,double]*)
(bind-lib-func stdlib randn [double]*)
(bind-lib-func stdlib vprintd [void,double*,i64]*)
(bind-lib-func stdlib vprintf [void,float*,i64]*)
(bind-lib-func stdlib vnormd [void,double*,i64,double*]*)
(bind-lib-func stdlib vnormf [void,float*,i64,float*]*)
(bind-lib-func stdlib vmagd [double,double*,i64]*)
(bind-lib-func stdlib vmagf [float,float*,i64]*)
(bind-lib-func stdlib vdotd [double,double*,double*,i64]*)
(bind-lib-func stdlib vdotf [float,float*,float*,i64]*)
(bind-lib-func stdlib vcrossd [void,double*,double*,double*]*)
(bind-lib-func stdlib vcrossf [void,float*,float*,float*]*)
(bind-lib-func stdlib vsmuld [void,double,double*,i64,double*]*)
(bind-lib-func stdlib vsmulf [void,float,float*,i64,float*]*)
(bind-lib-func stdlib vsdivd [void,double,double*,i64,double*]*)
(bind-lib-func stdlib vsdivf [void,float,float*,i64,float*]*)
(bind-lib-func stdlib vsumd [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vsumf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vsubd [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vsubf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vmuld [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vmulf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vaquatd [void,double,double*,double*]*)
(bind-lib-func stdlib vaquatf [void,float,float*,float*]*)
(bind-lib-func stdlib mprintd [void,double*,i64,i64,i1]*)
(bind-lib-func stdlib mprintf [void,float*,i64,i64,i1]*)
(bind-lib-func stdlib mprinti64 [void,i64*,i64,i64,i1]*)
(bind-lib-func stdlib mprinti32 [void,i32*,i64,i64,i1]*)
(bind-lib-func stdlib mmuld [double*,double*,i64,i64,double*,i64,i64,double*]*)
(bind-lib-func stdlib mmulf [float*,float*,i64,i64,float*,i64,i64,float*]*)
(bind-lib-func stdlib mmuli64 [i64*,i64*,i64,i64,i64*,i64,i64,i64*]*)
(bind-lib-func stdlib mmuli32 [i32*,i32*,i64,i64,i32*,i64,i64,i32*]*)
(bind-lib-func stdlib mtransd [double*,double*,i64,i64,double*]*)
(bind-lib-func stdlib mtransf [float*,float*,i64,i64,float*]*)
(bind-lib-func stdlib mdetrmd [double,double*,i64]*)
(bind-lib-func stdlib mdetrmf [float,float*,i64]*)
(bind-lib-func stdlib minvd [void,double*,i64,double*]*)
(bind-lib-func stdlib minvf [void,float*,i64,float*]*)
(bind-lib-func stdlib mcopyd [void,double*,i64,i64,double*]*)
(bind-lib-func stdlib mcopyf [void,float*,i64,i64,float*]*)
(bind-lib-func stdlib rot_matrix_about_axis_d [double*,double,double*,double*]*)
(bind-lib-func stdlib rot_matrix_about_axis_f [float*,float,float*,float*]*)
(bind-lib-func stdlib conjugate_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib conjugate_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib magnitude_squared_cpxf [float,cpxf*]*)
(bind-lib-func stdlib magnitude_squared_cpxd [double,cpxd*]*)
(bind-lib-func stdlib magnitude_cpxf [float,cpxf*]*)
(bind-lib-func stdlib magnitude_cpxd [double,cpxd*]*)
(bind-lib-func stdlib phase_cpxf [float,cpxf*]*)
(bind-lib-func stdlib phase_cpxd [double,cpxd*]*)
(bind-lib-func stdlib cart_to_pol_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib pol_to_cart_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib cart_to_pol_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib pol_to_cart_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxf [void,float*,float*,cpxf*,i64]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxd [void,double*,double*,cpxd*,i64]*)
(bind-lib-func stdlib conjugate_buffer_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib conjugate_buffer_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_cart_to_pol_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_pol_to_cart_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_cart_to_pol_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_pol_to_cart_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_re_only_cpxf [void,cpxf*,float*,i64]*)
(bind-lib-func stdlib buffer_im_only_cpxf [void,cpxf*,float*,i64]*)
(bind-lib-func stdlib buffer_re_only_cpxd [void,cpxd*,double*,i64]*)
(bind-lib-func stdlib buffer_im_only_cpxd [void,cpxd*,double*,i64]*)
(bind-lib-func stdlib buffer_cpxd_to_cpxf [void,cpxd*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_cpxf_to_cpxd [void,cpxf*,cpxd*,i64]*)
(bind-lib-func stdlib window_hamming [void,double*,i64]*)
(bind-lib-func stdlib window_hanning [void,double*,i64]*)


(bind-poly deg2rad deg2rad_d)
(bind-poly deg2rad deg2rad_f)
(bind-poly rad2deg rad2deg_d)
(bind-poly rad2deg rad2deg_f)
(bind-poly vprint vprintd)
(bind-poly vprint vprintf)
(bind-poly vnorm vnormd)
(bind-poly vnorm vnormf)
(bind-poly vmag vmagd)
(bind-poly vmag vmagf)
(bind-poly vdot vdotd)
(bind-poly vdot vdotf)
(bind-poly vcross vcrossd)
(bind-poly vcross vcrossf)
(bind-poly vsmul vsmuld)
(bind-poly vsmul vsmulf)
(bind-poly vsdiv vsdivd)
(bind-poly vsdiv vsdivf)
(bind-poly vsum vsumd)
(bind-poly vsum vsumf)
(bind-poly vsub vsubd)
(bind-poly vsub vsubf)
(bind-poly vmul vmuld)
(bind-poly vmul vmulf)
(bind-poly vmag vmagd)
(bind-poly vmag vmagf)
(bind-poly vaquat vaquatd)
(bind-poly vaquat vaquatf)
(bind-poly mprint mprintd)
(bind-poly mprint mprintf)
(bind-poly mprint mprinti64)
(bind-poly mprint mprinti32)
(bind-poly mmul mmuld)
(bind-poly mmul mmulf)
(bind-poly mmul mmuli64)
(bind-poly mmul mmuli32)
(bind-poly mtrans mtransd)
(bind-poly mtrans mtransf)
(bind-poly mdetrm mdetrmd)
(bind-poly mdetrm mdetrmf)
(bind-poly minv minvd)
(bind-poly minv minvf)
(bind-poly mcopy mcopyf)
(bind-poly mcopy mcopyd)
(bind-poly rot_matrix_about_axis rot_matrix_about_axis_d)
(bind-poly rot_matrix_about_axis rot_matrix_about_axis_f)
(bind-poly conjugate_cpx conjugate_cpxf)
(bind-poly conjugate_cpx conjugate_cpxd)
(bind-poly magnitude_squared_cpx magnitude_squared_cpxf)
(bind-poly magnitude_squared_cpx magnitude_squared_cpxd)
(bind-poly magnitude_cpx magnitude_cpxf)
(bind-poly magnitude_cpx magnitude_cpxd)
(bind-poly phase_cpx phase_cpxf)
(bind-poly phase_cpx phase_cpxd)
(bind-poly cart_to_pol cart_to_pol_cpxf)
(bind-poly cart_to_pol cart_to_pol_cpxd)
(bind-poly pol_to_cart pol_to_cart_cpxf)
(bind-poly pol_to_cart pol_to_cart_cpxd)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxf)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxd)
(bind-poly conjugate_buffer_cpx conjugate_buffer_cpxf)
(bind-poly conjugate_buffer_cpx conjugate_buffer_cpxd)
(bind-poly buffer_cart_to_pol buffer_cart_to_pol_cpxf)
(bind-poly buffer_cart_to_pol buffer_cart_to_pol_cpxd)
(bind-poly buffer_pol_to_cart buffer_pol_to_cart_cpxf)
(bind-poly buffer_pol_to_cart buffer_pol_to_cart_cpxd)
(bind-poly buffer_re_only buffer_re_only_cpxf)
(bind-poly buffer_im_only buffer_re_only_cpxf)
(bind-poly buffer_re_only buffer_re_only_cpxd)
(bind-poly buffer_im_only buffer_re_only_cpxd)

(println 'MATH 'LOADED)

;;;;;;  IMAGE SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'image)
(define *xtmlib-image-loaded* #t)

(define libsoil
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libSOIL.so"))
	  ((string=? platform "Windows") (sys:open-dylib "libSOIL.dll"))
	  ((string=? platform "OSX") (sys:open-dylib "libSOIL.dylib"))
	  (else (print "Unknown platform: " platform)))))

(bind-lib libsoil SOIL_load_OGL_texture [i32,i8*,i32,i32,i32]*)
(bind-lib libsoil SOIL_load_OGL_texture_from_memory [i32,i8*,i32,i32,i32,i32]*)
(bind-lib libsoil SOIL_load_image [i8*,i8*,i32*,i32*,i32*,i32]*)

(bind-lib-val stdlib SOIL_FLAG_POWER_OF_TWO i32 1)
(bind-lib-val stdlib SOIL_FLAG_MIPMAPS i32 2)
(bind-lib-val stdlib SOIL_FLAG_TEXTURE_REPEATS i32 4)
(bind-lib-val stdlib SOIL_FLAG_MULTIPLY_ALPHA i32 8)
(bind-lib-val stdlib SOIL_FLAG_INVERT_Y i32 16)
(bind-lib-val stdlib SOIL_FLAG_COMPRESS_TO_DXT i32 32)
(bind-lib-val stdlib SOIL_FLAG_DDS_LOAD_DIRECT i32 64)
(bind-lib-val stdlib SOIL_FLAG_NTSC_SAFE_RGB i32 128)
(bind-lib-val stdlib SOIL_FLAG_CoCg_Y i32 256)
(bind-lib-val stdlib SOIL_FLAG_TEXTURE_RECTANGLE i32 512)

(bind-lib-val stdlib SOIL_LOAD_AUTO i32 0)
(bind-lib-val stdlib SOIL_LOAD_L i32 1)
(bind-lib-val stdlib SOIL_LOAD_LA i32 2)
(bind-lib-val stdlib SOIL_LOAD_RGB i32 3)
(bind-lib-val stdlib SOIL_LOAD_RGBA i32 4)

(bind-lib-val stdlib SOIL_SAVE_TYPE_TGA i32 0)
(bind-lib-val stdlib SOIL_SAVE_TYPE_BMP i32 1)
(bind-lib-val stdlib SOIL_SAVE_TYPE_DDS i32 2)

(bind-lib-val stdlib GL_RED i32 6403)
(bind-lib-val stdlib GL_UNSIGNED_SHORT i32 5123)
(bind-lib-val stdlib GL_2_BYTES i32 5127)
(bind-lib-val stdlib GL_4_BYTES i32 5129)
(bind-lib-val stdlib GL_BGRA i32 32993)

(bind-lib-func stdlib gl_load_image_rect [i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_image [i32,i8*,i32]*)
(bind-lib-func stdlib gl_tex_height [i32,i32]*)
(bind-lib-func stdlib gl_tex_width [i32,i32]*)
(bind-lib-func stdlib gl_tex_width_rect [i32,i32]*)
(bind-lib-func stdlib gl_tex_height_rect [i32,i32]*)
(bind-lib-func stdlib gl_load_tex_rect [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex_ext [i32,i32,i32,i32,i32,i8*,i32,i32]*)
(bind-lib-func stdlib gl_load_tex_bgr [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex_ext_bgr [i32,i32,i32,i32,i32,i8*,i32,i32]*)
(bind-lib-func stdlib gl_draw_img [void,double,double,double,double,double,i32]*)
(bind-lib-func stdlib gl_draw_img_ext [void,double,double,double,double,double,i32,i32]*)
(bind-lib-func stdlib gl_draw_img_from_img [void,double,double,double,double,double,double,double,double,double,i32]*)
(bind-lib-func stdlib gl_draw_img_reverse [void,double,double,double,double,double,i32]*)

(println 'SOIL 'LOADED)


;;;;;;;;;; OPENGL SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'opengl)
(define *xtmlib-opengl-loaded* #t)

(bind-type E_vbo <i32,i32,i8*>)
(bind-type E_fbo <i32,i32,i32,i32,i32>)

(define libgl
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libGL.so"))
          ((string=? platform "Windows") (sys:open-dylib "Gl32.dll"))
          ((string=? platform "OSX") (sys:open-dylib "/System/Library/Frameworks/OpenGL.framework/OpenGL"))
          (else (print "Unknown platform: " platform)))))

;; if on windows also check for opengl32.dll			  
(if (or (eq? #f libgl)
	    (null? libgl)) 
	(if (string=? "Windows" (sys:platform))
	    (begin (set! libgl (sys:open-dylib "opengl32.dll"))
		       (if (or (null? libgl)
				       (eq? #f libgl))
			       (sys:load-escape "Error loading opengl library")))	   
		(sys:load-escape "Error loading opengl library")))

(if (not (string=? (sys:platform) "Windows"))
    (begin (llvm:compile "declare i32 @glGetUniformBlockIndex(i32, i8*);")
	   (llvm:compile "declare void @glUniformBlockBinding(i32, i32, i32);")
	   (llvm:compile "declare void @glBindBufferRange(i32,i32,i32,i32,i32);")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; missing opengl constants

(bind-lib-val stdlib GL_VIEWPORT_BIT i32 2048)
(bind-lib-val stdlib GL_ENABLE_BIT i32 8192)
(bind-lib-val stdlib GL_VERTEX_PROGRAM_POINT_SIZE i32 34370)
(bind-lib-val stdlib GL_COORD_REPLACE i32 34914)

(bind-lib-val stdlib GL_ONE_MINUS_SRC_ALPHA i32 771)
(bind-lib-val stdlib GL_ONE_MINUS_SRC_COLOR i32 769)
(bind-lib-val stdlib GL_ONE_MINUS_DST_COLOR i32 775)

;;;;;;;;;;;;;;;;;;;;;;;  FBO stuff
(bind-lib-val stdlib GL_DRAW_FRAMEBUFFER i32 36009)
(bind-lib-val stdlib GL_READ_FRAMEBUFFER i32 36008)
(bind-lib-val stdlib GL_FRAMEBUFFER i32 36160)
(bind-lib-val stdlib GL_RENDERBUFFER i32 36161)
(bind-lib-val stdlib GL_RENDERBUFFER_WIDTH i32 36162)
(bind-lib-val stdlib GL_RENDERBUFFER_HEIGHT i32 36163)
(bind-lib-val stdlib GL_RENDERBUFFER_INTERNAL_FORMAT i32 36164)
(bind-lib-val stdlib GL_FRAMEBUFFER_COMPLETE i32 36053)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT0 i32 36064)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT1 i32 36065)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT2 i32 36066)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT3 i32 36067)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT4 i32 36068)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT5 i32 36069)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT6 i32 36070)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT7 i32 36071)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT8 i32 36072)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT9 i32 36073)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT10 i32 36074)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT11 i32 36075)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT12 i32 36076)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT13 i32 36077)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT14 i32 36078)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT15 i32 36079)

(bind-lib-val stdlib GL_DEPTH_ATTACHMENT i32 36096)
(bind-lib-val stdlib GL_DEPTH_COMPONENT24 i32 33190)
(bind-lib-val stdlib GL_MODELVIEW_MATRIX i32 2982)
(bind-lib-val stdlib GL_TEXTURE_MATRIX i32 2984)
(bind-lib-val stdlib GL_RGBA16F i32 34842)
(bind-lib-val stdlib GL_RGBA8 i32 32856)

(bind-lib-val stdlib GL_RENDERER i32 7937)

(if (not (string=? "Windows" (sys:platform)))
    (begin 
      (bind-lib libgl glGenFramebuffers [void,i32,i32*]*)
      (bind-lib libgl glGenRenderbuffers [void,i32,i32*]*)
      (bind-lib libgl glBindFramebuffer [void,i32,i32]*)
      (bind-lib libgl glBindRenderbuffer [void,i32,i32]*)
      (bind-lib libgl glRenderbufferStorage [void,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferRenderbuffer [void,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture [void,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture1D [void,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture2D [void,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture3D [void,i32,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glCheckFramebufferStatus [i32,i32]*)))


(bind-lib-func stdlib gl_setup [void]*)
(bind-lib-func stdlib gl_set_view [i64,double,double,double]*)
(bind-lib-func stdlib gl_look_at [void,double,double,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib gl_print_driver_info [void]*)
(bind-lib-func stdlib gl_print_error [void]*)
(bind-lib-func stdlib fbo_create_texture_rect [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_depth_buffer_rect [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_texture [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_depth_buffer [i32,i32,i32]*)
(bind-lib-func stdlib create_vbo [E_vbo*,i32,i8*,i32]*)
(bind-lib-func stdlib create_fbo_rect [E_fbo*,i32,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo_no_depth_rect [E_fbo*,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo [E_fbo*,i32,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo_no_depth [E_fbo*,i32,i32,i32]*)
(bind-lib-func stdlib print_shader_info_log [i64,i32]*)
(bind-lib-func stdlib print_program_info_log [i64,i32]*)
(bind-lib-func stdlib create_shader [i32,i8*,i8*]*)
(bind-lib-func stdlib create_shader_xtm [i32,i8*,i8*]*)
(bind-lib-func stdlib circle_line [void,double,double,double]*)
(bind-lib-func stdlib circle_whole [void,double,double,double]*)
(bind-lib-func stdlib cube_whole [i64]*)
(bind-lib-func stdlib mat4_to_mat3 [void,float*,float*]*)
(bind-lib-func stdlib translate_matrix [void,float*,float,float,float]*)
(bind-lib-func stdlib scale_matrix [void,float*,float,float,float]*)
(bind-lib-func stdlib rotate_matrix [void,float*,float,float,float,float]*)
(bind-lib-func stdlib fill_identity_matrix [void,float*]*)
(bind-lib-func stdlib fill_projection_matrix [void,float*,float,float,float,float]*)
(bind-lib-func stdlib fill_orthographic_matrix [void,float*,float,float,float,float,float,float]*)
(bind-lib-func stdlib fill_direction_vector [void,float*,float*,float*]*)
(bind-lib-func stdlib fill_view_matrix [void,float*,float*,float*,float*]*)
(bind-lib-func stdlib fill_view_matrix_dir [void,float*,float*,float*,float*]*)

(println 'OPENGL 'LOADED)

;;; SHADER SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'shaders)
(define *xtmlib-shaders-loaded* #t)

(bind-alias XTMRENDERCB [void,i64,i32,float*,float*,float*,i8*]*)

(bind-type xtm_mesh <E_vbo*,i32,float*,float*,float*,float*,float,float,i32>)
(bind-type xtm_node <i8*,float*,xtm_node*,i32,xtm_node*,i32,xtm_mesh*>)
(bind-type xtm_camera <float*,float*,float*>)
(bind-type xtm_lights <float*,float*,float*,float*,float*,float*,float*,float*,float*,i32>)

(bind-val xtm_render_s1 i32 0)
(bind-val xtm_render_s2 i32 0)
(bind-val xtm_render_s3 i32 0)
(bind-val xtm_render_s4 i32 0)
(bind-val xtm_render_x i32 0)
(bind-val xtm_render_y i32 0)
(bind-val xtm_render_w i32 1024)
(bind-val xtm_render_h i32 768)
(bind-val xtm_render_angle float 35.0)
(bind-val xtm_render_near float 0.1)
(bind-val xtm_render_far float 100.0)

(bind-lib-func stdlib xtm_build_mesh_vbo [E_vbo*,float*,i32]*)
(bind-lib-func stdlib xtm_make_node_a [xtm_node*,i8*,float*,i32,float,float,float]*)

(bind-lib-func stdlib xtm_get_camera [xtm_camera*]*)
(bind-lib-func stdlib xtm_camera_pos [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_tgt [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_up [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_view [void,float*]*)
(bind-lib-func stdlib xtm_update_camera [void,i32]*)

(bind-lib-func stdlib xtm_get_lights [xtm_lights*]*)
(bind-lib-func stdlib xtm_light_pos [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_tgt [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_up [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_ambient [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_diffuse [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_specular [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_power [void,i32,float]*)
(bind-lib-func stdlib xtm_light_angle [void,i32,float]*)
(bind-lib-func stdlib xtm_light_view [void,i32,float*]*)
(bind-lib-func stdlib xtm_update_lights [void,i32]*)
(bind-lib-func stdlib xtm_update_matrices [void,i32,float*,float*,float*]*)
(bind-lib-func stdlib xtm_draw_mesh [void,xtm_mesh*,i32]*)
(bind-lib-func stdlib xtm_draw_node [void,xtm_node*,i32,float*,float*,float*]*)
(bind-lib-func stdlib xtm_draw_model [void,xtm_node*,i32,float*,float*,float*]*)

(bind-lib-func stdlib xtm_draw_tex [void,i32,i32,float*,float*,float*]*)

(bind-lib-func stdlib xtm_render_fbo [E_fbo*]*)
(bind-lib-func stdlib xtm_render_setup_a [void,i32,i32,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_setup_b [void,i32,i32,float,float,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_setup_c [void,i32,i32,i32,i32,float,float,float,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)

(bind-lib-func stdlib xtm_render [i64,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,i8*]*)

(bind-lib-func stdlib gl_draw_shader_quad [void,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib shader_set_grid_offsets [void,float*,float,float,float]*)
(bind-lib-func stdlib shader_setup_convolution_filter [void,float*,i32,float]*)
(bind-lib-func stdlib shader_update_camera [void,i32,float*,float*]*)
(bind-lib-func stdlib shader_update_light [void,i32,float*,float*,float,float,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_lights [void,i32,i32,float*,float*,float*,float*,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices [void,i32,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices_lv [void,i32,float*,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices_lvs [void,i32,float*,float*,float*,i32,float*]*);
(bind-lib-func stdlib shader_update_material [void,i32,float*,float*,float*,float]*)

(bind-poly xtm_make_node xtm_make_node_a)

(bind-poly xtm_render_setup xtm_render_setup_a)
(bind-poly xtm_render_setup xtm_render_setup_b)
(bind-poly xtm_render_setup xtm_render_setup_c)

(define xtm_render_setup
  (lambda (w h . args)
    (if (null? args)
        (xtm_render_setup_a w h
                            simple-vert-xtm simple-frag
                            xtmvert-xtm xtmfrag xtmfrag_nolight
                            quad-vert quad-frag)
        (cond ((= (length args) 2)
               (xtm_render_setup_b w h (car args) (cadr args)
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              ((= (length args) 5)
               (xtm_render_setup_c w h (car args) (cadr args)
                                   (caddr args) (cadddr args)
                                   (car (cddddr args))
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              (else (println 'Wrong 'number 'or 'args 'for 'xtm_render_setup))))))


;; load up glsl code

;; vert shader
(define passthrough-vert
"// VERTEX SHADER
// #version 330

varying vec2 TexCoord;
 
void main() {   
   // pass through texture coordinate
   //TexCoord =  gl_TextureMatrix[0].st * gl_MultiTexCoord0.st;   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; //this same as line below
   gl_Position = ftransform();
}")


;; frag shader
(define passthrough-frag
"//  FRAGMENT SHADER
// #version 330
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2DRect(tex1,TexCoord);
}")


;; frag shader
(define greyscale-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(vec3(grey),alpha);
}")


;; sepia
(define sepia-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(grey*vec3(1.2,1.0,0.8),alpha);
}")


(define invert-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   vec4 colour = texture2DRect(tex1,TexCoord);
   gl_FragColor = vec4(1.0 - colour.rgb,alpha);
}")


(define gaussian-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   vec4 sample[25];
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor = ((1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
	           (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
	           (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +
	           (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +
	           (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +
	           (41.0 * sample[12])
	           ) / 273.0;
   //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}")


;;  Blur (median filter)
(define blur-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   gl_FragColor = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      gl_FragColor += texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor /= 25.0;
}")


;;  sharpen
(define sharpen-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }
  
    gl_FragColor = 25.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
       if (i != 12)
          gl_FragColor -= sample[i];
    }
}")

(define dilate-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {  
   vec4 sample[25];
   vec4 maxValue = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
      // Keep the maximum value		
      maxValue = max(sample[i], maxValue);
   }
 
   gl_FragColor = maxValue;
}")


(define erode-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
    vec4 minValue = vec4(1.0);
 
    for (int i = 0; i < 25; i++)
    {
        // Sample a grid around and including our texel
        sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
        // Keep the minimum value		
        minValue = min(sample[i], minValue);
    }
    gl_FragColor = minValue;
}")


(define edge-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 24.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
	if (i != 12)
	   gl_FragColor -= sample[i];
    }
}")


(define blend-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect baseBuf;
uniform sampler2DRect blendBuf;
uniform float       time;
uniform float       opacity;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(baseBuf, TexCoord);
    vec4 blend = texture2DRect(blendBuf, TexCoord);

    vec4 result = blend + base;
         result = clamp(result, 0.0, 1.0);

    gl_FragColor = mix(base, result, opacity);
}")


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible

//varying vec2 TexCoord;

attribute vec2 myVertex;
attribute vec4 myColour;
attribute float mySize;
attribute vec2 myVelocity;
attribute float myState;

void main() {
   gl_PointSize = mySize;
   if(myState > 0.0) {
     gl_FrontColor = myColour;
   }else{
     gl_FrontColor = vec4(0.0,0.0,0.0,0.0);
   }
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(myVertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
// #version 330

#version 120

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

//varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")


(define green-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex_back;
uniform sampler2DRect tex_front;
uniform vec4 color;
uniform float width;
uniform float height;
uniform float scale_front;
uniform int flipx;
uniform int flipy;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(tex_back, TexCoord);
    float x = (flipx==0) ? TexCoord.x : width-TexCoord.x;
    float y = (flipy==0) ? TexCoord.y : height-TexCoord.y;
    vec4 blend = texture2DRect(tex_front, vec2(x*scale_front,y*scale_front));

    if(color == blend) {
      gl_FragColor = base;
    }else{
      gl_FragColor = blend;
    }
}")


(define dof-frag
"
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect dBuf;
uniform sampler2DRect cBuf;
//uniform vec2 frameBufSize;
uniform float blur;
uniform float fp;  // focal point
uniform int show_depth;
uniform float dfact; // depth factor (shorten or make longer)
uniform float near;
uniform float far;

varying vec2 TexCoord;

// const float near = 0.1;
// const float far = 1000.0;
const vec2 frameBufSize = vec2(1.0,1.0);

vec4 blurKawase( const sampler2DRect tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
	// Function assumes that tex is using bilinear hardware filtering
	
	vec2 dUV = (iteration + 0.5) / texSize;
	
	vec4 col = texture2DRect( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
	col += texture2DRect( tex, texCoord + dUV );		        // Top right
	col += texture2DRect( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
	col += texture2DRect( tex, texCoord - dUV );		        // Bottom left
	
	return col * 0.25;
}

void main( void ) {
        // get z depth from dBuf tex 
	float depth = texture2DRect(dBuf,TexCoord).x;	

        // scale depth buffer
        depth *= far-near;
        depth = (far+near)-depth;
        depth = abs(depth - fp); // fp focal point

        // show_depth is true display depth buffer
        if (show_depth == 1) {
          gl_FragColor = vec4(depth,depth,depth,1.0);  
        } else { // else apply depth blur
          gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
        }
}
")


(define light-vert
  "
//#version 120
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  gl_Position = ModelViewProjectionMatrix * gl_Vertex;
  vec4 vPosition = ModelViewMatrix * gl_Vertex;
  //gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_Vertex;
  //vec4 vPosition = ViewMatrix * ModelMatrix * gl_Vertex;
  N = NormalMatrix * gl_Normal; //normal
  L = (LightPos - (ModelMatrix * gl_Vertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
}
")

(define light-frag
  "
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  vec4 Color = vec4(0.0,0.0,0.0,0.0);

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  gl_FragColor = vec4((ambient + diffuse + specular).xyz,1.0);
}
")

(define simple-vert
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main() {   
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define simple-vert-xtm
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

void main() {   
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define simple-frag
  "

void main() {
   gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}
")

(define quad-vert
  "
#version 120

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

varying vec2 TexCoord;
 
void main() {   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define quad-frag
  "
uniform sampler2D tex1;
varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,TexCoord);
}
")

(define light-and-shade-vert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix;

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  L = (LightPos - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
  lightVertexPosition = LightModelViewProjectionMatrix * xtmVertex;
}
")


(define light-and-shade-frag
  "
//#version 120
varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured; 

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color
  
  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;

else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition;
  lightVertexPosition2 /= lightVertexPosition2.w;

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,lightVertexPosition2.xy+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
     vec4 texcolor = LightDiffuse * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
     gl_FragColor = vec4((texcolor.xyz*shadowValue),1.0);
  } else {
     gl_FragColor = vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }
}
")


(define xtmvert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  for(int i=0; j<numlights; i++, j+=1.0) {
    L[i] = (LightPos[i] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
    if(LightPos[i].w == 0.0) L[i] = LightPos[i].xyz; // i.e. if LightPos is already a direction vector
    D[i] = length(L[i]);
    lightVertexPosition[i] = LightModelViewProjectionMatrix[i] * xtmVertex;
  }
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  for(int i=0; j<numlights; i++, j+=1.0) 
  {  
    vec3 LL = normalize(L[i]); // light vector
    attenuation = 1.0 / (ConstantAttenuation[i] + (LinearAttenuation[i] * D[i]) + (QuadraticAttenuation[i] * D[i] * D[i]));
    spotDot = dot(-LL, normalize(SpotDir[i].xyz));

    if(spotDot < SpotAngle[i])
      spotAttenuation = 0.0;
    else
      spotAttenuation = pow(spotDot, SpotExponent[i]);  

    attenuation *= spotAttenuation;

    HV = normalize(LL+EE); // half vector
    nDotLL = max(0.0, dot(NN,LL));
    nDotHV = max(0.0, dot(NN,HV));

    if(nDotLL==0.0)
      pf = 0.0;
    else
      pf = pow(nDotHV, MaterialShininess);

    ambient = LightAmbient[i] * MaterialAmbient * attenuation;
    diffuse = LightDiffuse[i] * MaterialDiffuse * nDotLL * attenuation;
    specular = LightSpecular[i] * MaterialSpecular * pf * attenuation;

    //calc shadows
    float shadowValue = 0.0;
    vec4 lightVertexPosition2 = lightVertexPosition[i];
    lightVertexPosition2 /= lightVertexPosition2.w;

    float aa = mod((j-0.5),4.0);
    float bb = floor((j-0.5)/4.0);
    vec2 offset = vec2(0.25*aa,0.25*bb);

    // softer shadowing by adding dither
    for(float x=-0.0004; x<=0.0004; x+=0.0002) {
      for(float y=-0.0004; y<=0.0004; y+=0.0002) {
        if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
          shadowValue+=1.0;
      }
    }
    shadowValue/=16.0;

    if(IsTextured>0.5) {
      vec4 texcolor = LightDiffuse[i] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
      outcolor += vec4((texcolor.xyz*shadowValue),1.0);
    } else {
      outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
    }
  }
  float nl = numlights;
  if(numlights<0.5) {
    nl = 1.0;
    float dotE = max(0.0, dot(NN,EE));
    if(IsTextured>0.5) {
      outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
    }else{
      outcolor.xyz = MaterialDiffuse.xyz*dotE;
    }
  }
  gl_FragColor = vec4(outcolor.xyz/nl,1.0);
}
")

(define xtmfrag_nolight
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")


(println 'SHADERS 'LOADED)

;;; ASSIMP SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'assimp)

(define libassimp
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libassimp.so"))
          ((string=? platform "Windows") (sys:open-dylib "libassimp.dll"))
          ((string=? platform "OSX") (sys:open-dylib "libassimp.dylib"))
          (else (print "Unknown platform: " platform)))))

;; if on windows also check for opengl32.dll			  
(if (or (eq? #f libassimp)
        (null? libassimp))
    (sys:load-escape "Error loading assimp library"))

(define *xtmlib-assimp-loaded* #t)

(bind-val aiProcess_CalcTangentSpace i32 1)
(bind-val aiProcess_JoinIdenticalVertices i32 2)
(bind-val aiProcess_MakeLeftHanded i32 4)
(bind-val aiProcess_Triangulate i32 8)
(bind-val aiProcess_RemoveComponent i32 16)
(bind-val aiProcess_GenNormals i32 32)
(bind-val aiProcess_GenSmoothNormals i32 64)
(bind-val aiProcess_SplitLargeMeshes i32 128)
(bind-val aiProcess_PreTransformVertices i32 256)
(bind-val aiProcess_LimitBoneWeights i32 512)
(bind-val aiProcess_ValidateDataStructure i32 1024)
(bind-val aiProcess_ImproveCacheLocality i32 2048)
(bind-val aiProcess_RemoveRedundantMaterials i32 4096)
(bind-val aiProcess_FixInfacingNormals i32 8192)
(bind-val aiProcess_SortByPType i32 32768)
(bind-val aiProcess_FindDegenerates i32 65536)
(bind-val aiProcess_FindInvalidData i32 131072)
(bind-val aiProcess_GenUVCoords i32 262144)
(bind-val aiProcess_TransformUVCoords i32 524288)
(bind-val aiProcess_FindInstances i32 1048576)
(bind-val aiProcess_OptimizeMeshes i32 2097152)
(bind-val aiProcess_OptimizeGraph i32 4194304)
(bind-val aiProcess_FlipUVs i32 8388608)
(bind-val aiProcess_FlipWindingOrder i32 16777216)
(bind-val aiProcess_SplitByBoneCount i32 33554432)
(bind-val aiProcess_Debone i32 67108864)

(define  aiProcess_CalcTangentSpace  1)
(define  aiProcess_JoinIdenticalVertices  2)
(define  aiProcess_MakeLeftHanded  4)
(define  aiProcess_Triangulate  8)
(define  aiProcess_RemoveComponent  16)
(define  aiProcess_GenNormals  32)
(define  aiProcess_GenSmoothNormals  64)
(define  aiProcess_SplitLargeMeshes  128)
(define  aiProcess_PreTransformVertices  256)
(define  aiProcess_LimitBoneWeights  512)
(define  aiProcess_ValidateDataStructure  1024)
(define  aiProcess_ImproveCacheLocality  2048)
(define  aiProcess_RemoveRedundantMaterials  4096)
(define  aiProcess_FixInfacingNormals  8192)
(define  aiProcess_SortByPType  32768)
(define  aiProcess_FindDegenerates  65536)
(define  aiProcess_FindInvalidData  131072)
(define  aiProcess_GenUVCoords  262144)
(define  aiProcess_TransformUVCoords  524288)
(define  aiProcess_FindInstances  1048576)
(define  aiProcess_OptimizeMeshes  2097152)
(define  aiProcess_OptimizeGraph  4194304)
(define  aiProcess_FlipUVs  8388608)
(define  aiProcess_FlipWindingOrder  16777216)
(define  aiProcess_SplitByBoneCount  33554432)
(define  aiProcess_Debone 67108864)
(ipc:define "utility"  'aiProcess_CalcTangentSpace  1)
(ipc:define "utility"  'aiProcess_JoinIdenticalVertices  2)
(ipc:define "utility"  'aiProcess_MakeLeftHanded  4)
(ipc:define "utility"  'aiProcess_Triangulate  8)
(ipc:define "utility"  'aiProcess_RemoveComponent  16)
(ipc:define "utility"  'aiProcess_GenNormals  32)
(ipc:define "utility"  'aiProcess_GenSmoothNormals  64)
(ipc:define "utility"  'aiProcess_SplitLargeMeshes  128)
(ipc:define "utility"  'aiProcess_PreTransformVertices  256)
(ipc:define "utility"  'aiProcess_LimitBoneWeights  512)
(ipc:define "utility"  'aiProcess_ValidateDataStructure  1024)
(ipc:define "utility"  'aiProcess_ImproveCacheLocality  2048)
(ipc:define "utility"  'aiProcess_RemoveRedundantMaterials  4096)
(ipc:define "utility"  'aiProcess_FixInfacingNormals  8192)
(ipc:define "utility"  'aiProcess_SortByPType  32768)
(ipc:define "utility"  'aiProcess_FindDegenerates  65536)
(ipc:define "utility"  'aiProcess_FindInvalidData  131072)
(ipc:define "utility"  'aiProcess_GenUVCoords  262144)
(ipc:define "utility"  'aiProcess_TransformUVCoords  524288)
(ipc:define "utility"  'aiProcess_FindInstances  1048576)
(ipc:define "utility"  'aiProcess_OptimizeMeshes  2097152)
(ipc:define "utility"  'aiProcess_OptimizeGraph  4194304)
(ipc:define "utility"  'aiProcess_FlipUVs  8388608)
(ipc:define "utility"  'aiProcess_FlipWindingOrder  16777216)
(ipc:define "utility"  'aiProcess_SplitByBoneCount  33554432)
(ipc:define "utility"  'aiProcess_Debone 67108864)

(bind-type aiString <size_t,|1024,i8|>)
(bind-type aiMatrix4x4 <float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float>)
(bind-type aiMatrix3x3 <float,float,float,float,float,float,float,float,float>)
(bind-type aiVector4D <float,float,float,float>)
(bind-type aiVector3D <float,float,float>)
(bind-type aiVector2D <float,float>)
(bind-type aiColor4D <float,float,float,float>)
(bind-type aiColor3D <float,float,float>)
(bind-type aiQuaternion <float,float,float,float>)
(bind-type aiTexel <i8,i8,i8,i8>) ;; b,g,r,a
(bind-type aiVectorKey <double,aiVector3D>) ;; good
(bind-type aiQuatKey <double,aiQuaternion>) ;; good
(bind-type aiMeshKey <double,i32>) ;; good
(bind-type aiNode <aiString,aiMatrix4x4,aiNode*,i32,aiNode**,i32,i32*,i8*>) ;; good 1144
(bind-type aiFace <i32,i32*>) ;; good
(bind-type aiVertexWeight <i32,float>) ;; good
(bind-type aiBone <aiString,i32,aiVertexWeight*,aiMatrix4x4>) ;; good
(bind-type aiAnimMesh <aiVector3D*,aiVector3D*,aiVector3D*,aiVector3D*,|8,aiColor4D*|,|8,aiVector3D*|,i32>) ;; good
(bind-type aiMesh <i32,i32,i32,aiVector3D*,aiVector3D*,aiVector3D*,aiVector3D*,|8,aiColor4D*|,|8,aiVector3D*|,|8,i32|,aiFace*,i32,aiBone**,i32,aiString,i32,aiAnimMesh**,i64>) ;; i64 on end is padding
(bind-type aiUVTransform <aiVector2D,aiVector2D,float>) ;; good
(bind-type aiMaterialProperty <aiString,i32,i32,i32,i32,i8*>) ;; good
(bind-type aiMaterial <aiMaterialProperty**,i32,i32>) ;; good
(bind-type aiNodeAnim <aiString,i32,aiVectorKey*,i32,aiQuatKey*,i32,aiVectorKey*,i32,i32>) ;; good
(bind-type aiMeshAnim <aiString,i32,aiMeshKey*>) ;; good
(bind-type aiAnimation <aiString,double,double,i32,aiNodeAnim**,i32,aiMeshAnim**>) ;; good
(bind-type aiTexture <i32,i32,|4,i8|,aiTexel*>) ;; good
(bind-type aiLight <aiString,i32,aiVector3D,aiVector3D,float,float,float,aiColor3D,aiColor3D,aiColor3D,float,float>) ;; good
(bind-type aiCamera <aiString,aiVector3D,aiVector3D,aiVector3D,float,float,float,float>) ;; good
(bind-type aiScene <i32,aiNode*,i32,aiMesh**,i32,aiMaterial**,i32,aiAnimation**,i32,aiTexture**,i32,aiLight**,i32,aiCamera**,i8*>) ;; good
(bind-type aiExportFormatDesc <i8*,i8*,i8*>)

(bind-lib libassimp aiImportFile [aiScene*,i8*,i32]*)
(bind-lib libassimp aiExportScene [i32,aiScene*,i8*,i8*,i32]*)
(bind-lib libassimp aiGetExportFormatCount [size_t]*)
(bind-lib libassimp aiGetExportFormatDescription [aiExportFormatDesc*,size_t]*)
(bind-lib libassimp aiReleaseImport [void,aiScene*]*)
(bind-lib libassimp aiIdentityMatrix4 [void,aiMatrix4x4*]*)
(bind-lib libassimp aiMultiplyMatrix4 [void,aiMatrix4x4*,aiMatrix4x4*]*)
(bind-lib libassimp aiTransformVecByMatrix4 [void,aiVector3D*,aiMatrix4x4*]*)
(bind-lib libassimp aiTransposeMatrix4 [void,aiMatrix4x4*]*)
(bind-lib libassimp aiTransposeMatrix3 [void,aiMatrix3x3*]*)
(bind-lib libassimp aiGetMaterialColor [i32,aiMaterial*,i8*,i32,i32,aiColor4D*]*)
(bind-lib libassimp aiGetMaterialString [i32,aiMaterial*,i8*,i32,i32,aiString*]*)
(bind-lib libassimp aiGetMaterialFloatArray [i32,aiMaterial*,i8*,i32,i32,float*,i32*]*)
(bind-lib libassimp aiGetMaterialIntegerArray [i32,aiMaterial*,i8*,i32,i32,i32*,i32*]*)
(bind-lib libassimp aiGetMaterialTexture [i32,aiMaterial*,i32,i32,aiString*,i32*,i32*,float*,i32*,i32*,i32*]*)
(bind-lib libassimp aiGetMaterialTextureCount [i32,aiMaterial*,i32]*)

(bind-lib-func stdlib ai_load_ogl_texture [i32,i8*,i32]*)
(bind-lib-func stdlib ai_load_ogl_texture_from_buffer [i32,i8*,i32,i32]*)
(bind-lib-func stdlib aiGetMaterialFloat [i32,aiMaterial*,i8*,i32,i32,float*]*)
(bind-lib-func stdlib ai_copy_matrix4 [i64,aiMatrix4x4*,aiMatrix4x4*]*)
(bind-lib-func stdlib ai_matrix4_to_float [void,aiMatrix4x4*,float*]*)
(bind-lib-func stdlib aisgl_min [float,float,float]*)
(bind-lib-func stdlib aisgl_max [float,float,float]*)
(bind-lib-func stdlib ai_print_string [i32,aiString*]*)
(bind-lib-func stdlib aiColor4f [void,aiColor4D*]*)
(bind-lib-func stdlib ai_color4_to_float4 [i64,aiColor4D*,float*]*)
(bind-lib-func stdlib ai_apply_material [void,aiMaterial*,i32]*)
(bind-lib-func stdlib ai_build_mesh_vbo [E_vbo*,aiMesh*,i32*]*)
(bind-lib-func stdlib ai_build_mesh [void,aiScene*,aiMesh*,xtm_mesh*,i8*]*)
(bind-lib-func stdlib ai_build_node [void,aiScene*,aiNode*,xtm_node*,xtm_node*,i8*]*)
(bind-lib-func stdlib ai_build_scene [xtm_node*,aiScene*,i8*]*)
(bind-lib-func stdlib assimp_load_model_a [xtm_node*,i8*,i8*,i32]*)
(bind-lib-func stdlib assimp_load_model_b [xtm_node*,i8*,i8*]*)
;; (bind-lib-func stdlib assimp_draw_mesh [void,xtm_mesh*,i32]*)
(bind-lib-func stdlib assimp_draw_node [void,xtm_node*,i32,float*,float*,float*,i32,float*]*)
(bind-lib-func stdlib assimp_draw_model [void,xtm_node*,i32,float*,float*,float*,i32,float*]*)
(bind-lib-func stdlib ai_load_textures [void,aiScene*]*)
(bind-lib-func stdlib ai_print_export_formats [void]*)
(bind-lib-func stdlib ai_convert [void,i8*,i8*,i8*,i32]*)


(bind-poly assimp_load_model assimp_load_model_a)
(bind-poly assimp_load_model assimp_load_model_b)

;; poly has no binding for scheme
(define assimp_load_model
  (lambda (dir file . args)
    (if (null? args)
        (assimp_load_model_b dir file)
        (assimp_load_model_a dir file (car args)))))

(println 'ASSIMP 'LOADED)


;;; AUDIO SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(load "libs/core/pc_ivl.xtm")

;; lib-loading config
(sys:load-preload-check 'audio-inst-ext)

(bind-alias DSP [double,double,double,double,double*]*)

;; bind vals in library
(bind-lib-val stdlib SAMPLERATE double)
(bind-lib-val stdlib SR double)
(bind-lib-val stdlib CHANNELS i64)
(bind-lib-val stdlib IN_CHANNELS i64)
(bind-lib-val stdlib FRAMES i64)

(bind-lib-val stdlib SVF_LOWPASS i64)
(bind-lib-val stdlib SVF_HIGHPASS i64)
(bind-lib-val stdlib SVF_BANDPASS i64)
(bind-lib-val stdlib SVF_NOTCH i64)
(bind-lib-val stdlib SVF_PEAK i64)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; because the vals above rely on current state
;; we need to change their values to reflect
;; our *current* state (i.e. not the state when the
;; dylib was compiled)
;;
;; CHANGE AUDIO VARIABLES TO REFLECT CURRENT STATE 
(bind-func setup_audio_vals
  (lambda (a:double b:i64 c:i64 d:i64)
    (set! SVF_LOWPASS 1)
    (set! SVF_HIGHPASS 2)
    (set! SVF_BANDPASS 3)
    (set! SVF_NOTCH 4)
    (set! SVF_PEAK 5)    
    (set! SAMPLERATE a)
    (set! SR a)
    (set! CHANNELS b)
    (set! IN_CHANNELS c)
    (set! FRAMES d)))

(setup_audio_vals (integer->real *au:samplerate*)
                  *au:channels*
                  *au:in-channels*
                  *au:block-size*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first print the CURRENT audio state
(bind-lib-func stdlib print_audio_state [i32]*)
(bind-wrapper print-audio-state print_audio_state)
;; (print-audio-state)



;; ;; (dirty) check to see if audio_dsp.xtm has already been loaded
;; (if (not (llvm:get-globalvar "SAMPLERATE"))
;;     (load "libs/core/audio_dsp.xtm"))

;; load the libsndfile dynamic library
(define libsndfile
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:open-dylib "libsndfile.so"))
          ((string=? platform "Windows") (sys:open-dylib "libsndfile.dll"))
          ((string=? platform "OSX") (sys:open-dylib "libsndfile.dylib"))
          (else (print "Unknown platform: " platform)))))

(if (or (eq? #f libsndfile)
        (null? libsndfile))
    (sys:load-escape "Error loading libsndfile dynamic library"))

(define *xtmlib-sndfile-loaded* #t)

(bind-type sf_info <i64,i32,i32,i32,i32,i32>)
(bind-type sf_format_info <i32,i8*,i8*>)

(bind-lib libsndfile sf_open [i8*,i8*,i32,sf_info*]*)
(bind-lib libsndfile sf_open_fd [i8*,i32,i32,sf_info*,i32]*)
(bind-lib libsndfile sf_close [i32,i8*]*)
(bind-lib libsndfile sf_seek [i64,i8*,i64,i32]*)
(bind-lib libsndfile sf_write_sync [void,i8*]*)
(bind-lib libsndfile sf_read_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_write_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_strerror [i8*,i8*]*)


;; then bind the rest of the closures
;; NOTE: cant use standard bind-lib because these are closures
(bind-lib-func stdlib dsp [double,double,double,double,double*]*)
(bind-lib-func stdlib dsp_randn [double]*)
(bind-lib-func stdlib range_limit [double,double,double,double]*)
(bind-lib-func stdlib _sin [double,double]*)
(bind-lib-func stdlib osc_c [[double,double,double]*,double]*)
(bind-lib-func stdlib osc_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib square_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib square_mc_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib integrator_c [double,double]*)
(bind-lib-func stdlib triangle_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib triangle_mc_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib rect_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib saw_c [[double,double,double]*,double]*)
(bind-lib-func stdlib saw_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib white_c [[double]*]*)
(bind-lib-func stdlib pink_c [[double]*]*)
(bind-lib-func stdlib pulse_c [[double,double,double,double]*]*)
(bind-lib-func stdlib pulse_mc_c [[double,double,double,double,double]*]*)
(bind-lib-func stdlib delay_old_c [[double,double]*,i64]*)
(bind-lib-func stdlib delay_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib delay_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib delay_t_c [[double,double,double,double,double]*,double,double]*)
(bind-lib-func stdlib delay_t_mc_c [[double,double,double,double,double,double]*,i64,double,double]*)
(bind-lib-func stdlib delay_t_st_c [[double,double,double,double,double,double]*,double,double,double]*)
(bind-lib-func stdlib comb_old_c [[double,double,double]*,i64]*)
(bind-lib-func stdlib comb_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib comb_mc_c [[double,double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib flanger_c [[double,double,double,double]*,double,double,double,double]*)
(bind-lib-func stdlib flanger_mc_c [[double,double,double,double,double]*,i64,double,double,double,double]*)
(bind-lib-func stdlib chorus_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib chorus_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib tap_delay_c [[double,double]*,i64,i64]*)
(bind-lib-func stdlib allpass_old_c [[double,double]*,i64]*)
(bind-lib-func stdlib allpass_c [[double,double,double]*,double]*)
(bind-lib-func stdlib allpass_mc_c [[double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib reverb_old_c [[double,double,double]*,double]*)
(bind-lib-func stdlib reverb_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib reverb_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib reverb2_c [[double,double,double]*,double]*)
(bind-lib-func stdlib reverb2_mc_c [[double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib crusher_c [[double,double,double]*]*)
(bind-lib-func stdlib hold3_c [[double,double,double]*]*)
(bind-lib-func stdlib hold_mc_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib crush [double,double,double]*)
(bind-lib-func stdlib distort_c [[double,double]*,double]*)
(bind-lib-func stdlib pan2 [double,double,double,double]*)
(bind-lib-func stdlib pan_mc [[double,double,double,double]*,double]*)
(bind-lib-func stdlib mix2 [double,double,double,double,double]*)
(bind-lib-func stdlib mix4 [double,double,double,double,double,double,double]*)
(bind-lib-func stdlib mixer_c [[double,double*,double,double]*,i64]*)
(bind-lib-func stdlib lpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib lpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib hpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib hpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib bpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib bpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib notch_c [[double,double,double,double]*]*)
(bind-lib-func stdlib notch_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib hilbert_c [[double,double]*,i64]*)
(bind-lib-func stdlib env_follow_c [[double,double]*,i64]*)
(bind-lib-func stdlib vcf_old_c [[double,double,double,double]*]*)
(bind-lib-func stdlib vcf1_c [[double,double,double,double]*]*)
(bind-lib-func stdlib vcf_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib vcf3_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib vcf_mc_c [[double,double,double,double,double]*,i64,i64]*)
(bind-lib-func stdlib min2d [double,double,double]*)
(bind-lib-func stdlib svf_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib overdrive_c [[double,double]*,double]*)
(bind-lib-func stdlib saturation_c [[double,double,double,double]*]*)
(bind-lib-func stdlib ringmod_c [[double,double,double,double]*]*)
(bind-lib-func stdlib hann_c [[double,double]*]*)
(bind-lib-func stdlib hann_mc_c [[double,double,double]*]*)
(bind-lib-func stdlib hann_t_c [[double,double,double]*,double]*)
(bind-lib-func stdlib hann_t_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib hann_e_c [[double,double,double,double]*]*)
(bind-lib-func stdlib hann [double,double,double,double]*)
(bind-lib-func stdlib impulse [double,double,double]*)
(bind-lib-func stdlib linear_c [[double,double]*,double,double,double]*)
(bind-lib-func stdlib linear_mc_c [[double,double,double]*,double,double,double]*)
(bind-lib-func stdlib line_c [[double,double]*,double,double,double,double]*)
(bind-lib-func stdlib envelope_segments [[double,double]**,double*,i64]*)
(bind-lib-func stdlib envelope_c [[double,double]*,double*,i64]*)
(bind-lib-func stdlib adsr_c [[double,double]*,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib adsr_accum_c [[double,double,double]*,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib hermite_interp [double,double,double,double,double,double]*)
(bind-lib-func stdlib fade_c [[double,double,double]*,double]*)
(bind-lib-func stdlib midi2frq [double,double]*)
(bind-lib-func stdlib frq2midi [double,double]*)
(bind-lib-func stdlib note_c [[double,double,double,double]*,double,double,double,double,double,double,double,double,double*,i64,[double,double,double,double,double]*,mzone*]*)
(bind-lib-func stdlib _play_note [i64,double,[double,double,double,double,double*]*,double,double,double,i64,double*]*)
(bind-lib-func stdlib default_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib default_fx [double,double,double,double,double*]*)
(bind-lib-func stdlib definst [double,double,double,double,double*]*)
(bind-lib-func stdlib synth_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib synth_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib synth [double,double,double,double,double*]*)
(bind-lib-func stdlib epad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib epad_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib epad [double,double,double,double,double*]*)
(bind-lib-func stdlib organ_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib organ_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib fuzz_bass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib fuzz_bass_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fuzz_bass [double,double,double,double,double*]*)
(bind-lib-func stdlib shimmer_pad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib shimmer_pad_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib shimmer_pad [double,double,double,double,double*]*)
(bind-lib-func stdlib simplefm_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib simplefm_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fmsynth [double,double,double,double,double*]*)
(bind-lib-func stdlib fmpad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib fmpad_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fmpad [double,double,double,double,double*]*)
(bind-lib-func stdlib sawbass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib sawbass_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sawbass [double,double,double,double,double*]*)
(bind-lib-func stdlib subbass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib subbass_fx [double,double,double,double,double*]* 100000)
(bind-lib-func stdlib subbass [double,double,double,double,double*]*)
(bind-lib-func stdlib sf_frames [i64,sf_info*]*)
(bind-lib-func stdlib sf_samplerate [i64,sf_info*]*)
(bind-lib-func stdlib sf_channels [i64,sf_info*]*)
(bind-lib-func stdlib sf_format [i64,sf_info*]*)
(bind-lib-func stdlib sf_sections [i64,sf_info*]*)
(bind-lib-func stdlib sf_seekable [i64,sf_info*]*)
(bind-lib-func stdlib print_audio_file_info [i32,i8*]*)
(bind-lib-func stdlib read_audio_data [i64,i8*,double*,i64,i64]*)
(bind-lib-func stdlib audiofile_c [[double]*,i8*,i64,i64]*)
(bind-lib-func stdlib audiofile_ptr_c [[double*]*,i8*,i64,i64]*)
(bind-lib-func stdlib write_audio_data [i64,i8*,i64,i32,double*]*)
(bind-lib-func stdlib set_sample_data_ [i64,[double,double,double,double*]*,i8*,i64,i64,i64]*)
(bind-lib-func stdlib set_sample_offset_ [i64,[double,double,double,double*]*,i64,i64]*)
(bind-lib-func stdlib sampler_note_linear_c [[double,double,double,double,double]*,|128,double*|*,|128,i64|*,|128,i64|*,i64,double]*)
(bind-lib-func stdlib sampler_note_hermite_c [[double,double,double,double,double]*,|128,double*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,double]*)
(bind-lib-func stdlib sampler1_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler2_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler3_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler1 [double,double,double,double,double*]*)
(bind-lib-func stdlib sampler2 [double,double,double,double,double*]*)
(bind-lib-func stdlib sampler3 [double,double,double,double,double*]*)

(define-macro (play-note time inst pitch vol dur . args)  
  (let ((nargs (length args)))
    `(let ((duration (* 1.0 ,dur))
           (dargs (sys:make-cptr ,(* 8 nargs))) ;; doubles
           (native (llvm:get-native-closure ,(symbol->string inst))))
       (dotimes (i ,nargs) (cptr:set-double dargs (* i 8) (eval (list-ref ',args i))))
       (if (cptr? native)
           (_play_note (integer->real ,time)
                       native
                       (midi2frq (* 1.0 ,pitch))
                       (/ (exp (/ ,vol 26.222)) 127.0)
                       duration
                       ,nargs
                       dargs)
           (print-error 'No 'inst 'named ,(symbol->string inst))))))


;; the play macro
(macro (play args)
  (if (symbol? (cadr args))
      `(play-note (*metro* beat) ,(cadr args) ,(caddr args) ,(cadddr args) (*metro* 'dur ,(car (cddddr args)))
                  ,@(cdr (cddddr args)))
      `(play-note (*metro* (+ beat ,(cadr args))) ,(caddr args) ,(cadddr args) ,(car (cddddr args))
                  (*metro* 'dur ,(car (cdr (cddddr args))))
                  ,@(cddr (cddddr args)))))


;; a macro for making extemore instruments
;; see http://benswift.me/2012-09-28-making-an-instrument.html
(define-macro (define-instrument name note_kernel effect_kernel)
  `(bind-func ,name
     (let* ((poly:i64 48)
	    (notes:[double,double,double,double]** (zalloc poly))
	    (attack:double 200.0)
	    (decay:double 200.0)
	    (release:double 1000.0)
	    (sustain:double 0.6) ;; amplitude of the sustain
	    (gain 2.0)
	    (ii 0)
	    (note_starts:double* (zalloc poly))
	    (new_note (lambda (start freq dur amp nargs:i64 dargs)
			(let ((free_note:i64 -1)
			      (iii 0)
			      (i 0))
			  (dotimes (i poly) ;; check for free poly spot           
			    (if (> (pref note_starts i) 9999999999998.0)
				(set! free_note i)))
			  (if (> free_note -1) ;; if we found a free poly spot assign a note
			      (let ((note_zone (push_zone (* 1024 10))))
				(pset! notes free_note
				       (note_c start freq amp dur
                                               attack decay release sustain
                                               note_starts free_note
                                               (,note_kernel nargs dargs)
                                               note_zone))
				(pset! note_starts free_note start)
				(pop_zone)
				1)
			      0)))))
       (dotimes (ii poly) ;; sets all notes to inactive
	 (pset! note_starts ii 9999999999999.0))
       (lambda (in:double time:double chan:double dat:double*)
	 (let ((out:double 0.0)
	       (k 0))
	   (dotimes (k poly) ;; sum all active notes          
	     (if (< (pref note_starts k) time)
		 (set! out (+ out (* 0.3 ((pref notes k) in time chan))))))
	   (* gain (,effect_kernel out time chan dat)))))))


;; make sampler instrument
(define-macro (define-sampler name note_kernel effect_kernel)
  `(bind-func ,name
     (let ((poly:i64 48)
           (samples:|128,double*|* (zalloc)) ;; 128 samples
           (samples_length:|128,i64|* (zalloc)) ;; 128 samples
           (samples_channels:|128,i64|* (zalloc)) ;; 128 samples
           (samples_offsets:|128,i64|* (zalloc)) ;; 128 samples
           (notes:[double,double,double,double]** (zalloc poly))
           (attack:double 200.0)
           (decay:double 200.0)
           (release:double 1000.0)
           (sustain:double 1.0) ;; amplitude of the sustain
           (gain:double 2.0)
           (kk:i64 0) (ii:i64 0)
           ;;(active:i64 0)
           (note_starts:double* (zalloc poly))
           (new_note (lambda (start freq dur amp nargs:i64 dargs:double*)
                       (let ((free_note:i64 -1)
                             (idx (dtoi64 (floor (frq2midi freq))))
                             (closest 1000000)
                             (i:i64 0) (iii:i64 0) (idxi:i64 0)
                             (new_idx idx))
                         (dotimes (i poly) ;; check for free poly spot
                           (if (> (pref note_starts i) 9999999999998.0)
                               (set! free_note i)))
                         (if (> free_note -1) ;; if we found a free poly spot assign a note
                             (begin (dotimes (idxi 128)
                                      (let ((v (llabs (- idx idxi))))
                                        (if (and (<> (aref samples_length idxi) 0)
                                                 (< v closest))
                                            (begin (set! new_idx idxi)
                                                   (set! closest v) 0))))
                                    (let ((note_zone (push_zone (* 1024 10))))
                                      (pset! notes free_note
                                             (note_c start freq amp dur
                                                        attack decay release sustain
                                                        note_starts free_note
                                                        (if (> nargs 0)
                                                            (,note_kernel samples samples_length samples_offsets samples_channels new_idx (pref dargs 0))
                                                            (,note_kernel samples samples_length samples_offsets samples_channels new_idx 0.0))                                                        
                                                        note_zone))
                                      (pset! note_starts free_note start)
                                      (pop_zone))
                                    1)
                             0)))))
       (dotimes (kk 128)
	 (aset! samples_offsets kk 0)
	 (aset! samples_length kk 0))
       (dotimes (ii poly) ;; sets all notes to inactive
	 (pset! note_starts ii 9999999999999.0))
       (lambda (in:double time:double chan:double dat:double*)
	 (let ((out:double 0.0)
	       (k:i64 0))
	   (dotimes (k poly) ;; sum all active notesx
	     (if (< (pref note_starts k) time)
		 (set! out (+ out (* 0.3 ((pref notes k) in time chan))))))
	   (* gain (,effect_kernel out time chan dat)))))))




;; passing a length of 0 will read the whole file
(define-macro (set-sampler-index inst fname index offset lgth)
  `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
     (if (cptr? native)
         (set_sample_data_ native
                           ,fname
                           (real->integer ,index)
                           (real->integer ,offset)
                           (real->integer ,lgth)))))


;; passing a length of 0 will read the whole file
(define-macro (set-sampler-index inst fname index offset lgth)
  `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
     (if (and (cptr? native)
              (> ,index 0)
              (< ,index 128))
         (set_sample_data_ native
                           ,fname
                           (real->integer ,index)
                           (real->integer ,offset)
                           (real->integer ,lgth)))))

;; (set-sample-offset sampler 60 50000)
;; this would offset the sample at index 60 by 50000 samples
;; (define-macro (set-sample-offset inst index offset)
;;   `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
;;      (if (cptr? native)
;; 	 (set_sample_offset_ native
;; 			     (real->integer ,index)
;; 			     (real->integer ,offset)))))


(define note-name-to-midi-number
  (lambda (name)
    (let ((result (regex:matched name "([ABCDEFG])([#b])?(-?[0-9])")))
        (if (null? result)
            #f
            (let ((offset (+ 12 (* (string->number (cadddr result)) 12)))
                  (pc (case (modulo (- (modulo (char->integer (car (string->list (cadr result)))) 16) 3) 7)
                        ((0) 0) ((1) 2) ((2) 4) ((3) 5) ((4) 7) ((5) 9) ((6) 11))))
              (+ offset pc
                 (cond ((string=? (caddr result) "#") 1)
                       ((string=? (caddr result) "b") -1)
                       (else 0))))))))

;; this will match e.g. 60.aiff (where 60 is the midi note number)
(define parse-sample-names-1
  (lambda (file-list)
    (map (lambda (fname)
           (let ((result (regex:matched fname "([0-9]*)\.(wav|aif|aiff|ogg)$")))
             (if (null? result)
                 (begin (println 'Error: 'cannot 'parse 'filename: fname)
                        #f)
                 (list fname                          ; filename    
                       (string->number (cadr result)) ; midi note number
                       0                              ; offset
                       0))))                          ; length (0 for whole sample)
         file-list)))

;; this will match e.g. Eb3.aiff (representing E flat 3)
(define parse-sample-names-2
  (lambda (file-list)
    (map (lambda (fname)
           (let ((result (regex:matched fname "^.*([ABCDEFG][#b]?[0-9]).*\.(wav|aif|aiff|ogg)$")))
             (if (null? result)
                 (begin (println 'Error: 'cannot 'parse 'filename: fname)
                        #f)
                 (list fname                                    ; filename                   
                       (note-name-to-midi-number (cadr result)) ; midi note number           
                       0                                        ; offset                     
                       0))))                                    ; length (0 for whole sample)
         file-list)))


;; must be stereo samples of type wav aif or ogg
(define-macro (load-sampler sampler path . args)
  (let ((parser (if (null? args) 'parse-sample-names-1 (car args)))
        (midioffset (if (= (length args) 2) (cadr args) 0)))
    `(let ((file-list (sys:directory-list ,path)))
       (for-each (lambda (samp-data)
                   (if samp-data
                       (set-sampler-index ,sampler
                                          (if (string=? (sys:platform) "Windows")
                                              (car samp-data)
                                              (string-append ,path "/" (car samp-data)))
                                          (+ ,midioffset (cadr samp-data))
                                          (caddr samp-data)
                                          (cadddr samp-data))))
                 (,parser file-list)))))




(define ipc:audio-setup
  (lambda (proc)
    (ipc:eval-string proc
                     "(define-macro (play-note time inst pitch vol dur . args)  
                       (let ((nargs (length args)))
                         `(let ((duration (* 1.0 ,dur))
                                (dargs (sys:make-cptr ,(* 8 nargs))) ;; doubles
                                (native (llvm:get-native-closure ,(symbol->string inst))))
                            (dotimes (i ,nargs) (cptr:set-double dargs (* i 8) (eval (list-ref ',args i))))
                            (if (cptr? native)
                                (_play_note (integer->real ,time)
                                            native
                                            (midi2frq (* 1.0 ,pitch))
                                            (/ (exp (/ ,vol 26.222)) 127.0)
                                            duration
                                            ,nargs
                                            dargs)
                                (print-error 'No 'inst 'named ,(symbol->string inst))))))
                     ;; passing a length of 0 will read the whole file
                     (define-macro (set-sampler-index inst fname index offset lgth)
                       `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
                          (if (cptr? native)
                              (set_sample_data_ native
                                                ,fname
                                                (real->integer ,index)
                                                (real->integer ,offset)
                                                (real->integer ,lgth)))))
                     ;; this will match e.g. 60.aiff (where 60 is the midi note number)
                     (define parse-sample-names-1
                       (lambda (file-list)
                         (map (lambda (fname)
                                (let ((result (regex:matched fname \"([0-9]*)\.(wav|aif|aiff|ogg)$\")))
                                  (if (null? result)
                                      (begin (println 'Error: 'cannot 'parse 'filename: fname)
                                             #f)
                                      (list fname                          
                                            (string->number (cadr result)) 
                                            0                              
                                            0))))                          
                              file-list)))
                     ;; must be stereo samples of type wav aif or ogg
                     (define-macro (load-sampler sampler path . args)
                       (let ((parser (if (null? args) 'parse-sample-names-1 (car args))))
                         `(let ((file-list (sys:directory-list ,path)))
                            (for-each (lambda (samp-data)
                                        (if samp-data
                                            (set-sampler-index ,sampler
                                                               (if (string=? (sys:platform) \"Windows\")
                                                                   (car samp-data)
                                                                   (string-append ,path \"/\" (car samp-data)))
                                                               (cadr samp-data)
                                                               (caddr samp-data)
                                                               (cadddr samp-data))))
                                      (,parser file-list)))))
                     ;; (set-sample-offset sampler 60 50000)
                     ;; this would offset the sample at index 60 by 50000 samples
                     (define-macro (set-sample-offset inst index offset)
                       `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
                          (if (cptr? native)
                              (set_sample_offset_ native
                                                  (real->integer ,index)
                                                  (real->integer ,offset)))))
                     ;; the play macro
                     (macro (play args)
                            (if (symbol? (cadr args))
                                `(play-note (*metro* beat) ,(cadr args) ,(caddr args) ,(cadddr args) (*metro* 'dur ,(car (cddddr args)))
                                            ,@(cdr (cddddr args)))
                                `(play-note (*metro* (+ beat ,(cadr args))) ,(caddr args) ,(cadddr args) ,(car (cddddr args))
                                            (*metro* 'dur ,(car (cdr (cddddr args))))
                                            ,@(cddr (cddddr args)))))")
    (ipc:bind-func proc '_play_note)
    (ipc:bind-func proc 'midi2frq)))

;; (ipc:audio-setup "utility")

;;;;;;;
;; setup some instrument parameters

(subbass.attack 500.0)
(subbass.decay 500.0)
(subbass.sustain 0.8)
(subbass.release 500.0)

(define *xtmlib-audio-inst-ext-loaded* #t)

(println 'AUDIO 'LOADED)

(suppress-compiler-messages #f)

(println)
(println 'Finished 'loading 'xtm 'standard 'lib)
(println)

(define *xtmlib-stdlib-loaded* #t)
