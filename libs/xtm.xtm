;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; to compile xtm.{dylib,so,dll} shared library (for faster loading)

;; ;; first compile the xtlang code you want in the shared lib

;; (sys:load "libs/core/math.xtm")
;; (sys:load "libs/core/audio_dsp.xtm")
;; (sys:load "libs/core/instruments.xtm")
;; (sys:load "libs/external/instruments.xtm")
;; (sys:load "libs/external/opengl.xtm")
;; (sys:load "libs/external/shaders.xtm")
;; (sys:load "libs/external/assimp.xtm")
;; (sys:load "libs/external/sndfile.xtm")
;; (sys:load "libs/external/openvg.xtm")
;; (sys:load "libs/external/drawtext.xtm")
;; (println 'done 'loading!)
;; (llvm-export-current-xtlang-module "xtm")

;; ;; Then compile bitcode into a shared lib

;; Linux:
;; /path/to/llvm-3.2/Release/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && gcc --shared -g /tmp/xtm.s -o ./xtm.so

;; OSX:
;; /usr/local/Cellar/extempore-llvm/3.2/bin/llc -O3 -relocation-model=pic -tailcallopt /tmp/xtm.bc && clang -O3 -dynamiclib -undefined dynamic_lookup /tmp/xtm.s -o ./xtm.dylib

;; emacs regex for generating the header file:
;; Compiled \(.*\) >>> \(.*\) -> (bind-lib-func stdlib \1 \2)

;; lib-loading config
(sys:load-preload-check 'stdlib)

(define stdlib
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libs/xtm.so"))
          ((string=? platform "Windows") (sys:load-dylib "libs/xtm.dll"))
          ((string=? platform "OSX") (sys:load-dylib "libs/xtm.dylib"))
          (else (print "Unknown platform: " platform) #f))))

(if (or (eq? #f stdlib)
	(not stdlib)) 
    (sys:load-escape "Could not load 'xtm' dynamic library"))

(ascii-print-color 0 6 10)
(println)
(print 'Loading 'xtm 'standard 'lib '...)
(ascii-print-color 0 7 10)
(println)
(println)
(suppress-compiler-messages #t)

;;;;;;  MATH SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config
(sys:load-preload-check 'math)

(print "Loading math library...        ")
(define *xtmlib-math-loaded* #f)

(bind-type cpxd <double,double>)
(bind-type cpxf <float,float>)

(bind-lib-func stdlib deg2rad_f [float,float]*)
(bind-lib-func stdlib deg2rad_d [double,double]*)
(bind-lib-func stdlib rad2deg_f [float,float]*)
(bind-lib-func stdlib rad2deg_d [double,double]*)
(bind-lib-func stdlib randn [double]*)
(bind-lib-func stdlib vprintd [void,double*,i64]*)
(bind-lib-func stdlib vprintf [void,float*,i64]*)
(bind-lib-func stdlib vnormd [void,double*,i64,double*]*)
(bind-lib-func stdlib vnormf [void,float*,i64,float*]*)
(bind-lib-func stdlib vmagd [double,double*,i64]*)
(bind-lib-func stdlib vmagf [float,float*,i64]*)
(bind-lib-func stdlib vdotd [double,double*,double*,i64]*)
(bind-lib-func stdlib vdotf [float,float*,float*,i64]*)
(bind-lib-func stdlib vcrossd [void,double*,double*,double*]*)
(bind-lib-func stdlib vcrossf [void,float*,float*,float*]*)
(bind-lib-func stdlib vsmuld [void,double,double*,i64,double*]*)
(bind-lib-func stdlib vsmulf [void,float,float*,i64,float*]*)
(bind-lib-func stdlib vsdivd [void,double,double*,i64,double*]*)
(bind-lib-func stdlib vsdivf [void,float,float*,i64,float*]*)
(bind-lib-func stdlib vsumd [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vsumf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vsubd [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vsubf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vmuld [void,double*,double*,i64,double*]*)
(bind-lib-func stdlib vmulf [void,float*,float*,i64,float*]*)
(bind-lib-func stdlib vaquatd [void,double,double*,double*]*)
(bind-lib-func stdlib vaquatf [void,float,float*,float*]*)
(bind-lib-func stdlib mprintd [void,double*,i64,i64,i1]*)
(bind-lib-func stdlib mprintf [void,float*,i64,i64,i1]*)
(bind-lib-func stdlib mprinti64 [void,i64*,i64,i64,i1]*)
(bind-lib-func stdlib mprinti32 [void,i32*,i64,i64,i1]*)
(bind-lib-func stdlib mmuld [double*,double*,i64,i64,double*,i64,i64,double*]*)
(bind-lib-func stdlib mmulf [float*,float*,i64,i64,float*,i64,i64,float*]*)
(bind-lib-func stdlib mmuli64 [i64*,i64*,i64,i64,i64*,i64,i64,i64*]*)
(bind-lib-func stdlib mmuli32 [i32*,i32*,i64,i64,i32*,i64,i64,i32*]*)
(bind-lib-func stdlib mtransd [double*,double*,i64,i64,double*]*)
(bind-lib-func stdlib mtransf [float*,float*,i64,i64,float*]*)
(bind-lib-func stdlib mdetrmd [double,double*,i64]*)
(bind-lib-func stdlib mdetrmf [float,float*,i64]*)
(bind-lib-func stdlib minvd [void,double*,i64,double*]*)
(bind-lib-func stdlib minvf [void,float*,i64,float*]*)
(bind-lib-func stdlib mcopyd [void,double*,i64,i64,double*]*)
(bind-lib-func stdlib mcopyf [void,float*,i64,i64,float*]*)
(bind-lib-func stdlib rot_matrix_about_axis_d [double*,double,double*,double*]*)
(bind-lib-func stdlib rot_matrix_about_axis_f [float*,float,float*,float*]*)
(bind-lib-func stdlib conjugate_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib conjugate_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib magnitude_squared_cpxf [float,cpxf*]*)
(bind-lib-func stdlib magnitude_squared_cpxd [double,cpxd*]*)
(bind-lib-func stdlib magnitude_cpxf [float,cpxf*]*)
(bind-lib-func stdlib magnitude_cpxd [double,cpxd*]*)
(bind-lib-func stdlib phase_cpxf [float,cpxf*]*)
(bind-lib-func stdlib phase_cpxd [double,cpxd*]*)
(bind-lib-func stdlib cart_to_pol_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib pol_to_cart_cpxf [cpxf*,cpxf*]*)
(bind-lib-func stdlib cart_to_pol_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib pol_to_cart_cpxd [cpxd*,cpxd*]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxf [void,float*,float*,cpxf*,i64]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxd [void,double*,double*,cpxd*,i64]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxf_reonly [void,float*,cpxf*,i64]*)
(bind-lib-func stdlib fill_cpx_buffer_cpxd_reonly [void,double*,cpxd*,i64]*)
(bind-lib-func stdlib pour_cpx_buffer_cpxf [void,cpxf*,float*,float*,i64]*)
(bind-lib-func stdlib pour_cpx_buffer_cpxd [void,cpxd*,double*,double*,i64]*)
(bind-lib-func stdlib pour_cpx_buffer_cpxf_reonly [void,cpxf*,float*,i64]*)
(bind-lib-func stdlib pour_cpx_buffer_cpxd_reonly [void,cpxd*,double*,i64]*)

(bind-lib-func stdlib cpxd_add [cpxd*,cpxd*,cpxd*]*)
(bind-lib-func stdlib cpxf_add [cpxf*,cpxf*,cpxf*]*)
(bind-lib-func stdlib cpxd_add_buf [void,cpxd*,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib cpxf_add_buf [void,cpxf*,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib cpxd_sub [cpxd*,cpxd*,cpxd*]*)
(bind-lib-func stdlib cpxf_sub [cpxf*,cpxf*,cpxf*]*)
(bind-lib-func stdlib cpxd_sub_buf [void,cpxd*,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib cpxf_sub_buf [void,cpxf*,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib cpxd_mul [cpxd*,cpxd*,cpxd*]*)
(bind-lib-func stdlib cpxf_mul [cpxf*,cpxf*,cpxf*]*)
(bind-lib-func stdlib cpxd_mul_buf [void,cpxd*,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib cpxf_mul_buf [void,cpxf*,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib cpxd_div [cpxd*,cpxd*,cpxd*]*)
(bind-lib-func stdlib cpxf_div [cpxf*,cpxf*,cpxf*]*)
(bind-lib-func stdlib cpxd_div_buf [void,cpxd*,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib cpxf_div_buf [void,cpxf*,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib cpxd_print [void,cpxd*]*)
(bind-lib-func stdlib cpxf_print [void,cpxf*]*)

(bind-lib-func stdlib conjugate_buffer_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib conjugate_buffer_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_cart_to_pol_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_pol_to_cart_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_cart_to_pol_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_pol_to_cart_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib buffer_re_only_cpxf [void,cpxf*,float*,i64]*)
(bind-lib-func stdlib buffer_im_only_cpxf [void,cpxf*,float*,i64]*)
(bind-lib-func stdlib buffer_re_only_cpxd [void,cpxd*,double*,i64]*)
(bind-lib-func stdlib buffer_im_only_cpxd [void,cpxd*,double*,i64]*)
(bind-lib-func stdlib buffer_cpxd_to_cpxf [void,cpxd*,cpxf*,i64]*)
(bind-lib-func stdlib buffer_cpxf_to_cpxd [void,cpxf*,cpxd*,i64]*)
(bind-lib-func stdlib window_hamming [void,double*,i64]*)
(bind-lib-func stdlib window_hanning [void,double*,i64]*)


(bind-poly deg2rad deg2rad_d)
(bind-poly deg2rad deg2rad_f)
(bind-poly rad2deg rad2deg_d)
(bind-poly rad2deg rad2deg_f)
(bind-poly vprint vprintd)
(bind-poly vprint vprintf)
(bind-poly vnorm vnormd)
(bind-poly vnorm vnormf)
(bind-poly vmag vmagd)
(bind-poly vmag vmagf)
(bind-poly vdot vdotd)
(bind-poly vdot vdotf)
(bind-poly vcross vcrossd)
(bind-poly vcross vcrossf)
(bind-poly vsmul vsmuld)
(bind-poly vsmul vsmulf)
(bind-poly vsdiv vsdivd)
(bind-poly vsdiv vsdivf)
(bind-poly vsum vsumd)
(bind-poly vsum vsumf)
(bind-poly vsub vsubd)
(bind-poly vsub vsubf)
(bind-poly vmul vmuld)
(bind-poly vmul vmulf)
(bind-poly vmag vmagd)
(bind-poly vmag vmagf)
(bind-poly vaquat vaquatd)
(bind-poly vaquat vaquatf)
(bind-poly mprint mprintd)
(bind-poly mprint mprintf)
(bind-poly mprint mprinti64)
(bind-poly mprint mprinti32)
(bind-poly mmul mmuld)
(bind-poly mmul mmulf)
(bind-poly mmul mmuli64)
(bind-poly mmul mmuli32)
(bind-poly mtrans mtransd)
(bind-poly mtrans mtransf)
(bind-poly mdetrm mdetrmd)
(bind-poly mdetrm mdetrmf)
(bind-poly minv minvd)
(bind-poly minv minvf)
(bind-poly mcopy mcopyf)
(bind-poly mcopy mcopyd)
(bind-poly rot_matrix_about_axis rot_matrix_about_axis_d)
(bind-poly rot_matrix_about_axis rot_matrix_about_axis_f)
(bind-poly conjugate_cpx conjugate_cpxf)
(bind-poly conjugate_cpx conjugate_cpxd)
(bind-poly magnitude_squared_cpx magnitude_squared_cpxf)
(bind-poly magnitude_squared_cpx magnitude_squared_cpxd)
(bind-poly magnitude_cpx magnitude_cpxf)
(bind-poly magnitude_cpx magnitude_cpxd)
(bind-poly phase_cpx phase_cpxf)
(bind-poly phase_cpx phase_cpxd)
(bind-poly cart_to_pol cart_to_pol_cpxf)
(bind-poly cart_to_pol cart_to_pol_cpxd)
(bind-poly pol_to_cart pol_to_cart_cpxf)
(bind-poly pol_to_cart pol_to_cart_cpxd)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxf)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxd)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxf_reonly)
(bind-poly fill_cpx_buffer fill_cpx_buffer_cpxd_reonly)
(bind-poly pour_cpx_buffer pour_cpx_buffer_cpxf)
(bind-poly pour_cpx_buffer pour_cpx_buffer_cpxd)
(bind-poly pour_cpx_buffer pour_cpx_buffer_cpxf_reonly)
(bind-poly pour_cpx_buffer pour_cpx_buffer_cpxd_reonly)
(bind-poly conjugate_buffer_cpx conjugate_buffer_cpxf)
(bind-poly conjugate_buffer_cpx conjugate_buffer_cpxd)
(bind-poly buffer_cart_to_pol buffer_cart_to_pol_cpxf)
(bind-poly buffer_cart_to_pol buffer_cart_to_pol_cpxd)
(bind-poly buffer_pol_to_cart buffer_pol_to_cart_cpxf)
(bind-poly buffer_pol_to_cart buffer_pol_to_cart_cpxd)
(bind-poly buffer_re_only buffer_re_only_cpxf)
(bind-poly buffer_im_only buffer_re_only_cpxf)
(bind-poly buffer_re_only buffer_re_only_cpxd)
(bind-poly buffer_im_only buffer_re_only_cpxd)
(bind-poly cpxadd cpxf_add)
(bind-poly cpxadd cpxd_add)
(bind-poly cpxadd cpxf_add_buf)
(bind-poly cpxadd cpxd_add_buf)
(bind-poly cpxsub cpxf_sub)
(bind-poly cpxsub cpxd_sub)
(bind-poly cpxsub cpxf_sub_buf)
(bind-poly cpxsub cpxd_sub_buf)
(bind-poly cpxdiv cpxf_mul)
(bind-poly cpxdiv cpxd_mul)
(bind-poly cpxdiv cpxf_mul_buf)
(bind-poly cpxdiv cpxd_mul_buf)
(bind-poly cpxdiv cpxf_div)
(bind-poly cpxdiv cpxd_div)
(bind-poly cpxdiv cpxf_div_buf)
(bind-poly cpxdiv cpxd_div_buf)
(bind-poly cpxprint cpxf_print)
(bind-poly cpxprint cpxd_print)           


(define *xtmlib-math-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;; FFT   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'fft)

(define kissfft
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "kiss_fft.so"))
          ((string=? platform "Windows") (sys:load-dylib "kiss_fft.dll"))
          ((string=? platform "OSX") (sys:load-dylib "kiss_fft.dylib"))
          (else (print "Unknown platform: " platform)))))

(define *xtmlib-fft-loaded* #f)
(print "Loading FFT library...         ")

(bind-type kiss_fft_cpx <float,float>)
(bind-type kiss_fft_state <i32,i32,|64,i32|,|1,kiss_fft_cpx|>)
(bind-alias kiss_fft_cfg kiss_fft_state*)

(bind-lib kissfft kiss_fft_alloc [kiss_fft_cfg,i32,i32,i8*,i64*]*)
(bind-lib kissfft kiss_fft [i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*]*)
(bind-lib kissfft kiss_fft_stride [i8*,kiss_fft_cfg,kiss_fft_cpx*,kiss_fft_cpx*,i32]*)
(bind-lib kissfft kiss_fft_cleanup [i8*,i8*]*)
(bind-lib kissfft kiss_fft_next_fast_size [i32,i32]*)

(bind-lib-func stdlib fft_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib fft_cpxd [void,cpxd*,cpxd*,i64]*)
(bind-lib-func stdlib inverse_fft_cpxf [void,cpxf*,cpxf*,i64]*)
(bind-lib-func stdlib inverse_fft_cpxd [void,cpxd*,cpxd*,i64]*)

(bind-poly fft fft_cpxf)
(bind-poly fft fft_cpxd)
(bind-poly ifft inverse_fft_cpxf)
(bind-poly ifft inverse_fft_cpxd)
(bind-poly inverse_fft inverse_fft_cpxf)
(bind-poly inverse_fft inverse_fft_cpxd)

(define *xtmlib-fft-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)


;;; AUDIO SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load "libs/core/pc_ivl.xtm")

(sys:load-preload-check 'audio-inst-ext)
;; set *all* audio lib symbols
(define *xtmlib-audio-dsp-loaded* #f)
(define *xtmlib-audio-inst-loaded* #f)
(define *xtmlib-audio-inst-ext-loaded* #f)
(print "Loading audio library...       ")

(bind-alias DSP [double,double,double,double,double*]*)
(bind-alias DSPMT [double,double*,double,double,double*]*)

;; bind vals in library
(bind-lib-val stdlib SAMPLERATE double)
(bind-lib-val stdlib SR double)
(bind-lib-val stdlib CHANNELS i64)
(bind-lib-val stdlib IN_CHANNELS i64)
(bind-lib-val stdlib FRAMES i64)

(bind-lib-val stdlib SVF_LOWPASS i64)
(bind-lib-val stdlib SVF_HIGHPASS i64)
(bind-lib-val stdlib SVF_BANDPASS i64)
(bind-lib-val stdlib SVF_NOTCH i64)
(bind-lib-val stdlib SVF_PEAK i64)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; because the vals above rely on current state
;; we need to change their values to reflect
;; our *current* state (i.e. not the state when the
;; dylib was compiled)
;;
;; CHANGE AUDIO VARIABLES TO REFLECT CURRENT STATE 
(bind-func setup_audio_vals
  (lambda (a:double b:i64 c:i64 d:i64)
    (set! SVF_LOWPASS 1)
    (set! SVF_HIGHPASS 2)
    (set! SVF_BANDPASS 3)
    (set! SVF_NOTCH 4)
    (set! SVF_PEAK 5)    
    (set! SAMPLERATE a)
    (set! SR a)
    (set! CHANNELS b)
    (set! IN_CHANNELS c)
    (set! FRAMES d)))

(setup_audio_vals (integer->real *au:samplerate*)
                  *au:channels*
                  *au:in-channels*
                  *au:block-size*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; first print the CURRENT audio state
(bind-lib-func stdlib print_audio_state [i32]*)
(bind-wrapper print-audio-state print_audio_state)
;; (print-audio-state)

;; ;; (dirty) check to see if audio_dsp.xtm has already been loaded
;; (if (not (llvm:get-globalvar "SAMPLERATE"))
;;     (sys:load "libs/core/audio_dsp.xtm"))

;; load the libsndfile dynamic library
(define libsndfile
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libsndfile.so"))
          ((string=? platform "Windows") (sys:load-dylib "libsndfile.dll"))
          ((string=? platform "OSX") (sys:load-dylib "libsndfile.dylib"))
          (else (print "Unknown platform: " platform)))))

(if (or (eq? #f libsndfile)
        (null? libsndfile))
    (sys:load-escape "Error loading libsndfile dynamic library"))

(define *xtmlib-sndfile-loaded* #f)

(bind-type sf_info <i64,i32,i32,i32,i32,i32>)
(bind-type sf_format_info <i32,i8*,i8*>)

(bind-lib libsndfile sf_open [i8*,i8*,i32,sf_info*]*)
(bind-lib libsndfile sf_open_fd [i8*,i32,i32,sf_info*,i32]*)
(bind-lib libsndfile sf_close [i32,i8*]*)
(bind-lib libsndfile sf_seek [i64,i8*,i64,i32]*)
(bind-lib libsndfile sf_write_sync [void,i8*]*)
(bind-lib libsndfile sf_read_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_write_double [i64,i8*,double*,i64]*)
(bind-lib libsndfile sf_strerror [i8*,i8*]*)

(define *xtmlib-sndfile-loaded* #t)

;; then bind the rest of the closures
;; NOTE: cant use standard bind-lib because these are closures
(bind-lib-func stdlib dsp [double,double,double,double,double*]*)
(bind-lib-func stdlib dsp_randn [double]*)
(bind-lib-func stdlib gain [double,double,double,double]*)
(bind-lib-func stdlib hann [double,double,double,double]*)
(bind-lib-func stdlib impulse [double,double,double]*)
(bind-lib-func stdlib panner [double,double,double]*)
(bind-lib-func stdlib range_limit [double,double,double,double]*)
(bind-lib-func stdlib _sin [double,double]*)
(bind-lib-func stdlib osc_c [[double,double,double]*,double]*)
(bind-lib-func stdlib osc_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib square_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib square_mc_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib integrator_c [double,double]*)
(bind-lib-func stdlib triangle_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib triangle_mc_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib rect_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib saw_c [[double,double,double]*,double]*)
(bind-lib-func stdlib saw_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib white_c [[double]*]*)
(bind-lib-func stdlib pink_c [[double]*]*)
(bind-lib-func stdlib pulse_c [[double,double,double,double]*]*)
(bind-lib-func stdlib pulse_mc_c [[double,double,double,double,double]*]*)
(bind-lib-func stdlib fade_c [[double,double,double,double]*]*)
(bind-lib-func stdlib fade_mc_c [[double,double,double,double,double]*]*)
(bind-lib-func stdlib delay_old_c [[double,double]*,i64]*)
(bind-lib-func stdlib delay_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib delay_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib delay_st_c [[double,double,double,double,double]*,double,double]*)
(bind-lib-func stdlib delay_t_c [[double,double,double,double,double]*,double,double]*)
(bind-lib-func stdlib delay_t_mc_c [[double,double,double,double,double,double]*,i64,double,double]*)
(bind-lib-func stdlib delay_t_st_c [[double,double,double,double,double,double]*,double,double,double]*)
(bind-lib-func stdlib comb_old_c [[double,double,double]*,i64]*)
(bind-lib-func stdlib comb_c [[double,double,double,double,double]*,double]*)
(bind-lib-func stdlib comb_mc_c [[double,double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib flanger_c [[double,double,double,double]*,double,double,double,double]*)
(bind-lib-func stdlib flanger_mc_c [[double,double,double,double,double]*,i64,double,double,double,double]*)
(bind-lib-func stdlib chorus_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib chorus_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib tap_delay_c [[double,double]*,i64,i64]*)
(bind-lib-func stdlib allpass_old_c [[double,double]*,i64]*)
(bind-lib-func stdlib allpass_c [[double,double,double]*,double]*)
(bind-lib-func stdlib allpass_mc_c [[double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib reverb_old_c [[double,double,double]*,double]*)
(bind-lib-func stdlib reverb_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib reverb_mc_c [[double,double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib reverb2_c [[double,double,double]*,double]*)
(bind-lib-func stdlib reverb2_mc_c [[double,double,double,double]*,i64,double]*)
(bind-lib-func stdlib crusher_c [[double,double,double]*]*)
(bind-lib-func stdlib hold3_c [[double,double,double]*]*)
(bind-lib-func stdlib hold_mc_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib crush [double,double,double]*)
(bind-lib-func stdlib distort_c [[double,double]*,double]*)
(bind-lib-func stdlib pan2 [double,double,double,double]*)
(bind-lib-func stdlib pan_mc [[double,double,double,double]*,double]*)
(bind-lib-func stdlib mix2 [double,double,double,double,double]*)
(bind-lib-func stdlib mix4 [double,double,double,double,double,double,double]*)
(bind-lib-func stdlib mixer_c [[double,double*,double,double]*,i64]*)
(bind-lib-func stdlib lpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib lpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib hpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib hpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib bpf_c [[double,double,double,double]*]*)
(bind-lib-func stdlib bpf_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib notch_c [[double,double,double,double]*]*)
(bind-lib-func stdlib notch_mc_c [[double,double,double,double,double]*,i64]*)
(bind-lib-func stdlib hilbert_c [[double,double]*,i64]*)
(bind-lib-func stdlib env_follow_c [[double,double]*,i64]*)
(bind-lib-func stdlib vcf_old_c [[double,double,double,double]*]*)
(bind-lib-func stdlib vcf1_c [[double,double,double,double]*]*)
(bind-lib-func stdlib vcf_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib vcf3_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib vcf_mc_c [[double,double,double,double,double]*,i64,i64]*)
(bind-lib-func stdlib min2d [double,double,double]*)
(bind-lib-func stdlib svf_c [[double,double,double,double]*,i64]*)
(bind-lib-func stdlib overdrive_c [[double,double]*,double]*)
(bind-lib-func stdlib saturation_c [[double,double,double,double]*]*)
(bind-lib-func stdlib ringmod_c [[double,double,double,double]*]*)
(bind-lib-func stdlib hann_c [[double,double]*]*)
(bind-lib-func stdlib hann_mc_c [[double,double,double]*]*)
(bind-lib-func stdlib hann_t_c [[double,double,double]*,double]*)
(bind-lib-func stdlib hann_t_mc_c [[double,double,double,double]*,double]*)
(bind-lib-func stdlib hann_e_c [[double,double,double,double]*]*)
(bind-lib-func stdlib linear_c [[double,double]*,double,double,double]*)
(bind-lib-func stdlib linear_mc_c [[double,double,double]*,double,double,double]*)
(bind-lib-func stdlib line_c [[double,double]*,double,double,double,double]*)
(bind-lib-func stdlib envelope_segments [[double,double]**,double*,i64]*)
(bind-lib-func stdlib envelope_c [[double,double]*,double*,i64]*)
(bind-lib-func stdlib adsr_c [[double,double]*,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib adsr_accum_c [[double,double,double]*,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib hermite_interp [double,double,double,double,double,double]*)
(bind-lib-func stdlib midi2frq [double,double]*)
(bind-lib-func stdlib frq2midi [double,double]*)
(bind-lib-func stdlib note_c [[double,double,double,double]*,double,double,double,double,double,double,double,double,double*,i64,[double,double,double,double,double]*,mzone*]*)
(bind-lib-func stdlib _play_note [i64,double,[double,double,double,double,double*]*,double,double,double,i64,double*]*)
(bind-lib-func stdlib default_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib default_fx [double,double,double,double,double*]*)
(bind-lib-func stdlib definst [double,double,double,double,double*]*)
(bind-lib-func stdlib synth_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib synth_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib synth [double,double,double,double,double*]*)
(bind-lib-func stdlib epad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib epad_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib epad [double,double,double,double,double*]*)
(bind-lib-func stdlib organ_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib organ_fx [double,double,double,double,double*]* 800000)
(bind-lib-func stdlib fuzz_bass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib fuzz_bass_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fuzz_bass [double,double,double,double,double*]*)
(bind-lib-func stdlib shimmer_pad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib shimmer_pad_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib shimmer_pad [double,double,double,double,double*]*)
(bind-lib-func stdlib fmsynth_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib fmsynth_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fmsynth [double,double,double,double,double*]*)
(bind-lib-func stdlib fmpad_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib fmpad_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib fmpad [double,double,double,double,double*]*)
(bind-lib-func stdlib sawbass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib sawbass_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sawbass [double,double,double,double,double*]*)
(bind-lib-func stdlib subbass_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib subbass_fx [double,double,double,double,double*]* 100000)
(bind-lib-func stdlib subbass [double,double,double,double,double*]*)
(bind-lib-func stdlib sawlead_note_c [[double,double,double,double,double]*,i64,double*]*)
(bind-lib-func stdlib sawlead_fx [double,double,double,double,double*]* 1000000)
(bind-lib-func stdlib sawlead [double,double,double,double,double*]*)
(bind-lib-func stdlib sf_frames [i64,sf_info*]*)
(bind-lib-func stdlib sf_samplerate [i64,sf_info*]*)
(bind-lib-func stdlib sf_channels [i64,sf_info*]*)
(bind-lib-func stdlib sf_format [i64,sf_info*]*)
(bind-lib-func stdlib sf_sections [i64,sf_info*]*)
(bind-lib-func stdlib sf_seekable [i64,sf_info*]*)
(bind-lib-func stdlib print_audio_file_info [i32,i8*]*)
(bind-lib-func stdlib read_audio_data [i64,i8*,double*,i64,i64,i32]*)
(bind-lib-func stdlib audiofile_c [[double]*,i8*,i64,i64]*)
(bind-lib-func stdlib audiofile_ptr_c [[double*]*,i8*,i64,i64]*)
(bind-lib-func stdlib write_audio_data [i64,i8*,i64,i32,double*]*)
;; external/instruments
(bind-lib-func stdlib set_sample_data_ [i64,[double,double,double,double*]*,i8*,i64,i64,i64,i32,i32]*)
(bind-lib-func stdlib clear_sample_data_ [i64,[double,double,double,double*]*,i64,i32]*)
(bind-lib-func stdlib set_sample_offset_ [i64,[double,double,double,double*]*,i64,i64]*)
(bind-lib-func stdlib sampler_note_linear_c [[double,double,double,double,double]*,|128,double*|*,|128,i64|*,|128,i64|*,i64,double,i64]*)
(bind-lib-func stdlib sampler_note_hermite_c [[double,double,double,double,double]*,|128,double*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,double,double]*)
(bind-lib-func stdlib sampler_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler1_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler2_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler3_fx [double,double,double,double,double*]* 700000)
(bind-lib-func stdlib sampler [double,double,double,double,double*]* 100000) 
(bind-lib-func stdlib sampler1 [double,double,double,double,double*]* 100000)
(bind-lib-func stdlib sampler2 [double,double,double,double,double*]* 100000)
(bind-lib-func stdlib sampler3 [double,double,double,double,double*]* 100000)

(define play-note
  (lambda (time inst pitch vol dur . args)
    (let* ((nargs (length args))
          (duration (* 1.0 dur))
          (dargs (sys:make-cptr (* 8 nargs)))
          (native (if (procedure? inst)
                      (llvm:get-native-closure (llvm:ffi-get-name inst))
                      (llvm:get-native-closure (if (symbol? inst)
                                                   (symbol->string inst)
                                                   inst)))))
      (dotimes (i nargs) (cptr:set-double dargs (* i 8) (eval (list-ref args i))))
      (if (cptr? native)
          (_play_note (integer->real time)
                      native
                      (midi2frq (* 1.0 pitch))
                      (/ (exp (/ vol 26.222)) 127.0)
                      duration
                      nargs
                      dargs)
          (print-error 'No 'inst 'named (symbol->string inst))))))

;; the play macro
(macro (play args)
  (if (symbol? (cadr args))
      `(play-note (*metro* beat) ,(cadr args) ,(caddr args) ,(cadddr args) (*metro* 'dur ,(car (cddddr args)))
                  ,@(cdr (cddddr args)))
      `(play-note (*metro* (+ beat ,(cadr args))) ,(caddr args) ,(cadddr args) ,(car (cddddr args))
                  (*metro* 'dur ,(car (cdr (cddddr args))))
                  ,@(cddr (cddddr args)))))

;; a macro for making extemore instruments
;; see http://benswift.me/2012-09-28-making-an-instrument.html
(define-macro (define-instrument name note_kernel effect_kernel)
  `(bind-func ,name
     (let* ((poly:i64 48)
	    (notes:[double,double,double,double]** (zalloc poly))
	    (attack:double 200.0)
	    (decay:double 200.0)
	    (release:double 1000.0)
	    (sustain:double 0.6) ;; amplitude of the sustain
	    (gain 2.0)
	    (ii 0)
	    (note_starts:double* (zalloc poly))
	    (new_note (lambda (start freq dur amp nargs:i64 dargs)
			(let ((free_note:i64 -1)
			      (iii 0)
			      (i 0))
			  (dotimes (i poly) ;; check for free poly spot           
			    (if (> (pref note_starts i) 9999999999998.0)
				(set! free_note i)))
			  (if (> free_note -1) ;; if we found a free poly spot assign a note
			      (let ((note_zone (push_zone (* 1024 10))))
				(pset! notes free_note
				       (note_c start freq amp dur
                                               attack decay release sustain
                                               note_starts free_note
                                               (,note_kernel nargs dargs)
                                               note_zone))
				(pset! note_starts free_note start)
				(pop_zone)
				1)
			      0)))))
       (dotimes (ii poly) ;; sets all notes to inactive
	 (pset! note_starts ii 9999999999999.0))
       (lambda (in:double time:double chan:double dat:double*)
	 (let ((out:double 0.0)
	       (k 0))
	   (dotimes (k poly) ;; sum all active notes          
	     (if (< (pref note_starts k) time)
		 (set! out (+ out (* 0.3 ((pref notes k) in time chan))))))
	   (* gain (,effect_kernel out time chan dat)))))))


;; make sampler instrument
(define-macro (define-sampler name note_kernel effect_kernel)
  `(bind-func ,name 100000
     (let ((poly:i64 48)
           (samples:|20,|128,double*||* (zalloc)) ;; 128 samples * 20 'banks'
           (samples_length:|20,|128,i64||* (zalloc)) ;; 128 samples * 10
           (samples_channels:|20,|128,i64||* (zalloc)) ;; 128 samples * 10
           (samples_offsets:|20,|128,i64||* (zalloc)) ;; 128 samples * 10
           (notes:[double,double,double,double]** (zalloc poly))
           (attack:double 200.0)
           (decay:double 200.0)
           (release:double 1000.0)
           (sustain:double 1.0) ;; amplitude of the sustain
           (gain:double 2.0)
           (kk:i64 0) (ii:i64 0)
           ;;(active:i64 0)
           (note_starts:double* (zalloc poly))
           (new_note (lambda (start freq dur amp nargs:i64 dargs:double*)
                       (let ((free_note:i64 -1)
                             (bank:i32 (if (< nargs 1) (i64toi32 0) (dtoi32 (pref dargs 0))))
                             (idx (dtoi64 (floor (frq2midi freq))))
                             (closest 1000000)
                             (i:i64 0) (iii:i64 0) (idxi:i64 0)
                             (new_idx idx))
                         (dotimes (i poly) ;; check for free poly spot
                           (if (> (pref note_starts i) 9999999999998.0)
                               (set! free_note i)))
                         (if (> free_note -1) ;; if we found a free poly spot assign a note
                             (begin (dotimes (idxi 128)
                                      (let ((v (llabs (- idx idxi))))
                                        (if (and (<> (aref (aref-ptr samples_length bank) idxi) 0)
                                                 (< v closest))
                                            (begin (set! new_idx idxi)
                                                   (set! closest v) 0))))
                                    (let ((note_zone (push_zone (* 1024 10))))
                                      (pset! notes free_note
                                             (note_c start freq amp dur
                                                     attack decay release sustain
                                                     note_starts free_note
                                                     (if (< nargs 2)
                                                         (,note_kernel (aref-ptr samples bank) (aref-ptr samples_length bank) (aref-ptr samples_offsets bank)
                                                                       (aref-ptr samples_channels bank) new_idx 0.5 0.0)
                                                         (if (= nargs 2)
                                                             (,note_kernel (aref-ptr samples bank) (aref-ptr samples_length bank) (aref-ptr samples_offsets bank)
                                                                           (aref-ptr samples_channels bank) new_idx (pref dargs 1) 0.0)
                                                             (,note_kernel (aref-ptr samples bank) (aref-ptr samples_length bank) (aref-ptr samples_offsets bank)
                                                                           (aref-ptr samples_channels bank) new_idx (pref dargs 1) (pref dargs 2))))
                                                     note_zone))
                                      (pset! note_starts free_note start)
                                      (pop_zone))
                                    1)
                             0)))))
       (dotimes (kk 128)
         (dotimes (ii 10) ;banks
           (aset! (aref-ptr samples_offsets ii) kk 0)
           (aset! (aref-ptr samples_length ii) kk 0)))
       (dotimes (ii poly) ;; sets all notes to inactive
         (pset! note_starts ii 9999999999999.0))
       (lambda (in:double time:double chan:double dat:double*)
         (let ((out:double 0.0)
               (k:i64 0))
           (dotimes (k poly) ;; sum all active notesx
             (if (< (pref note_starts k) time)
                 (set! out (+ out (* 0.3 ((pref notes k) in time chan))))))
           (* gain (,effect_kernel out time chan dat)))))))



;; passing a length of 0 will read the whole file
(define-macro (set-sampler-index inst fname index offset lgth bank print?)
  `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
     (if (and (cptr? native)
              (> ,index 0)
              (< ,index 128))
         (set_sample_data_ native
                           ,fname
                           (real->integer ,index)
                           (real->integer ,offset)
                           (real->integer ,lgth)
                           (real->integer ,bank)
                           ,(if (> print? 0) 1 0)))))


(define note-name-to-midi-number
  (lambda (name)
    (let ((result (regex:matched name "([abcdefgABCDEFG])([#b])?(-?[0-9])")))
        (if (null? result)
            #f
            (let ((offset (+ 12 (* (string->number (cadddr result)) 12)))
                  (pc (case (modulo (- (modulo (char->integer (car (string->list (cadr result)))) 16) 3) 7)
                        ((0) 0) ((1) 2) ((2) 4) ((3) 5) ((4) 7) ((5) 9) ((6) 11))))
              (+ offset pc
                 (cond ((string=? (caddr result) "#") 1)
                       ((string=? (caddr result) "b") -1)
                       (else 0))))))))

;; this will match e.g. 60.aiff (where 60 is the midi note number)
(define parse-sample-names-1
  (lambda (file-list)
    (map (lambda (fname)
           (let ((result (regex:matched fname "([0-9]*)\.(wav|WAV|aif|AIF|aiff|AIFF|ogg|OGG)$")))
             (if (null? result)
                 (begin (if (not (regex:match? fname "^\\."))
                            (println 'Error: 'cannot 'parse 'filename: fname))
                        #f)
                 (list fname                          ; filename    
                       (string->number (cadr result)) ; midi note number
                       0                              ; offset
                       0))))                          ; length (0 for whole sample)
         file-list)))

;; this will match e.g. Eb3.aiff (representing E flat 3)
(define parse-sample-names-2
  (lambda (file-list)
    (map (lambda (fname)
           (let ((result (regex:matched fname "^.*([abcdefgABCDEFG][#b]?[0-9]).*\.(wav|WAV|aif|AIF|aiff|AIFF|ogg|OGG)$")))
             (if (null? result)
                 (begin
                   (if (not (regex:match? fname "^\\."))
                       (begin
                         (println 'Error: 'cannot 'parse 'filename: fname)
                         (println 'Regex-result: result)))
                   #f)
                 (list fname                                    ; filename                   
                       (note-name-to-midi-number (cadr result)) ; midi note number           
                       0                                        ; offset                     
                       0))))                                    ; length (0 for whole sample)
         file-list)))

;; must be stereo samples of type wav aif or ogg
(define-macro (load-sampler sampler path . args)
  (let ((bank (if (> (length args) 0) (car args) 0))
        (parser (if (> (length args) 1) (cadr args) 'parse-sample-names-1))
        (midioffset (if (> (length args) 2) (caddr args) 0)))
    `(let ((cnt 0)
           (file-list (sys:directory-list ,(sys:expand-path path))))
       (for-each (lambda (samp-data)
                   (if samp-data
                       (begin
                         (set! cnt (+ cnt 1))                         
                         (set-sampler-index ,sampler
                                            (if (string=? (sys:platform) "Windows")
                                                (car samp-data)
                                                (string-append ,(sys:expand-path path) "/" (car samp-data)))
                                            (+ ,midioffset (cadr samp-data))
                                            (caddr samp-data)
                                            (cadddr samp-data)
                                            ,bank
                                            0))))
                 (,parser file-list))
       (ascii-print-color 0 6 10)              
       (print 'Loaded cnt 'files 'into 'bank#: ,bank)
       (ascii-print-color 0 7 10)       
       (println)
       )))

(define-macro (clear-sampler sampler . args)
  (let ((bank (if (> (length args) 0) (car args) 0)))
    `(let ((native (llvm:get-native-closure ,(symbol->string sampler)))
           (cnt 0))
       (dotimes (i 128)
         (if (> (clear_sample_data_ native (real->integer i) (real->integer ,bank)) 0)
             (set! cnt (+ cnt 1))))
       (ascii-print-color 0 6 10)              
       (print 'Cleared cnt 'slots 'from 'bank#: ,bank)
       (ascii-print-color 0 7 10)
       (println)
       #t)))


(define ipc:audio-setup
  (lambda (proc)
    (ipc:load proc "libs/core/pc_ivl.xtm")
    (ipc:eval-string proc
                     ";; new playnote
                     (define play-note
                       (lambda (time inst pitch vol dur . args)
                         (let* ((nargs (length args))
                               (duration (* 1.0 dur))
                               (dargs (sys:make-cptr (* 8 nargs))) ;; doubles
                               (native (if (procedure? inst)
                                           (llvm:get-native-closure (llvm:ffi-get-name inst))
                                           (llvm:get-native-closure (if (symbol? inst)
                                                                        (symbol->string inst)
                                                                        inst)))))
                           (dotimes (i nargs) (cptr:set-double dargs (* i 8) (eval (list-ref args i))))
                           (if (cptr? native)
                               (_play_note (integer->real time)
                                           native
                                           (midi2frq (* 1.0 pitch))
                                           (/ (exp (/ vol 26.222)) 127.0)
                                           duration
                                           nargs
                                           dargs)
                               (print-error 'No 'inst 'named (symbol->string inst))))))
                     ;; load sampler                     
                     (define-macro (load-sampler sampler path . args)
                       (let ((bank (if (> (length args) 0) (car args) 0))
                             (parser (if (> (length args) 1) (cadr args) 'parse-sample-names-1))
                             (midioffset (if (> (length args) 2) (caddr args) 0)))
                         `(let ((cnt 0)
                                (file-list (sys:directory-list ,(sys:expand-path path))))
                            (for-each (lambda (samp-data)
                                        (if samp-data
                                            (begin
                                              (set! cnt (+ cnt 1))                         
                                              (set-sampler-index ,sampler
                                                                 (if (string=? (sys:platform) \"Windows\")
                                                                     (car samp-data)
                                                                     (string-append ,(sys:expand-path path) \"/\" (car samp-data)))
                                                                 (+ ,midioffset (cadr samp-data))
                                                                 (caddr samp-data)
                                                                 (cadddr samp-data)
                                                                 ,bank
                                                                 0))))
                                      (,parser file-list))
                            (ascii-print-color 0 6 10)              
                            (print 'Loaded cnt 'files 'into 'bank#: ,bank)
                            (ascii-print-color 0 7 10)       
                            (println)
                            )))
                     ;; clear sampler
                     (define-macro (clear-sampler sampler . args)
                       (let ((bank (if (> (length args) 0) (car args) 0)))
                         `(let ((native (llvm:get-native-closure ,(symbol->string sampler)))
                                (cnt 0))
                            (dotimes (i 128)
                              (if (> (clear_sample_data_ native (real->integer i) (real->integer ,bank)) 0)
                                  (set! cnt (+ cnt 1))))
                            (ascii-print-color 0 6 10)              
                            (print 'Cleared cnt 'slots 'from 'bank#: ,bank)
                            (ascii-print-color 0 7 10)
                            (println)
                            #t)))
                     ;; set sampler index
                     (define-macro (set-sampler-index inst fname index offset lgth bank print?)
                       `(let ((native (llvm:get-native-closure ,(symbol->string inst))))
                          (if (and (cptr? native)
                                   (> ,index 0)
                                   (< ,index 128))
                              (set_sample_data_ native
                                                ,fname
                                                (real->integer ,index)
                                                (real->integer ,offset)
                                                (real->integer ,lgth)
                                                (real->integer ,bank)
                                                ,(if (> print? 0) 1 0)))))
                     ;; this will match e.g. 60.aiff (where 60 is the midi note number)
                     (define parse-sample-names-1
                       (lambda (file-list)
                         (map (lambda (fname)
                                (let ((result (regex:matched fname \"([0-9]*)\.(wav|WAV|aif|AIF|aiff|AIFF|ogg|OGG)$\")))
                                  (if (null? result)
                                      (begin (if (not (regex:match? fname \"^\\.\"))
                                                 (println 'Error: 'cannot 'parse 'filename: fname))
                                             #f)
                                      (list fname                          ; filename    
                                            (string->number (cadr result)) ; midi note number
                                            0                              ; offset
                                            0))))                          ; length (0 for whole sample)
                              file-list)))
                     ;; this will match e.g. Eb3.aiff (representing E flat 3)
                     (define parse-sample-names-2
                       (lambda (file-list)
                         (map (lambda (fname)
                                (let ((result (regex:matched fname \"^.*([abcdefgABCDEFG][#b]?[0-9]).*\.(wav|WAV|aif|AIF|aiff|AIFF|ogg|OGG)$\")))
                                  (if (null? result)
                                      (begin
                                        (if (not (regex:match? fname \"^\\.\"))
                                            (begin
                                              (println 'Error: 'cannot 'parse 'filename: fname)
                                              (println 'Regex-result: result)))
                                        #f)
                                      (list fname                                    ; filename                   
                                            (note-name-to-midi-number (cadr result)) ; midi note number           
                                            0                                        ; offset                     
                                            0))))                                    ; length (0 for whole sample)
                              file-list)))
                     ;; note name to midi num
                     (define note-name-to-midi-number
                       (lambda (name)
                         (let ((result (regex:matched name \"([abcdefgABCDEFG])([#b])?(-?[0-9])\")))
                           (if (null? result)
                               #f
                               (let ((offset (+ 12 (* (string->number (cadddr result)) 12)))
                                     (pc (case (modulo (- (modulo (char->integer (car (string->list (cadr result)))) 16) 3) 7)
                                           ((0) 0) ((1) 2) ((2) 4) ((3) 5) ((4) 7) ((5) 9) ((6) 11))))
                                 (+ offset pc
                                    (cond ((string=? (caddr result) \"#\") 1)
                                          ((string=? (caddr result) \"b\") -1)
                                          (else 0))))))))
                     ;; the play macro
                     (macro (play args)
                            (if (symbol? (cadr args))
                                `(play-note (*metro* beat) ,(cadr args) ,(caddr args) ,(cadddr args) (*metro* 'dur ,(car (cddddr args)))
                                            ,@(cdr (cddddr args)))
                                `(play-note (*metro* (+ beat ,(cadr args))) ,(caddr args) ,(cadddr args) ,(car (cddddr args))
                                            (*metro* 'dur ,(car (cdr (cddddr args))))
                                            ,@(cddr (cddddr args)))))")
    (ipc:bind-func proc 'set_sample_data_)
    (ipc:bind-func proc 'clear_sample_data_)
    (ipc:bind-func proc '_play_note)
    (ipc:bind-func proc 'midi2frq)))


;;;;;;;
;; setup some instrument parameters

(sampler_fx.wet .025)
(sampler1_fx.wet .025)
(sampler2_fx.wet .025)
(sampler3_fx.wet .025)

(subbass.attack 500.0)
(subbass.decay 500.0)
(subbass.sustain 0.8)
(subbass.release 500.0)

(sawlead.attack 40.0)
(sawlead.decay 120.0)
(sawlead.release 400.0)
(sawlead.sustain 0.75)

(bind-func dsp:DSP
  (lambda (in time chan dat)
    (+ (fmsynth in time chan dat)
       (subbass in time chan dat)
       (sawlead in time chan dat)
       (sampler in time chan dat))))


(define xtm_audio_setup
  (lambda ()
    (ipc:audio-setup "utility")
    (ipc:bind-func "utility" 'fmsynth)
    (ipc:bind-func "utility" 'sawlead)
    (ipc:bind-func "utility" 'subbass)    
    (ipc:bind-func "utility" 'sampler)
    (ipc:bind-func "utility" 'fmsynth_fx)
    (ipc:bind-func "utility" 'sawlead_fx)
    (ipc:bind-func "utility" 'subbass_fx)    
    (ipc:bind-func "utility" 'sampler_fx)
    (dsp:set! dsp)
    (ascii-print-color 0 6 10)
    (print "Default Audio Initalized\n")
    (print "instruments: fmsynth, subbass, sawlead and sampler\n")
    (print "defined  in: 'primary' & 'utility'\n")
    (ascii-print-color 0 7 10)
    (println)))

;; load pc ivl library 
(load "libs/core/pc_ivl.xtm")

;; set *all* audio lib symbols
(define *xtmlib-audio-dsp-loaded* #t)
(define *xtmlib-audio-inst-loaded* #t)
(define *xtmlib-audio-inst-ext-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;; RTMIDI ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'rtmidi)

(define librtmidi
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "librtmidi.so"))
          ((string=? platform "Windows") (sys:load-dylib "librtmidi.dll"))
          ((string=? platform "OSX") (sys:load-dylib "librtmidi.dylib"))
          (else (print "Unknown platform: " platform)))))

(define *xtmlib-rtmidi-loaded* #f)
(print "Loading MIDI library...        ")

(bind-lib-val stdlib RTMIDI_NOERROR i32)
(bind-lib-val stdlib RTMIDI_ERROR i32)

(define *midi-note-off* 8)              ;; key, velocity
(define *midi-note-on* 9)               ;; key, velocity
(define *midi-aftertouch* 10)            ;; key, touch
(define *midi-continuous-controller* 11) ;; controller, value
(define *midi-patch-change* 12)           ;;
(define *midi-channel-pressure* 13)      ;;
(define *midi-pitch-bend* 14)            ;; lsb (7 bits), msb (7 bits)

(bind-lib-val stdlib MIDI_NOTE_OFF i8)
(bind-lib-val stdlib MIDI_NOTE_ON i8)
(bind-lib-val stdlib MIDI_AFTERTOUCH i8)
(bind-lib-val stdlib MIDI_CONTINUOUS_CONTROLLER i8)
(bind-lib-val stdlib MIDI_PATCH_CHANGE i8)
(bind-lib-val stdlib MIDI_CHANNEL_PRESSURE i8)
(bind-lib-val stdlib MIDI_PITCH_BEND i8)

(bind-lib-val stdlib UNSPECIFIED i32) ;; try to auto-detect the platform
(bind-lib-val stdlib MACOSX_CORE i32)
(bind-lib-val stdlib LINUX_ALSA  i32)
(bind-lib-val stdlib UNIX_JACK   i32)
(bind-lib-val stdlib WINDOWS_MM  i32)
(bind-lib-val stdlib WINDOWS_KS  i32)
(bind-lib-val stdlib RTMIDI_DUMMY i32)

(bind-type midi_in_device <i8*>)
(bind-type midi_out_device <i8*>)
(bind-alias midi_callback [i8*,double,i64,i8*]*)

(bind-lib librtmidi newMidiInDevice [i32,midi_in_device*,i32,i8*]*)
(bind-lib librtmidi deleteMidiInDevice [i32,midi_in_device*]*)
(bind-lib librtmidi getInCurrentApi [i64,midi_in_device*]*)
(bind-lib librtmidi getInPortCount [i64,midi_in_device*]*)
(bind-lib librtmidi getInPortName [i8*,midi_in_device*,i64]*)
(bind-lib librtmidi openInPort [i32,midi_in_device*,i64,i8*]*)
(bind-lib librtmidi openInVirtualPort [i32,midi_in_device*,i8*]*)
(bind-lib librtmidi closeInPort [i32,midi_in_device*]*)
(bind-lib librtmidi setCallback [i32,midi_in_device*,i8*]*)
(bind-lib librtmidi cancelCallback [i32,midi_in_device*]*)
(bind-lib librtmidi newMidiOutDevice [i32,midi_out_device*,i32,i8*]*)
(bind-lib librtmidi deleteMidiOutDevice [i32,midi_out_device*]*)
(bind-lib librtmidi getOutCurrentApi [i64,midi_out_device*]*)
(bind-lib librtmidi getOutPortCount [i64,midi_out_device*]*)
(bind-lib librtmidi getOutPortName [i8*,midi_out_device*,i64]*)
(bind-lib librtmidi openOutPort [i32,midi_out_device*,i64,i8*]*)
(bind-lib librtmidi openOutVirtualPort [i32,midi_out_device*,i8*]*)
(bind-lib librtmidi closeOutPort [i32,midi_out_device*]*)
(bind-lib librtmidi sendMessage [i32,midi_out_device*,i64,i8*]*)

(bind-lib-func stdlib midi_query_inports [void,midi_in_device*]*)
(bind-lib-func stdlib midi_query_outports [void,midi_out_device*]*)
(bind-lib-func stdlib midi_new_indevice [midi_in_device*]*)
(bind-lib-func stdlib midi_new_outdevice [midi_out_device*]*);

(bind-lib-func stdlib midi_open_inport [i32,midi_in_device*,i64]*)
(bind-lib-func stdlib midi_open_virtual_inport [i32,midi_in_device*]*)
(bind-lib-func stdlib midi_open_outport [i32,midi_out_device*,i64]*)
(bind-lib-func stdlib midi_open_virtual_outport [i32,midi_out_device*]*)

(bind-lib-func stdlib midi_delete_indevice [i32,midi_in_device*]*)
(bind-lib-func stdlib midi_delete_outdevice [i32,midi_out_device*]*)
(bind-lib-func stdlib midi_close_inport [i32,midi_in_device*]*)
(bind-lib-func stdlib midi_close_outport [i32,midi_out_device*]*)
(bind-lib-func stdlib midi_default_callback [void,double,i64,i8*]*)
(bind-lib-func stdlib midi_register_device [i32,midi_in_device*,i8*]*)
(bind-lib-func stdlib midi_unregister_device [i32,midi_in_device*]*)
(bind-lib-func stdlib midi_send [i32,midi_out_device*,i8,i8,i8,i8]*);

(bind-poly midi_query_ports midi_query_inports)
(bind-poly midi_query_ports midi_query_outports)

;; need to also define these on other procs (like utility!)

(define *midi-in-device* #f)
(define *midi-out-device* #f)

(define midi-register-events
  (lambda ()
    (set! *midi-in-device* (midi_new_indevice))
    (midi_register_device *midi-in-device* "midi_default_callback")
    (set! *midi-out-device* (midi_new_outdevice))))

(define midi-deregister-events
  (lambda ()
    (midi_delete_indevice *midi-in-device*)
    (set! *midi-in-device* #f)
    (midi_delete_outdevice *midi-out-device*)
    (set! *midi-out-device* #f)
    (print "Deregstered Extempore MIDI input/output devices.\n")))

(define play-midi-note
  (lambda (time device pitch velocity duration channel)
    (callback time 'midi_send device *midi-note-on* channel pitch velocity)
    (callback (+ time duration) 'midi_send device *midi-note-off* channel pitch velocity)))

(define-macro (mplay args)
  (if (symbol? (cadr args))
      `(play-midi-note (*metro* beat) ,(cadr args)
		       (real->integer ,(caddr args))
		       (real->integer ,(cadddr args))
		       (*metro* 'dur ,(car (cddddr args))) 0)
      `(play-midi-note (*metro* (+ beat ,(cadr args))) ,(caddr args)
		       (real->integer ,(cadddr args))
		       (real->integer ,(car (cddddr args)))
		       (*metro* 'dur ,(cadr (cddddr args))) 0)))

(define *xtmlib-rtmidi-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;;;;;  IMAGE SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; lib-loading config

(sys:load-preload-check 'soil)

(define libsoil
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libSOIL.so"))
	  ((string=? platform "Windows") (sys:load-dylib "libSOIL.dll"))
	  ((string=? platform "OSX") (sys:load-dylib "libSOIL.dylib"))
	  (else (print "Unknown platform: " platform)))))

(define *xtmlib-soil-loaded* #f)
(print "Loading SOIL library...        ")

(bind-lib libsoil SOIL_load_OGL_texture [i32,i8*,i32,i32,i32]*)
(bind-lib libsoil SOIL_load_OGL_texture_from_memory [i32,i8*,i32,i32,i32,i32]*)
(bind-lib libsoil SOIL_load_image [i8*,i8*,i32*,i32*,i32*,i32]*)

(bind-lib-val stdlib SOIL_FLAG_POWER_OF_TWO i32)
(bind-lib-val stdlib SOIL_FLAG_MIPMAPS i32)
(bind-lib-val stdlib SOIL_FLAG_TEXTURE_REPEATS i32)
(bind-lib-val stdlib SOIL_FLAG_MULTIPLY_ALPHA i32)
(bind-lib-val stdlib SOIL_FLAG_INVERT_Y i32)
(bind-lib-val stdlib SOIL_FLAG_COMPRESS_TO_DXT i32)
(bind-lib-val stdlib SOIL_FLAG_DDS_LOAD_DIRECT i32)
(bind-lib-val stdlib SOIL_FLAG_NTSC_SAFE_RGB i32)
(bind-lib-val stdlib SOIL_FLAG_CoCg_Y i32)
(bind-lib-val stdlib SOIL_FLAG_TEXTURE_RECTANGLE i32)

(bind-lib-val stdlib SOIL_LOAD_AUTO i32)
(bind-lib-val stdlib SOIL_LOAD_L i32)
(bind-lib-val stdlib SOIL_LOAD_LA i32)
(bind-lib-val stdlib SOIL_LOAD_RGB i32)
(bind-lib-val stdlib SOIL_LOAD_RGBA i32)

(bind-lib-val stdlib SOIL_SAVE_TYPE_TGA i32)
(bind-lib-val stdlib SOIL_SAVE_TYPE_BMP i32)
(bind-lib-val stdlib SOIL_SAVE_TYPE_DDS i32)

(bind-lib-val stdlib GL_RED i32)
(bind-lib-val stdlib GL_UNSIGNED_SHORT i32)
(bind-lib-val stdlib GL_2_BYTES i32)
(bind-lib-val stdlib GL_4_BYTES i32)
(bind-lib-val stdlib GL_BGRA i32)

(bind-lib-func stdlib gl_load_image_rect [i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_image [i32,i8*,i32]*)
(bind-lib-func stdlib gl_tex_height [i32,i32]*)
(bind-lib-func stdlib gl_tex_width [i32,i32]*)
(bind-lib-func stdlib gl_tex_width_rect [i32,i32]*)
(bind-lib-func stdlib gl_tex_height_rect [i32,i32]*)
(bind-lib-func stdlib gl_load_tex_rect [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex_ext [i32,i32,i32,i32,i32,i8*,i32,i32]*)
(bind-lib-func stdlib gl_load_tex_bgr [i32,i32,i32,i32,i32,i8*,i32]*)
(bind-lib-func stdlib gl_load_tex_ext_bgr [i32,i32,i32,i32,i32,i8*,i32,i32]*)
(bind-lib-func stdlib gl_draw_img [void,double,double,double,double,double,i32]*)
(bind-lib-func stdlib gl_draw_img_ext [void,double,double,double,double,double,i32,i32]*)
(bind-lib-func stdlib gl_draw_img_from_img [void,double,double,double,double,double,double,double,double,double,i32]*)
(bind-lib-func stdlib gl_draw_img_reverse [void,double,double,double,double,double,i32]*)

(define *xtmlib-soil-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;;;;;;;;; OPENGL SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'opengl)
(define *xtmlib-opengl-loaded* #f)
(print "Loading opengl library...      ")

(bind-type E_vbo <i32,i32,i8*>)
(bind-type E_fbo <i32,i32,i32,i32,i32>)

(define libgl
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libGL.so"))
          ((string=? platform "Windows") (sys:load-dylib "Gl32.dll"))
          ((string=? platform "OSX") (sys:load-dylib "/System/Library/Frameworks/OpenGL.framework/OpenGL"))
          (else (print "Unknown platform: " platform)))))

;; if on windows also check for opengl32.dll			  
(if (or (eq? #f libgl)
	    (null? libgl)) 
	(if (string=? "Windows" (sys:platform))
	    (begin (set! libgl (sys:load-dylib "opengl32.dll"))
		       (if (or (null? libgl)
				       (eq? #f libgl))
			       (sys:load-escape "Error loading opengl library")))	   
		(sys:load-escape "Error loading opengl library")))

(if (not (string=? (sys:platform) "Windows"))
    (begin (llvm:compile "declare i32 @glGetUniformBlockIndex(i32, i8*);")
	   (llvm:compile "declare void @glUniformBlockBinding(i32, i32, i32);")
	   (llvm:compile "declare void @glBindBufferRange(i32,i32,i32,i32,i32);")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; missing opengl constants

(bind-lib-val stdlib GL_VIEWPORT_BIT i32)
(bind-lib-val stdlib GL_ENABLE_BIT i32)
(bind-lib-val stdlib GL_VERTEX_PROGRAM_POINT_SIZE i32)
(bind-lib-val stdlib GL_COORD_REPLACE i32)

(bind-lib-val stdlib GL_ONE_MINUS_SRC_ALPHA i32)
(bind-lib-val stdlib GL_ONE_MINUS_SRC_COLOR i32)
(bind-lib-val stdlib GL_ONE_MINUS_DST_COLOR i32)

;;;;;;;;;;;;;;;;;;;;;;;  FBO stuff
(bind-lib-val stdlib GL_DRAW_FRAMEBUFFER i32)
(bind-lib-val stdlib GL_READ_FRAMEBUFFER i32)
(bind-lib-val stdlib GL_FRAMEBUFFER i32)
(bind-lib-val stdlib GL_RENDERBUFFER i32)
(bind-lib-val stdlib GL_RENDERBUFFER_WIDTH i32)
(bind-lib-val stdlib GL_RENDERBUFFER_HEIGHT i32)
(bind-lib-val stdlib GL_RENDERBUFFER_INTERNAL_FORMAT i32)
(bind-lib-val stdlib GL_FRAMEBUFFER_COMPLETE i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT0 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT1 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT2 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT3 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT4 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT5 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT6 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT7 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT8 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT9 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT10 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT11 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT12 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT13 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT14 i32)
(bind-lib-val stdlib GL_COLOR_ATTACHMENT15 i32)

(bind-lib-val stdlib GL_DEPTH_ATTACHMENT i32)
(bind-lib-val stdlib GL_DEPTH_COMPONENT24 i32)
(bind-lib-val stdlib GL_MODELVIEW_MATRIX i32)
(bind-lib-val stdlib GL_TEXTURE_MATRIX i32)
(bind-lib-val stdlib GL_RGBA16F i32)
(bind-lib-val stdlib GL_RGBA8 i32)

(bind-lib-val stdlib GL_RENDERER i32)

(if (not (string=? "Windows" (sys:platform)))
    (begin 
      (bind-lib libgl glGenFramebuffers [void,i32,i32*]*)
      (bind-lib libgl glGenRenderbuffers [void,i32,i32*]*)
      (bind-lib libgl glBindFramebuffer [void,i32,i32]*)
      (bind-lib libgl glBindRenderbuffer [void,i32,i32]*)
      (bind-lib libgl glRenderbufferStorage [void,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferRenderbuffer [void,i32,i32,i32,i32]*)
      (if (sys:symbol-cptr libgl "glFramebufferTexture")
          (bind-lib libgl glFramebufferTexture [void,i32,i32,i32,i32]*))
      (bind-lib libgl glFramebufferTexture1D [void,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture2D [void,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glFramebufferTexture3D [void,i32,i32,i32,i32,i32,i32]*)
      (bind-lib libgl glCheckFramebufferStatus [i32,i32]*)))


(bind-lib-func stdlib gl_setup [void]*)
(bind-lib-func stdlib gl_print_driver_info [void]*)
(bind-lib-func stdlib gl_print_error [void]*)
(bind-lib-func stdlib fbo_create_texture_rect [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_depth_buffer_rect [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_texture [i32,i32,i32]*)
(bind-lib-func stdlib fbo_create_depth_buffer [i32,i32,i32]*)
(bind-lib-func stdlib create_vbo [E_vbo*,i32,i8*,i32]*)
(bind-lib-func stdlib create_fbo_rect [E_fbo*,i32,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo_no_depth_rect [E_fbo*,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo [E_fbo*,i32,i32,i32,i32]*)
(bind-lib-func stdlib create_fbo_no_depth [E_fbo*,i32,i32,i32]*)
(bind-lib-func stdlib print_shader_info_log [i64,i32]*)
(bind-lib-func stdlib print_program_info_log [i64,i32]*)
(bind-lib-func stdlib create_shader [i32,i8*,i8*]*)
(bind-lib-func stdlib create_shader_xtm [i32,i8*,i8*]*)
(bind-lib-func stdlib circle_line [void,double,double,double]*)
(bind-lib-func stdlib circle_whole [void,double,double,double]*)
(bind-lib-func stdlib cube_whole [i64]*)
(bind-lib-func stdlib mat4_to_mat3 [void,float*,float*]*)
(bind-lib-func stdlib translate_matrix [void,float*,float,float,float]*)
(bind-lib-func stdlib scale_matrix [void,float*,float,float,float]*)
(bind-lib-func stdlib rotate_matrix [void,float*,float,float,float,float]*)
(bind-lib-func stdlib fill_identity_matrix [void,float*]*)
(bind-lib-func stdlib fill_projection_matrix [void,float*,float,float,float,float]*)
(bind-lib-func stdlib fill_orthographic_matrix [void,float*,float,float,float,float,float,float]*)
(bind-lib-func stdlib fill_direction_vector [void,float*,float*,float*]*)
(bind-lib-func stdlib fill_view_matrix [void,float*,float*,float*,float*]*)
(bind-lib-func stdlib fill_view_matrix_dir [void,float*,float*,float*,float*]*)

(define *xtmlib-opengl-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;; SHADER SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'shaders)
(define *xtmlib-shaders-loaded* #f)
(print "Loading shaders library...     ")

(bind-alias XTMRENDERCB [void,i64,i32,float*,float*,float*,i8*]*)

(bind-type xtm_mesh <E_vbo*,i32,float*,float*,float*,float*,float,float,i32>)
(bind-type xtm_node <i8*,float*,xtm_node*,i32,xtm_node*,i32,xtm_mesh*>)
(bind-type xtm_camera <float*,float*,float*>)
(bind-type xtm_lights <float*,float*,float*,float*,float*,float*,float*,float*,float*,i32>)

(bind-val xtm_render_s1 i32 0)
(bind-val xtm_render_s2 i32 0)
(bind-val xtm_render_s3 i32 0)
(bind-val xtm_render_s4 i32 0)
(bind-val xtm_render_light_shaders |8,i32|)
(bind-val xtm_render_simple_shader i32 0)
(bind-val xtm_render_quad_shader i32 0)
(bind-val xtm_render_x i32 0)
(bind-val xtm_render_y i32 0)
(bind-val xtm_render_w i32 1024)
(bind-val xtm_render_h i32 768)
(bind-val xtm_render_angle float 35.0)
(bind-val xtm_render_near float 0.1)
(bind-val xtm_render_far float 100.0)

(bind-lib-func stdlib xtm_build_mesh_vbo [E_vbo*,float*,i32]*)
(bind-lib-func stdlib xtm_make_node_a [xtm_node*,i8*,float*,i32,float,float,float]*)

(bind-lib-func stdlib xtm_get_camera [xtm_camera*]*)
(bind-lib-func stdlib xtm_camera_pos [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_tgt [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_up [void,float,float,float]*)
(bind-lib-func stdlib xtm_camera_view [void,float*]*)
(bind-lib-func stdlib xtm_update_camera [void,i32]*)

(bind-lib-func stdlib xtm_get_lights [xtm_lights*]*)
(bind-lib-func stdlib xtm_light_pos [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_tgt [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_up [void,i32,float,float,float]*)
(bind-lib-func stdlib xtm_light_ambient [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_diffuse [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_specular [void,i32,float,float,float,float]*)
(bind-lib-func stdlib xtm_light_power [void,i32,float]*)
(bind-lib-func stdlib xtm_light_angle [void,i32,float]*)
(bind-lib-func stdlib xtm_light_view [void,i32,float*]*)
(bind-lib-func stdlib xtm_update_lights [void,i32]*)
(bind-lib-func stdlib xtm_update_matrices [void,i32,float*,float*,float*]*)
(bind-lib-func stdlib xtm_draw_mesh [void,xtm_mesh*,i32]*)
(bind-lib-func stdlib xtm_draw_node [void,xtm_node*,i32,float*,float*,float*]*)
(bind-lib-func stdlib xtm_draw_model [void,xtm_node*,i32,float*,float*,float*]*)

(bind-lib-func stdlib xtm_draw_tex [void,i32,i32,float*,float*,float*]*)

(bind-lib-func stdlib xtm_render_init_light_shaders [void,i8*,i8*,i8*,i8*,i8*,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_init_simple_shader [void,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_init_quad_shader [void,i8*,i8*]*)

(bind-lib-func stdlib xtm_render_fbo [E_fbo*]*)
(bind-lib-func stdlib xtm_render_setup_a [void,i32,i32,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_setup_b [void,i32,i32,float,float,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)
(bind-lib-func stdlib xtm_render_setup_c [void,i32,i32,i32,i32,float,float,float,i8*,i8*,i8*,i8*,i8*,i8*,i8*]*)

(bind-lib-func stdlib xtm_render [i64,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,[void,i64,i32,float*,float*,float*,i8*]*,i8*]*)

(bind-lib-func stdlib gl_draw_shader_quad [void,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib shader_set_grid_offsets [void,float*,float,float,float]*)
(bind-lib-func stdlib shader_setup_convolution_filter [void,float*,i32,float]*)
(bind-lib-func stdlib shader_update_camera [void,i32,float*,float*]*)
(bind-lib-func stdlib shader_update_light [void,i32,float*,float*,float,float,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_lights [void,i32,i32,float*,float*,float*,float*,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices [void,i32,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices_lv [void,i32,float*,float*,float*,float*]*)
(bind-lib-func stdlib shader_update_matrices_lvs [void,i32,float*,float*,float*,i32,float*]*);
(bind-lib-func stdlib shader_update_material [void,i32,float*,float*,float*,float]*)

(bind-poly xtm_make_node xtm_make_node_a)

(bind-poly xtm_render_setup xtm_render_setup_a)
(bind-poly xtm_render_setup xtm_render_setup_b)
(bind-poly xtm_render_setup xtm_render_setup_c)

(define xtm_render_setup
  (lambda (w h . args)
    (xtm_render_init_quad_shader quad-vert quad-frag)
    (xtm_render_init_simple_shader simple-vert-xtm simple-frag)
    (xtm_render_init_light_shaders xtmvert0 xtmfrag0 xtmvert1 xtmfrag1 xtmvert2 xtmfrag2 xtmvert3 xtmfrag3 xtmvert4 xtmfrag4 xtmvert5 xtmfrag5)    
    (if (null? args)
        (xtm_render_setup_a w h
                            simple-vert-xtm simple-frag
                            xtmvert-xtm xtmfrag xtmfrag_nolight
                            quad-vert quad-frag)
        (cond ((= (length args) 2)
               (xtm_render_setup_b w h (car args) (cadr args)
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              ((= (length args) 5)
               (xtm_render_setup_c w h (car args) (cadr args)
                                   (caddr args) (cadddr args)
                                   (car (cddddr args))
                                   simple-vert-xtm simple-frag
                                   xtmvert-xtm xtmfrag xtmfrag_nolight
                                   quad-vert quad-frag))
              (else (println 'Wrong 'number 'or 'args 'for 'xtm_render_setup))))))


;; load up glsl code

;; vert shader
(define passthrough-vert
"// VERTEX SHADER
// #version 330

varying vec2 TexCoord;
 
void main() {   
   // pass through texture coordinate
   //TexCoord =  gl_TextureMatrix[0].st * gl_MultiTexCoord0.st;   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; //this same as line below
   gl_Position = ftransform();
}")


;; frag shader
(define passthrough-frag
"//  FRAGMENT SHADER
// #version 330
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2DRect(tex1,TexCoord);
}")


;; frag shader
(define greyscale-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(vec3(grey),alpha);
}")


;; sepia
(define sepia-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(grey*vec3(1.2,1.0,0.8),alpha);
}")


(define invert-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

varying vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   vec4 colour = texture2DRect(tex1,TexCoord);
   gl_FragColor = vec4(1.0 - colour.rgb,alpha);
}")


(define gaussian-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   vec4 sample[25];
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor = ((1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
	           (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
	           (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +
	           (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +
	           (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +
	           (41.0 * sample[12])
	           ) / 273.0;
   //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}")


;;  Blur (median filter)
(define blur-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
   gl_FragColor = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      gl_FragColor += texture2DRect(tex1, TexCoord + texoffset[i]);
   }
 
   gl_FragColor /= 25.0;
}")


;;  sharpen
(define sharpen-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }
  
    gl_FragColor = 25.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
       if (i != 12)
          gl_FragColor -= sample[i];
    }
}")

(define dilate-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {  
   vec4 sample[25];
   vec4 maxValue = vec4(0.0);
 
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
      // Keep the maximum value		
      maxValue = max(sample[i], maxValue);
   }
 
   gl_FragColor = maxValue;
}")


(define erode-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
    vec4 minValue = vec4(1.0);
 
    for (int i = 0; i < 25; i++)
    {
        // Sample a grid around and including our texel
        sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
 
        // Keep the minimum value		
        minValue = min(sample[i], minValue);
    }
    gl_FragColor = minValue;
}")


(define edge-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

varying vec2 TexCoord;

void main() {
    vec4 sample[25];
 
    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 24.0 * sample[12];
 
    for (int i = 0; i < 25; i++)
    {
	if (i != 12)
	   gl_FragColor -= sample[i];
    }
}")


(define blend-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect baseBuf;
uniform sampler2DRect blendBuf;
uniform float       time;
uniform float       opacity;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(baseBuf, TexCoord);
    vec4 blend = texture2DRect(blendBuf, TexCoord);

    vec4 result = blend + base;
         result = clamp(result, 0.0, 1.0);

    gl_FragColor = mix(base, result, opacity);
}")


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible

//varying vec2 TexCoord;

attribute vec2 myVertex;
attribute vec4 myColour;
attribute float mySize;
attribute vec2 myVelocity;
attribute float myState;

void main() {
   gl_PointSize = mySize;
   if(myState > 0.0) {
     gl_FrontColor = myColour;
   }else{
     gl_FrontColor = vec4(0.0,0.0,0.0,0.0);
   }
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(myVertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
// #version 330

#version 120

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

//varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")


(define green-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex_back;
uniform sampler2DRect tex_front;
uniform vec4 color;
uniform float width;
uniform float height;
uniform float scale_front;
uniform int flipx;
uniform int flipy;

varying vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(tex_back, TexCoord);
    float x = (flipx==0) ? TexCoord.x : width-TexCoord.x;
    float y = (flipy==0) ? TexCoord.y : height-TexCoord.y;
    vec4 blend = texture2DRect(tex_front, vec2(x*scale_front,y*scale_front));

    if(color == blend) {
      gl_FragColor = base;
    }else{
      gl_FragColor = blend;
    }
}")


(define dof-frag
"
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect dBuf;
uniform sampler2DRect cBuf;
//uniform vec2 frameBufSize;
uniform float blur;
uniform float fp;  // focal point
uniform int show_depth;
uniform float dfact; // depth factor (shorten or make longer)
uniform float near;
uniform float far;

varying vec2 TexCoord;

// const float near = 0.1;
// const float far = 1000.0;
const vec2 frameBufSize = vec2(1.0,1.0);

vec4 blurKawase( const sampler2DRect tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
	// Function assumes that tex is using bilinear hardware filtering
	
	vec2 dUV = (iteration + 0.5) / texSize;
	
	vec4 col = texture2DRect( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
	col += texture2DRect( tex, texCoord + dUV );		        // Top right
	col += texture2DRect( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
	col += texture2DRect( tex, texCoord - dUV );		        // Bottom left
	
	return col * 0.25;
}

void main( void ) {
        // get z depth from dBuf tex 
	float depth = texture2DRect(dBuf,TexCoord).x;	

        // scale depth buffer
        depth *= far-near;
        depth = (far+near)-depth;
        depth = abs(depth - fp); // fp focal point

        // show_depth is true display depth buffer
        if (show_depth == 1) {
          gl_FragColor = vec4(depth,depth,depth,1.0);  
        } else { // else apply depth blur
          gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
        }
}
")


(define light-vert
  "
//#version 120
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  gl_Position = ModelViewProjectionMatrix * gl_Vertex;
  vec4 vPosition = ModelViewMatrix * gl_Vertex;
  //gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_Vertex;
  //vec4 vPosition = ViewMatrix * ModelMatrix * gl_Vertex;
  N = NormalMatrix * gl_Normal; //normal
  L = (LightPos - (ModelMatrix * gl_Vertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
}
")

(define light-frag
  "
#version 120
varying vec3 N, L, E, V;
varying float D;
uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  vec4 Color = vec4(0.0,0.0,0.0,0.0);

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  gl_FragColor = vec4((ambient + diffuse + specular).xyz,1.0);
}
")

(define simple-vert
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main() {   
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define simple-vert-xtm
  "
uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

void main() {   
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define simple-frag
  "

void main() {
   gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}
")

(define quad-vert
  "
#version 120

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

varying vec2 TexCoord;
 
void main() {   
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define quad-frag
  "
uniform sampler2D tex1;
varying vec2 TexCoord;

void main() {
   gl_FragColor = texture2D(tex1,TexCoord);
}
")

(define light-and-shade-vert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix;

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  L = (LightPos - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;
  lightVertexPosition = LightModelViewProjectionMatrix * xtmVertex;
}
")


(define light-and-shade-frag
  "
//#version 120
varying vec3 N, L, E, V;
varying float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured; 

varying vec4 lightVertexPosition;
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color
  
  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;

else
    spotAttenuation = pow(spotDot, SpotExponent);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition;
  lightVertexPosition2 /= lightVertexPosition2.w;

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,lightVertexPosition2.xy+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
     vec4 texcolor = LightDiffuse * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
     gl_FragColor = vec4((texcolor.xyz*shadowValue),1.0);
  } else {
     gl_FragColor = vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }
}
")


(define xtmvert-xtm
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  for(int i=0; j<numlights; i++, j+=1.0) {
    L[i] = (LightPos[i] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
    if(LightPos[i].w == 0.0) L[i] = LightPos[i].xyz; // i.e. if LightPos is already a direction vector
    D[i] = length(L[i]);
    lightVertexPosition[i] = LightModelViewProjectionMatrix[i] * xtmVertex;
  }
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  for(int i=0; j<numlights; i++, j+=1.0) 
  {  
    vec3 LL = normalize(L[i]); // light vector
    attenuation = 1.0 / (ConstantAttenuation[i] + (LinearAttenuation[i] * D[i]) + (QuadraticAttenuation[i] * D[i] * D[i]));
    spotDot = dot(-LL, normalize(SpotDir[i].xyz));

    if(spotDot < SpotAngle[i])
      spotAttenuation = 0.0;
    else
      spotAttenuation = pow(spotDot, SpotExponent[i]);  

    attenuation *= spotAttenuation;

    HV = normalize(LL+EE); // half vector
    nDotLL = max(0.0, dot(NN,LL));
    nDotHV = max(0.0, dot(NN,HV));

    if(nDotLL==0.0)
      pf = 0.0;
    else
      pf = pow(nDotHV, MaterialShininess);

    ambient = LightAmbient[i] * MaterialAmbient * attenuation;
    diffuse = LightDiffuse[i] * MaterialDiffuse * nDotLL * attenuation;
    specular = LightSpecular[i] * MaterialSpecular * pf * attenuation;

    //calc shadows
    float shadowValue = 0.0;
    vec4 lightVertexPosition2 = lightVertexPosition[i];
    lightVertexPosition2 /= lightVertexPosition2.w;

    float aa = mod((j-0.5),4.0);
    float bb = floor((j-0.5)/4.0);
    vec2 offset = vec2(0.25*aa,0.25*bb);

    // softer shadowing by adding dither
    for(float x=-0.0004; x<=0.0004; x+=0.0002) {
      for(float y=-0.0004; y<=0.0004; y+=0.0002) {
        if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
          shadowValue+=1.0;
      }
    }
    shadowValue/=16.0;

    if(IsTextured>0.5) {
      vec4 texcolor = LightDiffuse[i] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
      outcolor += vec4((texcolor.xyz*shadowValue),1.0);
    } else {
      outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
    }
  }
  float nl = numlights;
  if(numlights<0.5) {
    nl = 1.0;
    float dotE = max(0.0, dot(NN,EE));
    if(IsTextured>0.5) {
      outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
    }else{
      outcolor.xyz = MaterialDiffuse.xyz*dotE;
    }
  }
  gl_FragColor = vec4(outcolor.xyz/nl,1.0);
}
")

(define xtmfrag_nolight
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")


(define xtmvert0
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmvert1
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag0
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture2D(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  gl_FragColor = vec4(outcolor.xyz,1.0);
}
")


(define xtmfrag1
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    vec4 texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert2
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  
  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag2
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    vec4 texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert3
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  
  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag3
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert4
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  
  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag4
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define xtmvert5
  "
#version 120

attribute vec4 xtmVertex;
attribute vec3 xtmNormal;
attribute vec3 xtmUVW;
attribute vec4 xtmColor;

varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  
  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  L[4] = (LightPos[4] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[4].w == 0.0) L[4] = LightPos[4].xyz; // i.e. if LightPos is already a direction vector
  D[4] = length(L[4]);
  lightVertexPosition[4] = LightModelViewProjectionMatrix[4] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColor;  
}
")

(define xtmfrag5
  "
//#version 120
varying vec3 N, E, V;
varying vec3 L[10];
varying float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat4 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

varying vec4 lightVertexPosition[10];
varying vec3 UVWCoord;
varying vec4 Color;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 5
  j += 1.0;
  LL = normalize(L[4]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[4] + (LinearAttenuation[4] * D[4]) + (QuadraticAttenuation[4] * D[4] * D[4]));
  spotDot = dot(-LL, normalize(SpotDir[4].xyz));

  if(spotDot < SpotAngle[4])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[4]);  

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[4] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[4] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[4] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[4];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture2D(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[4] * texture2D(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  gl_FragColor = vec4(outcolor.xyz/numlights,1.0);
}
")

(define *xtmlib-shaders-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;; GLU (optional) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define libglu
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libGLU.so"))
          ((string=? platform "Windows") (sys:load-dylib "Glu32.dll"))
          ((string=? platform "OSX") (sys:load-dylib "/System/Library/Frameworks/OpenGL.framework/OpenGL"))
          (else (print "Unknown platform: " platform)))))

(if (not (and (eq? #f libglu)
              (not libglu)))
    (begin
      (print "Loading glu library...         ")
      (bind-lib-func stdlib gl_set_view [i64,double,double,double]*)
      (bind-lib-func stdlib gl_look_at [void,double,double,double,double,double,double,double,double,double]*)      
      (bind-lib libglu gluLookAt [void,double,double,double,double,double,double,double,double,double]*)
      (bind-lib libglu gluPerspective [void,double,double,double,double]*)
      (bind-lib libglu gluErrorString [i8*,i32]*)
      (ascii-print-color 0 2 10)
      (print "[YES]")
      (ascii-print-color 0 7 10)
      (println))
    (begin
      (print "Loading glu library...         ")      
      (ascii-print-color 0 1 10)
      (print "[NO]")
      (ascii-print-color 0 7 10)
      (println)))


;;; ASSIMP SETUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'assimp)

(define libassimp
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libassimp.so.3"))
          ((string=? platform "Windows") (sys:load-dylib "libassimp.dll"))
          ((string=? platform "OSX") (sys:load-dylib "libassimp.dylib"))
          (else (print "Unknown platform: " platform)))))

;; if on windows also check for opengl32.dll			  
(if (or (eq? #f libassimp)
        (null? libassimp))
    (sys:load-escape "Error loading assimp library"))

(define *xtmlib-assimp-loaded* #f)
(print "Loading assimp library...      ")

(bind-val aiProcess_CalcTangentSpace i32 1)
(bind-val aiProcess_JoinIdenticalVertices i32 2)
(bind-val aiProcess_MakeLeftHanded i32 4)
(bind-val aiProcess_Triangulate i32 8)
(bind-val aiProcess_RemoveComponent i32 16)
(bind-val aiProcess_GenNormals i32 32)
(bind-val aiProcess_GenSmoothNormals i32 64)
(bind-val aiProcess_SplitLargeMeshes i32 128)
(bind-val aiProcess_PreTransformVertices i32 256)
(bind-val aiProcess_LimitBoneWeights i32 512)
(bind-val aiProcess_ValidateDataStructure i32 1024)
(bind-val aiProcess_ImproveCacheLocality i32 2048)
(bind-val aiProcess_RemoveRedundantMaterials i32 4096)
(bind-val aiProcess_FixInfacingNormals i32 8192)
(bind-val aiProcess_SortByPType i32 32768)
(bind-val aiProcess_FindDegenerates i32 65536)
(bind-val aiProcess_FindInvalidData i32 131072)
(bind-val aiProcess_GenUVCoords i32 262144)
(bind-val aiProcess_TransformUVCoords i32 524288)
(bind-val aiProcess_FindInstances i32 1048576)
(bind-val aiProcess_OptimizeMeshes i32 2097152)
(bind-val aiProcess_OptimizeGraph i32 4194304)
(bind-val aiProcess_FlipUVs i32 8388608)
(bind-val aiProcess_FlipWindingOrder i32 16777216)
(bind-val aiProcess_SplitByBoneCount i32 33554432)
(bind-val aiProcess_Debone i32 67108864)

(define  aiProcess_CalcTangentSpace  1)
(define  aiProcess_JoinIdenticalVertices  2)
(define  aiProcess_MakeLeftHanded  4)
(define  aiProcess_Triangulate  8)
(define  aiProcess_RemoveComponent  16)
(define  aiProcess_GenNormals  32)
(define  aiProcess_GenSmoothNormals  64)
(define  aiProcess_SplitLargeMeshes  128)
(define  aiProcess_PreTransformVertices  256)
(define  aiProcess_LimitBoneWeights  512)
(define  aiProcess_ValidateDataStructure  1024)
(define  aiProcess_ImproveCacheLocality  2048)
(define  aiProcess_RemoveRedundantMaterials  4096)
(define  aiProcess_FixInfacingNormals  8192)
(define  aiProcess_SortByPType  32768)
(define  aiProcess_FindDegenerates  65536)
(define  aiProcess_FindInvalidData  131072)
(define  aiProcess_GenUVCoords  262144)
(define  aiProcess_TransformUVCoords  524288)
(define  aiProcess_FindInstances  1048576)
(define  aiProcess_OptimizeMeshes  2097152)
(define  aiProcess_OptimizeGraph  4194304)
(define  aiProcess_FlipUVs  8388608)
(define  aiProcess_FlipWindingOrder  16777216)
(define  aiProcess_SplitByBoneCount  33554432)
(define  aiProcess_Debone 67108864)
(ipc:define "utility"  'aiProcess_CalcTangentSpace  1)
(ipc:define "utility"  'aiProcess_JoinIdenticalVertices  2)
(ipc:define "utility"  'aiProcess_MakeLeftHanded  4)
(ipc:define "utility"  'aiProcess_Triangulate  8)
(ipc:define "utility"  'aiProcess_RemoveComponent  16)
(ipc:define "utility"  'aiProcess_GenNormals  32)
(ipc:define "utility"  'aiProcess_GenSmoothNormals  64)
(ipc:define "utility"  'aiProcess_SplitLargeMeshes  128)
(ipc:define "utility"  'aiProcess_PreTransformVertices  256)
(ipc:define "utility"  'aiProcess_LimitBoneWeights  512)
(ipc:define "utility"  'aiProcess_ValidateDataStructure  1024)
(ipc:define "utility"  'aiProcess_ImproveCacheLocality  2048)
(ipc:define "utility"  'aiProcess_RemoveRedundantMaterials  4096)
(ipc:define "utility"  'aiProcess_FixInfacingNormals  8192)
(ipc:define "utility"  'aiProcess_SortByPType  32768)
(ipc:define "utility"  'aiProcess_FindDegenerates  65536)
(ipc:define "utility"  'aiProcess_FindInvalidData  131072)
(ipc:define "utility"  'aiProcess_GenUVCoords  262144)
(ipc:define "utility"  'aiProcess_TransformUVCoords  524288)
(ipc:define "utility"  'aiProcess_FindInstances  1048576)
(ipc:define "utility"  'aiProcess_OptimizeMeshes  2097152)
(ipc:define "utility"  'aiProcess_OptimizeGraph  4194304)
(ipc:define "utility"  'aiProcess_FlipUVs  8388608)
(ipc:define "utility"  'aiProcess_FlipWindingOrder  16777216)
(ipc:define "utility"  'aiProcess_SplitByBoneCount  33554432)
(ipc:define "utility"  'aiProcess_Debone 67108864)

(bind-type aiString <size_t,|1024,i8|>)
(bind-type aiMatrix4x4 <float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float>)
(bind-type aiMatrix3x3 <float,float,float,float,float,float,float,float,float>)
(bind-type aiVector4D <float,float,float,float>)
(bind-type aiVector3D <float,float,float>)
(bind-type aiVector2D <float,float>)
(bind-type aiColor4D <float,float,float,float>)
(bind-type aiColor3D <float,float,float>)
(bind-type aiQuaternion <float,float,float,float>)
(bind-type aiTexel <i8,i8,i8,i8>) ;; b,g,r,a
(bind-type aiVectorKey <double,aiVector3D>) ;; good
(bind-type aiQuatKey <double,aiQuaternion>) ;; good
(bind-type aiMeshKey <double,i32>) ;; good
(bind-type aiNode <aiString,aiMatrix4x4,aiNode*,i32,aiNode**,i32,i32*,i8*>) ;; good 1144
(bind-type aiFace <i32,i32*>) ;; good
(bind-type aiVertexWeight <i32,float>) ;; good
(bind-type aiBone <aiString,i32,aiVertexWeight*,aiMatrix4x4>) ;; good
(bind-type aiAnimMesh <aiVector3D*,aiVector3D*,aiVector3D*,aiVector3D*,|8,aiColor4D*|,|8,aiVector3D*|,i32>) ;; good
(bind-type aiMesh <i32,i32,i32,aiVector3D*,aiVector3D*,aiVector3D*,aiVector3D*,|8,aiColor4D*|,|8,aiVector3D*|,|8,i32|,aiFace*,i32,aiBone**,i32,aiString,i32,aiAnimMesh**,i64>) ;; i64 on end is padding
(bind-type aiUVTransform <aiVector2D,aiVector2D,float>) ;; good
(bind-type aiMaterialProperty <aiString,i32,i32,i32,i32,i8*>) ;; good
(bind-type aiMaterial <aiMaterialProperty**,i32,i32>) ;; good
(bind-type aiNodeAnim <aiString,i32,aiVectorKey*,i32,aiQuatKey*,i32,aiVectorKey*,i32,i32>) ;; good
(bind-type aiMeshAnim <aiString,i32,aiMeshKey*>) ;; good
(bind-type aiAnimation <aiString,double,double,i32,aiNodeAnim**,i32,aiMeshAnim**>) ;; good
(bind-type aiTexture <i32,i32,|4,i8|,aiTexel*>) ;; good
(bind-type aiLight <aiString,i32,aiVector3D,aiVector3D,float,float,float,aiColor3D,aiColor3D,aiColor3D,float,float>) ;; good
(bind-type aiCamera <aiString,aiVector3D,aiVector3D,aiVector3D,float,float,float,float>) ;; good
(bind-type aiScene <i32,aiNode*,i32,aiMesh**,i32,aiMaterial**,i32,aiAnimation**,i32,aiTexture**,i32,aiLight**,i32,aiCamera**,i8*>) ;; good
(bind-type aiExportFormatDesc <i8*,i8*,i8*>)

(bind-lib libassimp aiImportFile [aiScene*,i8*,i32]*)
(bind-lib libassimp aiExportScene [i32,aiScene*,i8*,i8*,i32]*)
(bind-lib libassimp aiGetExportFormatCount [size_t]*)
(bind-lib libassimp aiGetExportFormatDescription [aiExportFormatDesc*,size_t]*)
(bind-lib libassimp aiReleaseImport [void,aiScene*]*)
(bind-lib libassimp aiIdentityMatrix4 [void,aiMatrix4x4*]*)
(bind-lib libassimp aiMultiplyMatrix4 [void,aiMatrix4x4*,aiMatrix4x4*]*)
(bind-lib libassimp aiTransformVecByMatrix4 [void,aiVector3D*,aiMatrix4x4*]*)
(bind-lib libassimp aiTransposeMatrix4 [void,aiMatrix4x4*]*)
(bind-lib libassimp aiTransposeMatrix3 [void,aiMatrix3x3*]*)
(bind-lib libassimp aiGetMaterialColor [i32,aiMaterial*,i8*,i32,i32,aiColor4D*]*)
(bind-lib libassimp aiGetMaterialString [i32,aiMaterial*,i8*,i32,i32,aiString*]*)
(bind-lib libassimp aiGetMaterialFloatArray [i32,aiMaterial*,i8*,i32,i32,float*,i32*]*)
(bind-lib libassimp aiGetMaterialIntegerArray [i32,aiMaterial*,i8*,i32,i32,i32*,i32*]*)
(bind-lib libassimp aiGetMaterialTexture [i32,aiMaterial*,i32,i32,aiString*,i32*,i32*,float*,i32*,i32*,i32*]*)
(bind-lib libassimp aiGetMaterialTextureCount [i32,aiMaterial*,i32]*)

(bind-lib-func stdlib ai_load_ogl_texture [i32,i8*,i32]*)
(bind-lib-func stdlib ai_load_ogl_texture_from_buffer [i32,i8*,i32,i32]*)
(bind-lib-func stdlib aiGetMaterialFloat [i32,aiMaterial*,i8*,i32,i32,float*]*)
(bind-lib-func stdlib ai_copy_matrix4 [i64,aiMatrix4x4*,aiMatrix4x4*]*)
(bind-lib-func stdlib ai_matrix4_to_float [void,aiMatrix4x4*,float*]*)
(bind-lib-func stdlib aisgl_min [float,float,float]*)
(bind-lib-func stdlib aisgl_max [float,float,float]*)
(bind-lib-func stdlib ai_print_string [i32,aiString*]*)
(bind-lib-func stdlib aiColor4f [void,aiColor4D*]*)
(bind-lib-func stdlib ai_color4_to_float4 [i64,aiColor4D*,float*]*)
(bind-lib-func stdlib ai_apply_material [void,aiMaterial*,i32]*)
(bind-lib-func stdlib ai_build_mesh_vbo [E_vbo*,aiMesh*,i32*]*)
(bind-lib-func stdlib ai_build_mesh [void,aiScene*,aiMesh*,xtm_mesh*,i8*]*)
(bind-lib-func stdlib ai_build_node [void,aiScene*,aiNode*,xtm_node*,xtm_node*,i8*]*)
(bind-lib-func stdlib ai_build_scene [xtm_node*,aiScene*,i8*]*)
(bind-lib-func stdlib assimp_load_model_a [xtm_node*,i8*,i8*,i32]*)
(bind-lib-func stdlib assimp_load_model_b [xtm_node*,i8*,i8*]*)
;; (bind-lib-func stdlib assimp_draw_mesh [void,xtm_mesh*,i32]*)
(bind-lib-func stdlib assimp_draw_node [void,xtm_node*,i32,float*,float*,float*,i32,float*]*)
(bind-lib-func stdlib assimp_draw_model [void,xtm_node*,i32,float*,float*,float*,i32,float*]*)
(bind-lib-func stdlib ai_load_textures [void,aiScene*]*)
(bind-lib-func stdlib ai_print_export_formats [void]*)
(bind-lib-func stdlib ai_convert [void,i8*,i8*,i8*,i32]*)


(bind-poly assimp_load_model assimp_load_model_a)
(bind-poly assimp_load_model assimp_load_model_b)

;; poly has no binding for scheme
(define assimp_load_model
  (lambda (dir file . args)
    (if (null? args)
        (assimp_load_model_b dir file)
        (assimp_load_model_a dir file (car args)))))

(define *xtmlib-assimp-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OpenVG setup
(sys:load-preload-check 'openvg)

(define libopenvg
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libOpenVG.so"))
	  ((string=? platform "Windows") (sys:load-dylib "libOpenVG.dll"))
	  ((string=? platform "OSX") (sys:load-dylib "libOpenVG.dylib"))
	  (else (sys:load-escape "Unknown platform for OpenVG lib")))))

(if (null? libopenvg)
    (sys:load-escape "Could not load OpenVG\n"))

(define *xtmlib-openvg-loaded* #f)
(print "Loading openvg library...      ")

(bind-alias VGint i32)
(bind-alias VGuint i32)
(bind-alias VGbitfield i32)
(bind-alias VGfloat float)
(bind-alias VGbyte i8)
(bind-alias VGubyte i8)
(bind-alias VGshort i16)
(bind-alias VGboolean i32)
(bind-lib-val stdlib VG_FALSE i32)
(bind-lib-val stdlib VG_TRUE i32)
(bind-alias VGHandle i8*)
(bind-alias VGPath i8*)
(bind-alias VGPaint i8*)
(bind-alias VGImage i8*)
(bind-alias VGErrorCode i32)
(bind-lib-val stdlib VG_NO_ERROR i32)
(bind-lib-val stdlib VG_BAD_HANDLE_ERROR i32)
(bind-lib-val stdlib VG_ILLEGAL_ARGUMENT_ERROR i32)
(bind-lib-val stdlib VG_OUT_OF_MEMORY_ERROR i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_ERROR i32)
(bind-lib-val stdlib VG_UNSUPPORTED_IMAGE_FORMAT_ERROR i32)
(bind-lib-val stdlib VG_UNSUPPORTED_PATH_FORMAT_ERROR i32)
(bind-lib-val stdlib VG_IMAGE_IN_USE_ERROR i32)
(bind-lib-val stdlib VG_NO_CONTEXT_ERROR i32)
(bind-alias VGParamType i32)
(bind-lib-val stdlib VG_MATRIX_MODE i32)
(bind-lib-val stdlib VG_FILL_RULE i32)
(bind-lib-val stdlib VG_IMAGE_QUALITY i32)
(bind-lib-val stdlib VG_RENDERING_QUALITY i32)
(bind-lib-val stdlib VG_BLEND_MODE i32)
(bind-lib-val stdlib VG_IMAGE_MODE i32)
(bind-lib-val stdlib VG_SCISSOR_RECTS i32)
(bind-lib-val stdlib VG_STROKE_LINE_WIDTH i32)
(bind-lib-val stdlib VG_STROKE_CAP_STYLE i32)
(bind-lib-val stdlib VG_STROKE_JOIN_STYLE i32)
(bind-lib-val stdlib VG_STROKE_MITER_LIMIT i32)
(bind-lib-val stdlib VG_STROKE_DASH_PATTERN i32)
(bind-lib-val stdlib VG_STROKE_DASH_PHASE i32)
(bind-lib-val stdlib VG_STROKE_DASH_PHASE_RESET i32)
(bind-lib-val stdlib VG_TILE_FILL_COLOR i32)
(bind-lib-val stdlib VG_CLEAR_COLOR i32)
(bind-lib-val stdlib VG_MASKING i32)
(bind-lib-val stdlib VG_SCISSORING i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT i32)
(bind-lib-val stdlib VG_SCREEN_LAYOUT i32)
(bind-lib-val stdlib VG_FILTER_FORMAT_LINEAR i32)
(bind-lib-val stdlib VG_FILTER_FORMAT_PREMULTIPLIED i32)
(bind-lib-val stdlib VG_FILTER_CHANNEL_MASK i32)
(bind-lib-val stdlib VG_MAX_SCISSOR_RECTS i32)
(bind-lib-val stdlib VG_MAX_DASH_COUNT i32)
(bind-lib-val stdlib VG_MAX_KERNEL_SIZE i32)
(bind-lib-val stdlib VG_MAX_SEPARABLE_KERNEL_SIZE i32)
(bind-lib-val stdlib VG_MAX_COLOR_RAMP_STOPS i32)
(bind-lib-val stdlib VG_MAX_IMAGE_WIDTH i32)
(bind-lib-val stdlib VG_MAX_IMAGE_HEIGHT i32)
(bind-lib-val stdlib VG_MAX_IMAGE_PIXELS i32)
(bind-lib-val stdlib VG_MAX_IMAGE_BYTES i32)
(bind-lib-val stdlib VG_MAX_FLOAT i32)
(bind-lib-val stdlib VG_MAX_GAUSSIAN_STD_DEVIATION i32)
(bind-alias VGRenderingQuality i32)
(bind-lib-val stdlib VG_RENDERING_QUALITY_NONANTIALIASED i32)
(bind-lib-val stdlib VG_RENDERING_QUALITY_FASTER i32)
(bind-lib-val stdlib VG_RENDERING_QUALITY_BETTER i32)
(bind-alias VGPixelLayout i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT_UNKNOWN i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT_RGB_VERTICAL i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT_BGR_VERTICAL i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT_RGB_HORIZONTAL i32)
(bind-lib-val stdlib VG_PIXEL_LAYOUT_BGR_HORIZONTAL i32)
(bind-alias VGMatrixMode i32)
(bind-lib-val stdlib VG_MATRIX_PATH_USER_TO_SURFACE i32)
(bind-lib-val stdlib VG_MATRIX_IMAGE_USER_TO_SURFACE i32)
(bind-lib-val stdlib VG_MATRIX_FILL_PAINT_TO_USER i32)
(bind-lib-val stdlib VG_MATRIX_STROKE_PAINT_TO_USER i32)
(bind-alias VGMaskOperation i32)
(bind-lib-val stdlib VG_CLEAR_MASK i32)
(bind-lib-val stdlib VG_FILL_MASK i32)
(bind-lib-val stdlib VG_SET_MASK i32)
(bind-lib-val stdlib VG_UNION_MASK i32)
(bind-lib-val stdlib VG_INTERSECT_MASK i32)
(bind-lib-val stdlib VG_SUBTRACT_MASK i32)
(bind-lib-val stdlib VG_PATH_FORMAT_STANDARD i32)
(bind-alias VGPathDatatype i32)
(bind-lib-val stdlib VG_PATH_DATATYPE_S_8 i32)
(bind-lib-val stdlib VG_PATH_DATATYPE_S_16 i32)
(bind-lib-val stdlib VG_PATH_DATATYPE_S_32 i32)
(bind-lib-val stdlib VG_PATH_DATATYPE_F i32)
(bind-alias VGPathAbsRel i32)
(bind-lib-val stdlib VG_ABSOLUTE i32)
(bind-lib-val stdlib VG_RELATIVE i32)
(bind-alias VGPathSegment i32)
(bind-lib-val stdlib VG_CLOSE_PATH i32)
(bind-lib-val stdlib VG_MOVE_TO i32)
(bind-lib-val stdlib VG_LINE_TO i32)
(bind-lib-val stdlib VG_HLINE_TO i32)
(bind-lib-val stdlib VG_VLINE_TO i32)
(bind-lib-val stdlib VG_QUAD_TO i32)
(bind-lib-val stdlib VG_CUBIC_TO i32)
(bind-lib-val stdlib VG_SQUAD_TO i32)
(bind-lib-val stdlib VG_SCUBIC_TO i32)
(bind-lib-val stdlib VG_SCCWARC_TO i32)
(bind-lib-val stdlib VG_SCWARC_TO i32)
(bind-lib-val stdlib VG_LCCWARC_TO i32)
(bind-lib-val stdlib VG_LCWARC_TO i32)
(bind-alias VGPathCommand i32)
(bind-lib-val stdlib VG_MOVE_TO_ABS i32)
(bind-lib-val stdlib VG_MOVE_TO_REL i32)
(bind-lib-val stdlib VG_LINE_TO_ABS i32)
(bind-lib-val stdlib VG_LINE_TO_REL i32)
(bind-lib-val stdlib VG_HLINE_TO_ABS i32)
(bind-lib-val stdlib VG_HLINE_TO_REL i32)
(bind-lib-val stdlib VG_VLINE_TO_ABS i32)
(bind-lib-val stdlib VG_VLINE_TO_REL i32)
(bind-lib-val stdlib VG_QUAD_TO_ABS i32)
(bind-lib-val stdlib VG_QUAD_TO_REL i32)
(bind-lib-val stdlib VG_CUBIC_TO_ABS i32)
(bind-lib-val stdlib VG_CUBIC_TO_REL i32)
(bind-lib-val stdlib VG_SQUAD_TO_ABS i32)
(bind-lib-val stdlib VG_SQUAD_TO_REL i32)
(bind-lib-val stdlib VG_SCUBIC_TO_ABS i32)
(bind-lib-val stdlib VG_SCUBIC_TO_REL i32)
(bind-lib-val stdlib VG_SCCWARC_TO_ABS i32)
(bind-lib-val stdlib VG_SCCWARC_TO_REL i32)
(bind-lib-val stdlib VG_SCWARC_TO_ABS i32)
(bind-lib-val stdlib VG_SCWARC_TO_REL i32)
(bind-lib-val stdlib VG_LCCWARC_TO_ABS i32)
(bind-lib-val stdlib VG_LCCWARC_TO_REL i32)
(bind-lib-val stdlib VG_LCWARC_TO_ABS i32)
(bind-lib-val stdlib VG_LCWARC_TO_REL i32)
(bind-alias VGPathCapabilities i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_APPEND_FROM i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_APPEND_TO i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_MODIFY i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_TRANSFORM_FROM i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_TRANSFORM_TO i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_INTERPOLATE_FROM i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_INTERPOLATE_TO i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_PATH_LENGTH i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_POINT_ALONG_PATH i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_TANGENT_ALONG_PATH i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_PATH_BOUNDS i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS i32)
(bind-lib-val stdlib VG_PATH_CAPABILITY_ALL i32)
(bind-alias VGPathParamType i32)
(bind-lib-val stdlib VG_PATH_FORMAT i32)
(bind-lib-val stdlib VG_PATH_DATATYPE i32)
(bind-lib-val stdlib VG_PATH_SCALE i32)
(bind-lib-val stdlib VG_PATH_BIAS i32)
(bind-lib-val stdlib VG_PATH_NUM_SEGMENTS i32)
(bind-lib-val stdlib VG_PATH_NUM_COORDS i32)
(bind-alias VGCapStyle i32)
(bind-lib-val stdlib VG_CAP_BUTT i32)
(bind-lib-val stdlib VG_CAP_ROUND i32)
(bind-lib-val stdlib VG_CAP_SQUARE i32)
(bind-alias VGJoinStyle i32)
(bind-lib-val stdlib VG_JOIN_MITER i32)
(bind-lib-val stdlib VG_JOIN_ROUND i32)
(bind-lib-val stdlib VG_JOIN_BEVEL i32)
(bind-alias VGFillRule i32)
(bind-lib-val stdlib VG_EVEN_ODD i32)
(bind-lib-val stdlib VG_NON_ZERO i32)
(bind-alias VGPaintMode i32)
(bind-lib-val stdlib VG_STROKE_PATH i32)
(bind-lib-val stdlib VG_FILL_PATH i32)
(bind-alias VGPaintParamType i32)
(bind-lib-val stdlib VG_PAINT_TYPE i32)
(bind-lib-val stdlib VG_PAINT_COLOR i32)
(bind-lib-val stdlib VG_PAINT_COLOR_RAMP_SPREAD_MODE i32)
(bind-lib-val stdlib VG_PAINT_COLOR_RAMP_PREMULTIPLIED i32)
(bind-lib-val stdlib VG_PAINT_COLOR_RAMP_STOPS i32)
(bind-lib-val stdlib VG_PAINT_LINEAR_GRADIENT i32)
(bind-lib-val stdlib VG_PAINT_RADIAL_GRADIENT i32)
(bind-lib-val stdlib VG_PAINT_PATTERN_TILING_MODE i32)
(bind-alias VGPaintType i32)
(bind-lib-val stdlib VG_PAINT_TYPE_COLOR i32)
(bind-lib-val stdlib VG_PAINT_TYPE_LINEAR_GRADIENT i32)
(bind-lib-val stdlib VG_PAINT_TYPE_RADIAL_GRADIENT i32)
(bind-lib-val stdlib VG_PAINT_TYPE_PATTERN i32)
(bind-alias VGColorRampSpreadMode i32)
(bind-lib-val stdlib VG_COLOR_RAMP_SPREAD_PAD i32)
(bind-lib-val stdlib VG_COLOR_RAMP_SPREAD_REPEAT i32)
(bind-lib-val stdlib VG_COLOR_RAMP_SPREAD_REFLECT i32)
(bind-alias VGTilingMode i32)
(bind-lib-val stdlib VG_TILE_FILL i32)
(bind-lib-val stdlib VG_TILE_PAD i32)
(bind-lib-val stdlib VG_TILE_REPEAT i32)
(bind-lib-val stdlib VG_TILE_REFLECT i32)
(bind-alias VGImageFormat i32)
(bind-lib-val stdlib VG_sRGBX_8888 i32)
(bind-lib-val stdlib VG_sRGBA_8888 i32)
(bind-lib-val stdlib VG_sRGBA_8888_PRE i32)
(bind-lib-val stdlib VG_lRGBX_8888 i32)
(bind-lib-val stdlib VG_lRGBA_8888 i32)
(bind-lib-val stdlib VG_lRGBA_8888_PRE i32)
(bind-lib-val stdlib VG_lARGB_8888 i32)
(bind-alias VGImageQuality i32)
(bind-lib-val stdlib VG_IMAGE_QUALITY_NONANTIALIASED i32)
(bind-lib-val stdlib VG_IMAGE_QUALITY_FASTER i32)
(bind-lib-val stdlib VG_IMAGE_QUALITY_BETTER i32)
(bind-alias VGImageParamType i32)
(bind-lib-val stdlib VG_IMAGE_FORMAT i32)
(bind-lib-val stdlib VG_IMAGE_WIDTH i32)
(bind-lib-val stdlib VG_IMAGE_HEIGHT i32)
(bind-alias VGImageMode i32)
(bind-lib-val stdlib VG_DRAW_IMAGE_NORMAL i32)
(bind-lib-val stdlib VG_DRAW_IMAGE_MULTIPLY i32)
(bind-lib-val stdlib VG_DRAW_IMAGE_STENCIL i32)
(bind-alias VGImageChannel i32)
(bind-lib-val stdlib VG_RED i32)
(bind-lib-val stdlib VG_GREEN i32)
(bind-lib-val stdlib VG_BLUE i32)
(bind-lib-val stdlib VG_ALPHA i32)
(bind-alias VGBlendMode i32)
(bind-lib-val stdlib VG_BLEND_SRC i32)
(bind-lib-val stdlib VG_BLEND_SRC_OVER i32)
(bind-lib-val stdlib VG_BLEND_DST_OVER i32)
(bind-lib-val stdlib VG_BLEND_SRC_IN i32)
(bind-lib-val stdlib VG_BLEND_DST_IN i32)
(bind-lib-val stdlib VG_BLEND_MULTIPLY i32)
(bind-lib-val stdlib VG_BLEND_SCREEN i32)
(bind-lib-val stdlib VG_BLEND_DARKEN i32)
(bind-lib-val stdlib VG_BLEND_LIGHTEN i32)
(bind-lib-val stdlib VG_BLEND_ADDITIVE i32)
(bind-lib-val stdlib VG_BLEND_SRC_OUT_SH i32)
(bind-lib-val stdlib VG_BLEND_DST_OUT_SH i32)
(bind-lib-val stdlib VG_BLEND_SRC_ATOP_SH i32)
(bind-lib-val stdlib VG_BLEND_DST_ATOP_SH i32)
(bind-alias VGHardwareQueryType i32)
(bind-lib-val stdlib VG_IMAGE_FORMAT_QUERY i32)
(bind-lib-val stdlib VG_PATH_DATATYPE_QUERY i32)
(bind-alias VGHardwareQueryResult i32)
(bind-lib-val stdlib VG_HARDWARE_ACCELERATED i32)
(bind-lib-val stdlib VG_HARDWARE_UNACCELERATED i32)
(bind-alias VGStringID i32)
(bind-lib-val stdlib VG_VENDOR i32)
(bind-lib-val stdlib VG_RENDERER i32)
(bind-lib-val stdlib VG_VERSION i32)
(bind-lib-val stdlib VG_EXTENSIONS i32)
(bind-alias VGUErrorCode i32)
(bind-lib-val stdlib VGU_NO_ERROR i32)
(bind-lib-val stdlib VGU_BAD_HANDLE_ERROR i32)
(bind-lib-val stdlib VGU_ILLEGAL_ARGUMENT_ERROR i32)
(bind-lib-val stdlib VGU_OUT_OF_MEMORY_ERROR i32)
(bind-lib-val stdlib VGU_PATH_CAPABILITY_ERROR i32)
(bind-lib-val stdlib VGU_BAD_WARP_ERROR i32)
(bind-alias VGUArcType i32)
(bind-lib-val stdlib VGU_ARC_OPEN i32)
(bind-lib-val stdlib VGU_ARC_CHORD i32)
(bind-lib-val stdlib VGU_ARC_PIE i32)
(bind-lib libopenvg vgGetError [i32]*)
(bind-lib libopenvg vgFlush [void]*)
(bind-lib libopenvg vgFinish [void]*)
(bind-lib libopenvg vgSetf [void,i32,float]*)
(bind-lib libopenvg vgSeti [void,i32,i32]*)
(bind-lib libopenvg vgSetfv [void,i32,i32,float*]*)
(bind-lib libopenvg vgSetiv [void,i32,i32,i32*]*)
(bind-lib libopenvg vgGetf [float,i32]*)
(bind-lib libopenvg vgGeti [i32,i32]*)
(bind-lib libopenvg vgGetVectorSize [i32,i32]*)
(bind-lib libopenvg vgGetfv [void,i32,i32,float*]*)
(bind-lib libopenvg vgGetiv [void,i32,i32,i32*]*)
(bind-lib libopenvg vgSetParameterf [void,i8*,i32,float]*)
(bind-lib libopenvg vgSetParameteri [void,i8*,i32,i32]*)
(bind-lib libopenvg vgSetParameterfv [void,i8*,i32,i32,float*]*)
(bind-lib libopenvg vgSetParameteriv [void,i8*,i32,i32,i32*]*)
(bind-lib libopenvg vgGetParameterf [float,i8*,i32]*)
(bind-lib libopenvg vgGetParameteri [i32,i8*,i32]*)
(bind-lib libopenvg vgGetParameterVectorSize [i32,i8*,i32]*)
(bind-lib libopenvg vgGetParameterfv [i8*,i32,i32,float*]*)
(bind-lib libopenvg vgGetParameteriv [i8*,i32,i32,i32*]*)
(bind-lib libopenvg vgLoadIdentity [void]*)
(bind-lib libopenvg vgLoadMatrix [void,float*]*)
(bind-lib libopenvg vgGetMatrix [void,float*]*)
(bind-lib libopenvg vgMultMatrix [void,float*]*)
(bind-lib libopenvg vgTranslate [void,float,float]*)
(bind-lib libopenvg vgScale [void,float,float]*)
(bind-lib libopenvg vgShear [void,float,float]*)
(bind-lib libopenvg vgRotate [void,float]*)
(bind-lib libopenvg vgMask [void,i8*,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgClear [void,i32,i32,i32,i32]*)
(bind-lib libopenvg vgCreatePath [i8*,i32,i32,float,float,i32,i32,i32]*)
(bind-lib libopenvg vgClearPath [void,i8*,i32]*)
(bind-lib libopenvg vgDestroyPath [void,i8*]*)
(bind-lib libopenvg vgRemovePathCapabilities [void,i8*,i32]*)
(bind-lib libopenvg vgGetPathCapabilities [i32,i8*]*)
(bind-lib libopenvg vgAppendPath [void,i8*,i8*]*)
(bind-lib libopenvg vgAppendPathData [void,i8*,i32,i8*,i8*]*)
(bind-lib libopenvg vgModifyPathCoords [void,i8*,i32,i32,i8*]*)
(bind-lib libopenvg vgTransformPath [void,i8*,i8*]*)
(bind-lib libopenvg vgInterpolatePath [i32,i8*,i8*,i8*,float]*)
(bind-lib libopenvg vgPathLength [i32,i8*,i32,i32]*)
(bind-lib libopenvg vgPointAlongPath [void,i8*,i32,i32,float,float*,float*,float*,float*]*)
(bind-lib libopenvg vgPathBounds [void,i8*,float*,float*,float*,float*]*)
(bind-lib libopenvg vgPathTransformedBounds [void,i8*,float,float*,float*,float*,float*]*)
(bind-lib libopenvg vgDrawPath [void,i8*,i32]*)
(bind-lib libopenvg vgCreatePaint [i8*]*)
(bind-lib libopenvg vgDestroyPaint [void,i8*]*)
(bind-lib libopenvg vgSetPaint [void,i8*,i32]*)
(bind-lib libopenvg vgPaintPattern [void,i8*,i8*]*)
(bind-lib libopenvg vgCreateImage [i8*,i32,i32,i32,i32]*)
(bind-lib libopenvg vgDestroyImage [void,i8*]*)
(bind-lib libopenvg vgImageSubData [void,i8*,i8*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgGetImageSubData [void,i8*,i8*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgChildImage [i8*,i8*,i32,i32,i32,i32]*)
(bind-lib libopenvg vgGetParent [i8*,i8*]*)
(bind-lib libopenvg vgCopyImage [void,i8*,i32,i32,i8*,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgDrawImage [void,i8*]*)
(bind-lib libopenvg vgSetPixels [void,i32,i32,i8*,i32,i32,i32,i32]*)
(bind-lib libopenvg vgWritePixels [void,i8*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgGetPixels [void,i8*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgReadPixels [void,i8*,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgCopyPixels [void,i32,i32,i32,i32,i32,i32]*)
(bind-lib libopenvg vgColorMatrix [void,i8*,i8*,float*]*)
(bind-lib libopenvg vgConvolve [void,i8*,i8*,i32,i32,i32,i32,i16*,float,float,i32]*)
(bind-lib libopenvg vgSeparableConvolve [void,i8*,i8*,i32,i32,i32,i32,i16*,i16*,float,float,i32]*)
(bind-lib libopenvg vgGaussianBlur [void,i8*,i8*,float,float,i32]*)
(bind-lib libopenvg vgLookup [void,i8*,i8*,i8*,i8*,i8*,i8*,i32,i32]*)
(bind-lib libopenvg vgLookupSingle [void,i8*,i8*,i32*,i32,i32,i32]*)
(bind-lib libopenvg vgHardwareQuery [i32,i32,i32]*)
(bind-lib libopenvg vgGetString [i8*,i32]*)
(bind-lib-val stdlib OVG_SH_blend_src_out i32)
(bind-lib-val stdlib OVG_SH_blend_dst_out i32)
(bind-lib-val stdlib OVG_SH_blend_src_atop i32)
(bind-lib-val stdlib OVG_SH_blend_dst_atop i32)
(bind-lib libopenvg vgCreateContextSH [i32,i32,i32]*)
(bind-lib libopenvg vgResizeSurfaceSH [void,i32,i32]*)
(bind-lib libopenvg vgDestroyContextSH [void]*)
(bind-lib libopenvg vguLine [i32,i8*,float,float,float,float]*)
(bind-lib libopenvg vguPolygon [i32,i8*,float*,i32,i32]*)
(bind-lib libopenvg vguRect [i32,i8*,float,float,float,float]*)
(bind-lib libopenvg vguRoundRect [i32,i8*,float,float,float,float,float,float]*)
(bind-lib libopenvg vguEllipse [i32,i8*,float,float,float,float]*)
(bind-lib libopenvg vguArc [i32,i8*,float,float,float,float,float,float,i32]*)
(bind-lib libopenvg vguComputeWarpQuadToSquare [i32,float,float,float,float,float,float,float,float,float*]*)
(bind-lib libopenvg vguComputeWarpSquareToQuad [i32,float,float,float,float,float,float,float,float,float*]*)
(bind-lib libopenvg vguComputeWarpQuadToQuad [i32,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float*]*)
(bind-lib-func stdlib xtm_vg_error_string [i8*,i32]*)
(bind-lib-func stdlib xtm_vg_print_error [i32]*)
(bind-lib-func stdlib xtm_create_vg_context [i32,i64,i64]*)
(bind-lib-func stdlib xtm_vg_setup [void]*)
(bind-lib-func stdlib xtm_create_vgpath [i8*]*)
(bind-alias xtm_colour |4,float|)
(bind-alias xtm_color |4,float|)
(bind-lib-func stdlib xtm_vg_clear_rect [void,double,double,double,double,i64,i64,i64,i64]*)
(bind-lib-func stdlib xtm_vg_clear [void,double,double,double,double,i64,i64]*)
(bind-lib-func stdlib xtm_paint_setupf [void,i8*,float,float,float,float]*)
(bind-lib-func stdlib xtm_paint_setupd [void,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_paint_setup_strokef [void,i8*,float,float,float,float,float]*)
(bind-lib-func stdlib xtm_paint_setup_stroked [void,i8*,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_paint_setup_fillf [void,i8*,float,float,float,float]*)
(bind-lib-func stdlib xtm_paint_setup_filld [void,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_destroy_paint [void,i8*]*)
(bind-lib-func stdlib xtm_draw_path_keep [void,i8*]*)
(bind-lib-func stdlib xtm_draw_path [void,i8*]*)
(bind-lib-func stdlib xtm_clear_path [void,i8*]*)
(bind-lib-func stdlib xtm_destroy_path [void,i8*]*)
(bind-lib-func stdlib xtm_stroke_path_keep [void,i8*]*)
(bind-lib-func stdlib xtm_stroke_path [void,i8*]*)
(bind-lib-func stdlib xtm_fill_path_keep [void,i8*]*)
(bind-lib-func stdlib xtm_fill_path [void,i8*]*)
(bind-lib-func stdlib xtm_add_linef [i32,i8*,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_lined [i32,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_polyf [i32,i8*,float*,i32,i32]*)
(bind-lib-func stdlib xtm_add_polyd [i32,i8*,double*,i64,i32]*)
(bind-lib-func stdlib xtm_add_trif [i32,i8*,float,float,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_trid [i32,i8*,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_quadf [i32,i8*,float,float,float,float,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_quadd [i32,i8*,double,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_rectf [i32,i8*,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_rectd [i32,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_round_rectf [i32,i8*,float,float,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_round_rectd [i32,i8*,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_ellipsef [i32,i8*,float,float,float,float]*)
(bind-lib-func stdlib xtm_add_ellipsed [i32,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_add_arcf [i32,i8*,float,float,float,float,float,float,i32]*)
(bind-lib-func stdlib xtm_add_arcd [i32,i8*,double,double,double,double,double,double,i32]*)
(bind-lib-func stdlib xtm_draw_linef [void,float,float,float,float]*)
(bind-lib-func stdlib xtm_draw_lined [void,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_polyf [void,float*,i32,i32]*)
(bind-lib-func stdlib xtm_draw_polyd [void,double*,i64,i32]*)
(bind-lib-func stdlib xtm_draw_trid [void,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_quadd [void,double,double,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_rectf [void,float,float,float,float]*)
(bind-lib-func stdlib xtm_draw_rectd [void,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_round_rectf [void,float,float,float,float,float,float]*)
(bind-lib-func stdlib xtm_draw_round_rectd [void,double,double,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_ellipsef [void,float,float,float,float]*)
(bind-lib-func stdlib xtm_draw_ellipsed [void,double,double,double,double]*)
(bind-lib-func stdlib xtm_draw_arcf [void,float,float,float,float,float,float,i32]*)
(bind-lib-func stdlib xtm_draw_arcd [void,double,double,double,double,double,double,i32]*)
(bind-lib-func stdlib xtm_create_vgimage [i8*,i64,i64]*)
(bind-lib-func stdlib xtm_destroy_vgimage [void,i8*]*)
(bind-lib-func stdlib xtm_set_vgimage_subdata [void,i8*,i8*,i64,i64,i64,i64,i64]*)
(bind-lib-func stdlib xtm_load_vgimage [i8*,i8*]*)
(bind-lib-func stdlib xtm_set_color32 [i8,i8*,double,double,double,double]*)
(bind-lib-func stdlib xtm_color32_red [double,i8*]*)
(bind-lib-func stdlib xtm_set_color32_red [i8,i8*,double]*)
(bind-lib-func stdlib xtm_color32_green [double,i8*]*)
(bind-lib-func stdlib xtm_set_color32_green [i8,i8*,double]*)
(bind-lib-func stdlib xtm_color32_blue [double,i8*]*)
(bind-lib-func stdlib xtm_set_color32_blue [i8,i8*,double]*)
(bind-lib-func stdlib xtm_color32_alpha [double,i8*]*)
(bind-lib-func stdlib xtm_set_color32_alpha [i8,i8*,double]*)

(bind-poly xtm_draw_arc xtm_draw_arcf)
(bind-poly xtm_draw_arc xtm_draw_arcd)

(bind-poly xtm_draw_arc xtm_draw_arcf)
(bind-poly xtm_draw_arc xtm_draw_arcd)

(bind-poly xtm_draw_ellipse xtm_draw_ellipsef)
(bind-poly xtm_draw_ellipse xtm_draw_ellipsed)

(bind-poly xtm_draw_ellipse xtm_draw_ellipsef)
(bind-poly xtm_draw_ellipse xtm_draw_ellipsed)

(bind-poly xtm_draw_round_rect xtm_draw_round_rectf)
(bind-poly xtm_draw_round_rect xtm_draw_round_rectd)

(bind-poly xtm_draw_round_rect xtm_draw_round_rectf)
(bind-poly xtm_draw_round_rect xtm_draw_round_rectd)

(bind-poly xtm_draw_rect xtm_draw_rectf)
(bind-poly xtm_draw_rect xtm_draw_rectd)

(bind-poly xtm_draw_rect xtm_draw_rectf)
(bind-poly xtm_draw_rect xtm_draw_rectd)

(bind-poly xtm_draw_quad xtm_draw_quadd)
(bind-poly xtm_draw_tri xtm_draw_trid)

(bind-poly xtm_draw_poly xtm_draw_polyf)
(bind-poly xtm_draw_poly xtm_draw_polyd)

(bind-poly xtm_draw_poly xtm_draw_polyf)
(bind-poly xtm_draw_poly xtm_draw_polyd)

(bind-poly xtm_draw_line xtm_draw_linef)
(bind-poly xtm_draw_line xtm_draw_lined)

(bind-poly xtm_draw_line xtm_draw_linef)
(bind-poly xtm_draw_line xtm_draw_lined)

(bind-poly xtm_add_arc xtm_add_arcf)
(bind-poly xtm_add_arc xtm_add_arcd)

(bind-poly xtm_add_arc xtm_add_arcf)
(bind-poly xtm_add_arc xtm_add_arcd)

(bind-poly xtm_add_ellipse xtm_add_ellipsef)
(bind-poly xtm_add_ellipse xtm_add_ellipsed)

(bind-poly xtm_add_ellipse xtm_add_ellipsef)
(bind-poly xtm_add_ellipse xtm_add_ellipsed)

(bind-poly xtm_add_round_rect xtm_add_round_rectf)
(bind-poly xtm_add_round_rect xtm_add_round_rectd)

(bind-poly xtm_add_round_rect xtm_add_round_rectf)
(bind-poly xtm_add_round_rect xtm_add_round_rectd)

(bind-poly xtm_add_rect xtm_add_rectf)
(bind-poly xtm_add_rect xtm_add_rectd)

(bind-poly xtm_add_rect xtm_add_rectf)
(bind-poly xtm_add_rect xtm_add_rectd)

(bind-poly xtm_paint_setup xtm_paint_setupf)
(bind-poly xtm_paint_setup xtm_paint_setupd)

(bind-poly xtm_paint_setup_stroke xtm_paint_setup_strokef)
(bind-poly xtm_paint_setup_stroke xtm_paint_setup_stroked)

(bind-poly xtm_paint_setup_stroke xtm_paint_setup_strokef)
(bind-poly xtm_paint_setup_stroke xtm_paint_setup_stroked)

(bind-poly xtm_paint_setup_fill xtm_paint_setup_fillf)
(bind-poly xtm_paint_setup_fill xtm_paint_setup_filld)

(bind-poly xtm_paint_setup_fill xtm_paint_setup_fillf)
(bind-poly xtm_paint_setup_fill xtm_paint_setup_filld)

(bind-poly xtm_add_line xtm_add_linef)
(bind-poly xtm_add_line xtm_add_lined)

(bind-poly xtm_add_line xtm_add_linef)
(bind-poly xtm_add_line xtm_add_lined)

(bind-poly xtm_add_poly xtm_add_polyf)
(bind-poly xtm_add_poly xtm_add_polyd)

(bind-poly xtm_add_poly xtm_add_polyf)
(bind-poly xtm_add_poly xtm_add_polyd)

(bind-poly xtm_add_tri xtm_add_trif)
(bind-poly xtm_add_tri xtm_add_trid)

(bind-poly xtm_add_tri xtm_add_trif)
(bind-poly xtm_add_tri xtm_add_trid)

(bind-poly xtm_add_quad xtm_add_quadf)
(bind-poly xtm_add_quad xtm_add_quadd)

(bind-poly xtm_add_quad xtm_add_quadf)
(bind-poly xtm_add_quad xtm_add_quadd)

(bind-poly xtm_paint_setup xtm_paint_setupf)
(bind-poly xtm_paint_setup xtm_paint_setupd)

(define *xtmlib-openvg-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)

;;;;;;;;;;;;;;;;;
;; libdrawtext ;;
;;;;;;;;;;;;;;;;;

(sys:load-preload-check 'drawtext)

(define libdrawtext
  (let ((platform (sys:platform)))
    (cond ((string=? platform "Linux") (sys:load-dylib "libdrawtext.so"))
	  ((string=? platform "Windows") (sys:load-dylib "libdrawtext.dll"))
	  ((string=? platform "OSX") (sys:load-dylib "libdrawtext.dylib"))
	  (else (print "Unknown platform: " platform)))))

(define *xtmlib-drawtext-loaded* #f)
(print "Loading drawtext library...    ")

(bind-alias dtx_font i8)
(bind-alias dtx_glyphmap i8)

(bind-lib-val stdlib DTX_NBF i32)	;; unbuffered
(bind-lib-val stdlib DTX_LBF i32)	;; line buffered
(bind-lib-val stdlib DTX_FBF i32)	;; fully buffered

;; <x,y,width,height>
(bind-type dtx_box <float,float,float,float>)

;; Open a truetype/opentype/whatever font.

;; If sz is non-zero, the default ASCII glyphmap at the requested
;; point size is automatically created as well, and ready to use.

;; To use other unicode ranges and different font sizes you must first
;; call dtx_prepare or dtx_prepare_range before issuing any drawing
;; calls, otherwise nothing will be rendered.

;; struct dtx_font *dtx_open_font(const char *fname, int sz);
(bind-lib libdrawtext dtx_open_font [i8*,i8*,i32]*)
;; void dtx_close_font(struct dtx_font *fnt);
(bind-lib libdrawtext dtx_close_font [void,i8*]*)

;; prepare an ASCII glyphmap for the specified font size
;; void dtx_prepare(struct dtx_font *fnt, int sz);
(bind-lib libdrawtext dtx_prepare [void,i8*,i32]*)

;; prepare an arbitrary unicode range glyphmap for the specified font size
;; void dtx_prepare_range(struct dtx_font *fnt, int sz, int cstart, int cend);
(bind-lib libdrawtext dtx_prepare_range [void,i8*,i32,i32,i32]*)

;; Finds the glyphmap that contains the specified character code and
;; matches the requested size. Returns null if it hasn't been created
;; (you should call dtx_prepare/dtx_prepare_range).
;; struct dtx_glyphmap *dtx_get_font_glyphmap(struct dtx_font *fnt, int sz, int code);
(bind-lib libdrawtext dtx_get_font_glyphmap [i8*,i8*,i32,i32]*)

;; Finds the glyphmap that contains the specified unicode range and
;; matches the rested font size. Will automatically generate one if it
;; can't find it.
;; struct dtx_glyphmap *dtx_get_font_glyphmap_range(struct dtx_font *fnt, int sz, int cstart, int cend);
(bind-lib libdrawtext dtx_get_font_glyphmap_range [i8*,i8*,i32,i32,i32]*)

;; Creates and returns a glyphmap for a particular unicode range and
;; font size. The generated glyphmap is added to the font's list of
;; glyphmaps.

;; struct dtx_glyphmap *dtx_create_glyphmap_range(struct dtx_font *fnt, int sz, int cstart, int cend);
(bind-lib libdrawtext dtx_create_glyphmap_range [i8*,i8*,i32,i32,i32]*)

(bind-lib libdrawtext dtx_free_glyphmap [void,i8*]*)

;; returns a pointer to the raster image of a glyphmap (1 byte per
;; pixel grayscale)
;; unsigned char *dtx_get_glyphmap_image(struct dtx_glyphmap *gmap);
;; (bind-lib libdrawtext dtx_get_glyphmap_image [i8*,i8*]*)

;; returns the width of the glyphmap image in pixels
;; int dtx_get_glyphmap_width(struct dtx_glyphmap *gmap);
(bind-lib libdrawtext dtx_get_glyphmap_width [i32,i8*]*)
;; returns the height of the glyphmap image in pixels
;; int dtx_get_glyphmap_height(struct dtx_glyphmap *gmap);
(bind-lib libdrawtext dtx_get_glyphmap_height [i32,i8*]*)

;; The following functions can be used even when the library is
;; compiled without freetype support. (TODO)

;; struct dtx_glyphmap *dtx_load_glyphmap(const char *fname);
;; struct dtx_glyphmap *dtx_load_glyphmap_stream(FILE *fp);
;; int dtx_save_glyphmap(const char *fname, const struct dtx_glyphmap *gmap);
;; int dtx_save_glyphmap_stream(FILE *fp, const struct dtx_glyphmap *gmap);


;;;;;;;;;;;;;;;
;; rendering ;;
;;;;;;;;;;;;;;;

;; before drawing anything this function must set the font to use
;; void dtx_use_font(struct dtx_font *fnt, int sz);
(bind-lib libdrawtext dtx_use_font [void,i8*,i32]*)

;; /sets the buffering mode
;;  - DTX_NBUF: every call to dtx_string gets rendered immediately.
;;  - DTX_LBUF: renders when the buffer is full or the string contains a newline.
;;  - DTX_FBUF: renders only when the buffer is full (you must call dtx_flush explicitly).

;; (bind-lib libdrawtext dtx_draw_buffering [void,i32]*)

;; Sets the vertex attribute indices to use for passing vertex and
;; texture coordinate data. By default both are -1 which means you
;; don't have to use a shader, and if you do they are accessible
;; through gl_Vertex and gl_MultiTexCoord0, as usual.
;;
;; NOTE: If you are using OpenGL ES 2.x or OpenGL >= 3.1 pure
;; (non-compatibility) context you must specify valid attribute
;; indices.
;; void dtx_vertex_attribs(int vert_attr, int tex_attr);
(bind-lib libdrawtext dtx_vertex_attribs [void,i32,i32]*)

;; draws a single glyph at the origin
;; void dtx_glyph(int code);
(bind-lib libdrawtext dtx_glyph [void,i32]*)
;; draws a utf-8 string starting at the origin. \n \r and \t are handled appropriately.
;; void dtx_string(const char *str);
(bind-lib libdrawtext dtx_string [void,i8*]*)

;; render any pending glyphs (see dtx_draw_buffering)
;; void dtx_flush(void);
(bind-lib libdrawtext dtx_flush [void]*)

;;;;;;;;;;;;;;;
;; encodings ;;
;;;;;;;;;;;;;;;

;; returns a pointer to the next character in a utf-8 stream
;; char *dtx_utf8_next_char(char *str);
(bind-lib libdrawtext dtx_utf8_next_char [i8*,i8*]*)

;; returns the unicode character codepoint of the utf-8 character starting at str
;; int dtx_utf8_char_code(const char *str);
(bind-lib libdrawtext dtx_utf8_char_code [i32,i8*]*)

;; returns the number of bytes of the utf-8 character starting at str
;; int dtx_utf8_nbytes(const char *str);
(bind-lib libdrawtext dtx_utf8_nbytes [i32,i8*]*)

;; returns the number of utf-8 character in a zero-terminated utf-8 string
;; int dtx_utf8_char_count(const char *str);
(bind-lib libdrawtext dtx_utf8_char_count [i32,i8*]*)

;; Converts a unicode code-point to a utf-8 character by filling in
;; the buffer passed at the second argument, and returns the number of
;; bytes taken by that utf-8 character.
;; 
;; It's valid to pass a null buffer pointer, in which case only the
;; byte count is returned (useful to figure out how much memory to
;; allocate for a buffer).
;; size_t dtx_utf8_from_char_code(int code, char *buf);
(bind-lib libdrawtext dtx_utf8_from_char_code [i64,i32,i8*]*)

;; Converts a unicode utf-16 wchar_t string to utf-8, filling in the
;; buffer passed at the second argument. Returns the size of the
;; resulting string in bytes.

;; It's valid to pass a null buffer pointer, in which case only the
;; size gets calculated and returned, which is useful for figuring out
;; how much memory to allocate for the utf-8 buffer.
;; size_t dtx_utf8_from_string(const wchar_t *str, char *buf);
(bind-lib libdrawtext dtx_utf8_from_string [i64,i32,i8*]*)


;;;;;;;;;;;;;
;; metrics ;;
;;;;;;;;;;;;;

;; float dtx_line_height(void);
(bind-lib libdrawtext dtx_line_height [float]*)

;; rendered dimensions of a single glyph
;; void dtx_glyph_box(int code, struct dtx_box *box);
(bind-lib libdrawtext dtx_glyph_box [void,i32,dtx_box*]*)
;; float dtx_glyph_width(int code);
(bind-lib libdrawtext dtx_glyph_width [float,i32]*)
;; float dtx_glyph_height(int code);
(bind-lib libdrawtext dtx_glyph_height [float,i32]*)

;; rendered dimensions of a string
;; void dtx_string_box(const char *str, struct dtx_box *box);
(bind-lib libdrawtext dtx_string_box [void,i8*,dtx_box*]*)
;; float dtx_string_width(const char *str);
(bind-lib libdrawtext dtx_string_width [float,i8*]*)
;; float dtx_string_height(const char *str);
(bind-lib libdrawtext dtx_string_height [float,i8*]*)

;; returns the horizontal position of the n-th character of the
;; rendered string (useful for placing cursors)
;; float dtx_char_pos(const char *str, int n);
(bind-lib libdrawtext dtx_char_pos [float,i8*,i32]*)

;; int dtx_char_at_pt(const char *str, float pt);
(bind-lib libdrawtext dtx_char_at_pt [i32,i8*,float]*)

(define *xtmlib-drawtext-loaded* #t)
(ascii-print-color 0 2 10)
(print "[YES]")
(ascii-print-color 0 7 10)
(println)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; FINISHED LOADING LIBS
;;
;;;;;

(suppress-compiler-messages #f)

(ascii-print-color 0 6 10)
(print "\nFinished loading xtm standard lib.\n\n")
(ascii-print-color 0 7 10)

;; (print "\n*** xtm standard library loaded successfully ***\n\n")

(define *xtmlib-stdlib-loaded* #t)
