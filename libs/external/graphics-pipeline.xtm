;;; graphics-pipeline.xtm -- OpenGL Extempore graphics pipeline

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: openGL

;;; Commentary:

;; TODO

;;; Code:

;; lib-loading config
(if *impc:compiler:with-cache* (sys:load "libs/aot-cache/graphics-pipeline.xtm" 'quiet))
(sys:load-preload-check 'graphics-pipeline)
(define *xtmlib-graphics-pipeline-loaded* #t)

(impc:aot:suppress-aot-do
 (sys:load "libs/base/base.xtm")
 (sys:load "libs/core/math.xtm")
 (sys:load "libs/external/gl.xtm")
 (sys:load "libs/external/stb_image.xtm")
 (sys:load "libs/external/gl/gl-objects2.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/base/base.xtm" 'quiet)
 (sys:load "libs/core/math.xtm" 'quiet)
 (sys:load "libs/external/gl.xtm" 'quiet)
 (sys:load "libs/external/stb_image.xtm" 'quiet)
 (sys:load "libs/external/gl/gl-objects2.xtm" 'quiet))

(impc:aot:insert-header "xtmgraphics-pipeline")
(impc:aot:import-ll "xtmgraphics-pipeline")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; OpenGL related Matrix Operations
;;

(bind-func mat4_to_mat3
  (lambda (mat4:float* mat3:float*)
    (pfill! mat3
            (pref mat4 0) (pref mat4 1) (pref mat4 2)
            (pref mat4 4) (pref mat4 5) (pref mat4 6)
            (pref mat4 8) (pref mat4 9) (pref mat4 10))
    void))

(bind-func plane_intersection
  (lambda (ray_origin:float* ray_dir:float* plane_centre:float* plane_normal:float*)
    (let ((denom (vvdot plane_normal ray_dir 3))
          (t -1.0))
      (if (> (fabs denom) 0.0001:f) ;; epsilon
          (begin
            (vvsub plane_centre ray_origin 3 plane_centre)
            (set! t (/ (vvdot plane_centre plane_normal 3)
                       denom))))
      (if (>= t 0.0)
          #t
          #f))))

(bind-func translate_matrix
  (lambda (mat:float* x y z)
    (let ((mat2:float* (salloc 32))
          (mat3 (pref-ptr mat2 16)))
      (pfill! mat2
              1.0 0.0 0.0 0.0
              0.0 1.0 0.0 0.0
              0.0 0.0 1.0 0.0
              x   y   z   1.0)
      (mmmul mat mat2 mat3)
      (memcpy (cast mat i8*) (cast mat3 i8*) (* 16 4))
      void)))

(bind-func scale_matrix
  (lambda (mat:float* x:float y:float z:float)
    (let ((mat2:float* (salloc 32))
          (mat3:float* (pref-ptr mat2 16)))
      (pfill! mat2
              x     0.0   0.0   0.0
              0.0   y     0.0   0.0
              0.0   0.0   z     0.0
              0.0   0.0   0.0   1.0)
      (mmmul mat mat2 mat3)
      (memcpy (cast mat i8*) (cast mat3 i8*) (* 16 4))
      void)))

(bind-func invert_matrix
  (lambda (mat:float*)
    (let ((mat2:float* (salloc 16)))
      (minverse mat 4 mat2)
      (memcpy (cast mat i8*) (cast mat2 i8*) (* 16 4))
      void)))

(bind-func rotate_matrix
  (lambda (mat:float* alpha:float x:float y:float z:float)
    (let ((c (cos alpha))
          (c-1 (- 1.0 c))
          (s (sin alpha))
          (mat2:float* (salloc 16))
          (mat3:float* (salloc 16))
          (vec1:float* (salloc 3)) ;; axis to rotate around (normalized)
          (vec2:float* (salloc 3))) ;; axis to rotate around (normalized)
      (pfill! vec1 x y z)
      (vnormalise vec1 3 vec2)
      (set! x (pref vec2 0))
      (set! y (pref vec2 1))
      (set! z (pref vec2 2))
      (pfill! mat2
              (+ (* x x c-1) c) (- (* x y c-1) (* z s)) (+ (* x z c-1) (* y s)) 0.0
              (+ (* y x c-1) (* z s)) (+ (* y y c-1) c) (- (* y z c-1) (* x s)) 0.0
              (- (* x z c-1) (* y s)) (+ (* y z c-1) (* x s)) (+ (* z z c-1) c) 0.0
              0.0               0.0                     0.0                     1.0)
      (mmmul mat mat2 mat3)
      (memcpy (cast mat i8*) (cast mat3 i8*) (* 16 4))
      void)))

;; this is similar to gluPerspective
;; but fills a suitable PROJECTION matrix
(bind-func fill_identity_matrix
  (lambda (mat:float*)
    (pfill! mat
            1.0 0.0 0.0 0.0
            0.0 1.0 0.0 0.0
            0.0 0.0 1.0 0.0
            0.0 0.0 0.0 1.0)
    void))

(bind-func fill_pos_scale_matrix
  (lambda (mat:float* posx posy posz scalex scaley scalez)
    (pfill! mat
            scalex 0.0 0.0 0.0
            0.0 scaley 0.0 0.0
            0.0 0.0 scalez 0.0
            posx posy posz 1.0)
    void))

;; this is similar to gluPerspective
;; but fills a suitable PROJECTION matrix
;; (bind-func fill_projection_matrix
;;   (lambda (mat:float* fovy aspect near far)
;;     (let ((top (* near (tanf fovy)))
;;           (right (* top aspect))
;;           (left (* -1.0 right))
;;           (bottom (* -1.0 top)))
;;       (pfill! mat
;;               (/ near right) 0.0 0.0 0.0
;;               0.0 (/ near top) 0.0 0.0
;;               0.0 0.0 (* -1.0 (/ (+ far near) (- far near))) -1.0
;;               0.0 0.0 (* -1.0 (/ (* 2.0 far near) (- far near))) 0.0)
;;       void)))

(bind-func fill_projection_matrix
  (lambda (mat:float* fovy aspect near far)
    (let ((a (* fovy (/ PIf 180.0))) ;; convert deg to rad
          (c (/ (cos (* a 0.5)) (sin (* a 0.5)))))
      (pfill! mat
              (/ c aspect) 0.0 0.0 0.0
              0.0 c 0.0 0.0
              0.0 0.0 (* -1.0 (/ (+ far near) (- far near))) -1.0
              0.0 0.0 (* -1.0 (/ (* 2.0 far near) (- far near))) 0.0)
      void)))

;; left right bottom top near far
(bind-func fill_projection_matrix
  (lambda (mat:float* l r b t n f)
    (pfill! mat
            (/ 2.0 (- r l)) 0.0 0.0 0.0
            0.0 (/ (* 2.0 n) (- t b)) 0.0 0.0
            (/ (+ r l) (- r l)) (/ (+ t b) (- t b)) (* -1.0 (/ (+ f n) (- f n))) -1.0
            0.0 0.0 (* -1.0 (* 2.0 f n) (- f n)) 0.0)
    void))

;; this is similar to gluPerspective
;; but fills a suitable PROJECTION matrix
(bind-func fill_orthographic_matrix
  (lambda (mat:float* left right bottom top near far)
    (pfill! mat
            (/ 2.0 (- right left)) 0.0 0.0 0.0
            0.0 (/ 2.0 (- top bottom)) 0.0 0.0
            0.0 0.0 (* -1.0 (/ 2.0 (- far near))) 0.0
            (* -1.0 (/ (+ left right) (- right left)))
            (* -1.0 (/ (+ top bottom) (- top bottom)))
            (* -1.0 (/ (+ far near) (- far near)))
            1.0)
    void))

;; where v1 and v2 can be v3 or v4
;; but v3 MUST be v4
(bind-func fill_direction_vector
  (lambda (v1:float* v2:float* v3:float*)
    (let ((tmp:float* (salloc 4)))
      (vvsub v1 v2 3 tmp)
      (vnormalise tmp 3 v3)
      (pset! v3 3 0.0) ;; direction vectors get w = 0.0
      void)))

;; this is similar to gl_look_at
;; but returns a suitable VIEW matrix
(bind-func fill_view_matrix
  (let ((orientation_matrix:float* (alloc 16))
        (translation_matrix:float* (alloc 16))
        (vz:float* (alloc 3)) ;; vector z axes
        (vy:float* (alloc 3)) ;; vector y axes
        (vx:float* (alloc 3)) ;; vector x axes
        (vtmp:float* (alloc 3)))
    (lambda (matrix:float* vEye vTarget vUp)
      (let ((i 0))
        (vvsub vEye vTarget 3 vtmp)
        (vnormalise vtmp 3 vz) ;; gives z axes
        ;; cross z with up
        (vvcross vUp vz vtmp)
        (vnormalise vtmp 3 vx) ;; gives x axes
        (vvcross vz vx vy) ;; gives y axes
        ;; (pfill! mat
        ;;         (pref vx 0) (pref vx 1) (pref vx 2) 0.0
        ;;         (pref vy 0) (pref vy 1) (pref vy 2) 0.0
        ;;         (pref vz 0) (pref vz 1) (pref vz 2) 0.0
        ;;         (pref vEye 0) (pref vEye 1) (pref vEye 2) 1.0)
        (pfill! orientation_matrix
                (pref vx 0) (pref vy 0) (pref vz 0) 0.0
                (pref vx 1) (pref vy 1) (pref vz 1) 0.0
                (pref vx 2) (pref vy 2) (pref vz 2) 0.0
                0.0 0.0 0.0 1.0)
        (pfill! translation_matrix
                1.0 0.0 0.0 0.0
                0.0 1.0 0.0 0.0
                0.0 0.0 1.0 0.0
                (* -1.0 (pref vEye 0)) (* -1.0 (pref vEye 1)) (* -1.0 (pref vEye 2)) 1.0)
        ;; (minverse mat 4 matrix)
        (mmmul translation_matrix orientation_matrix matrix)
        void))))

;; this is similar to gl_look_at
;; but returns a suitable VIEW matrix
;;
;; same as fill_view_matrix but
;; instead of a target:position
;; we provide a    dir:vector
(bind-func fill_view_matrix_dir
  (let ((orientation_matrix:float* (alloc 16))
        (translation_matrix:float* (alloc 16))
        (vz:float* (alloc 3)) ;; vector z axes
        (vy:float* (alloc 3)) ;; vector y axes
        (vx:float* (alloc 3)) ;; vector x axes
        (vtmp:float* (alloc 3)))
    (lambda (matrix:float* vEye:float* vDir vUp)
      (let ((i 0))
        (vnormalise vDir 3 vz)
        (vnormalise vUp 3 vtmp)
        (vvcross vtmp vz vy) ;; use vy as a tmp here
        (vnormalise vy 3 vx)
        (vvcross vz vx vy)
        ;; (pfill! mat
        ;;         (pref vx 0) (pref vx 1) (pref vx 2) 0.0
        ;;         (pref vy 0) (pref vy 1) (pref vy 2) 0.0
        ;;         (pref vz 0) (pref vz 1) (pref vz 2) 0.0
        ;;         (pref vEye 0) (pref vEye 1) (pref vEye 2) 1.0)
        ;; (minverse mat 4 matrix)
        (pfill! orientation_matrix
                (pref vx 0) (pref vy 0) (pref vz 0) 0.0
                (pref vx 1) (pref vy 1) (pref vz 1) 0.0
                (pref vx 2) (pref vy 2) (pref vz 2) 0.0
                0.0 0.0 0.0 1.0)
        (pfill! translation_matrix
                1.0 0.0 0.0 0.0
                0.0 1.0 0.0 0.0
                0.0 0.0 1.0 0.0
                (* -1.0 (pref vEye 0)) (* -1.0 (pref vEye 1)) (* -1.0 (pref vEye 2)) 1.0)
        ;; (minverse mat 4 matrix)
        (mmmul translation_matrix orientation_matrix matrix)
        void))))


;; 0 vertex id
;; 1 weight
(bind-type XTMVertexWeight <i32,float>)
;; 0 name
;; 1 idx
;; 2 transmat
;; 3 offsetmat
;; 4 num_children
;; 5 children
;; 6 parent (null if no parent)
(bind-type XTMBone <String*,i32,float*,float*,i32,XTMBone**,XTMBone*>)
;; 0 vbo
;; 1 texture
;; 2 diffuse
;; 3 ambient
;; 4 specular
;; 5 emissive
;; 6 shininess
;; 7 opacity
;; 8 facemode (GL_TRIANGLE, GL_QUAD etc.)
;; 9 number of verts
;; 10 vao
;; 11 name
;; 12 num bones
;; 13 bones
;; 14 max active bones
;; 15 diffuse texture (currently same as 1)
;; 16 specular texture
;; 17 height texture
;; 18 normal texture
(bind-type XTMMesh <VBO*,Texture*,float*,float*,float*,float*,float,float,i32,i64,VAO*,String*,i32,XTMBone*,i32,Texture*,Texture*,Texture*,Texture*> (printer? . #f))

(bind-func print:[void,XTMMesh*]*
  (lambda (mesh)
    (if (null? mesh)
        (println "<XTMMesh:NULL>")
        (let ((name (tref mesh 11))
              (texture (tref mesh 1))
              (diffuse:float* (tref mesh 2))
              (ambient:float* (tref mesh 3))
              (specular:float* (tref mesh 4))
              (emissive:float* (tref mesh 5))
              (shininess:float (tref mesh 6))
              (opacity:float (tref mesh 7))
              (verts:i64 (tref mesh 9))
              (bones:i32 (tref mesh 12))
              (diffuse_tex:Texture* (tref mesh 15))
              (specular_tex:Texture* (tref mesh 16))
              (height_tex:Texture* (tref mesh 17))
              (normal_tex:Texture* (tref mesh 18)))
          (printout "------ mesh ---------")
          (printout "\n name    : " name)
          (printout "\n texture : " texture)
          (printout "\n diffuse : ") (mprint diffuse 1 4)
          (printout " ambient : ") (mprint ambient 1 4)
          (printout " speculr : ") (mprint specular 1 4)
          (printout " emissiv : ") (mprint emissive 1 4)
          (printout " shine   : " shininess)
          (printout "\n opacity : " opacity)
          (printout "\n verts   : " verts)
          (printout "\n bones   : " bones)
          (printout "\n diff tex: " (if (null? diffuse_tex) #f #t))
          (printout "\n spec tex: " (if (null? specular_tex) #f #t))
          (printout "\n high tex: " (if (null? height_tex) #f #t))
          (printout "\n norm tex: " (if (null? normal_tex) #f #t))
          (println)
          void))))

(bind-func xtm_mesh_diffuse
  (lambda (mesh:XTMMesh* r g b a)
    (let ((c (tref mesh 2)))
      (pfill! c r g b a)
      void)))

(bind-func xtm_mesh_ambient
  (lambda (mesh:XTMMesh* r g b a)
    (let ((c (tref mesh 3)))
      (pfill! c r g b a)
      void)))

(bind-func xtm_mesh_specular
  (lambda (mesh:XTMMesh* r g b a)
    (let ((c (tref mesh 4)))
      (pfill! c r g b a)
      void)))

(bind-func xtm_mesh_emissive
  (lambda (mesh:XTMMesh* r g b a)
    (let ((c (tref mesh 5)))
      (pfill! c r g b a)
      void)))

(bind-func xtm_mesh_shininess
  (lambda (mesh:XTMMesh* value)
    (tset! mesh 6 value)))

(bind-func xtm_mesh_opacity
  (lambda (mesh:XTMMesh* value)
    (tset! mesh 7 value)))

;; 0 name
;; 1 transmat
;; 2 parent
;; 3 num_children
;; 4 chidren
;; 5 num_of_meshes
;; 6 meshes
(bind-type XTMModel <String*,float*,XTMModel*,i32,XTMModel*,i32,XTMMesh*> (printer? . #f))

(bind-func print_xtmmodel:[void,XTMModel*]*
  (lambda (model)
    (if (null? model)
        (println "<XTMModel:null>")
        (let ((i:i32 0)
              (name (tref model 0))
              (parent (tref model 2))
              (parent_name (if (null? parent) (Str "<null>") (tref parent 0)))
              (num_children (tref model 3))
              (children (tref model 4))
              (num_meshes (tref model 5))
              (meshes (tref model 6)))
          (printout "\n======= model =========")
          (printout "\nname    : " name)
          (printout "\nparent  : " parent_name)
          (printout "\nchildren: " num_children)
          (printout "\nmeshes  : " num_meshes)
          (println)
          (dotimes (i num_meshes)
            (println (pref-ptr meshes i))
            1)
          (dotimes (i num_children)
            (print_xtmmodel (pref-ptr children i))
            1)
          void))))

(bind-func print:[void,XTMModel*]*
  (lambda (model)
    (print_xtmmodel model)))


(bind-func xtm_model_child
  (lambda (model:XTMModel* idx:i32)
    (let ((num_children (tref model 3))
          (models (tref model 4)))
      (if (< idx num_children)
          (pref-ptr models idx)
          null))))

(bind-func xtm_model_mesh
  (lambda (model:XTMModel* idx:i32)
    (let ((num_meshes (tref model 5))
          (meshes (tref model 6)))
      (if (< idx num_meshes)
          (pref-ptr meshes idx)
          null))))


(bind-func set_instance_matrices
  (lambda (model:XTMModel* vbo:VBO*)
    (let ((i 0)
          (num_children (tref model 3))
          (children (tref model 4))
          (num_meshes (tref model 5))
          (meshes (tref model 6))
          (mesh:XTMMesh* null)
          (vao:VAO* null))
      (dotimes (i num_children)
        (set_instance_matrices (pref-ptr children i) vbo))
      (dotimes (i num_meshes)
        (set! mesh (pref-ptr meshes i))
        (set! vao (tref mesh 10))
        (set_attribute vao vbo 4 16 #t))
      void))) ;; true for instance attrib

;; matrix should be float* 5x5
(bind-func shader_set_grid_offsets
  (lambda (matrix:float* width:float height:float factor:float)
    (let ((xinc:float (/ factor width))
          (yinc:float (/ factor height))
          (i 0) (j 0))
      (dotimes (i 5) ;; columns
        (dotimes (j 5) ;; rows
          (pset! matrix (+ (* (+ (* i 5) j) 2) 0)
                 (+ (* -2.0 xinc)
                    (* (i32tof i) xinc)))
          (pset! matrix (+ (* (+ (* i 5) j) 2) 1)
                 (+ (* -2.0 xinc)
                    (* (i32tof i) yinc)))))
      void)))

;; matrix should be float* 5x5
(bind-func shader_setup_convolution_filter
  (lambda (matrix:float* shader:ShaderProgram* offset)
    (shader_set_grid_offsets matrix 1.0 1.0 offset) ;(* 2.0 (dtof (cos (* 2222.2 (i64tod (now)))))))
    (glUniform2fv (glGetUniformLocation (id shader) "texoffset") 25 matrix)
    (glUniform1i (glGetUniformLocation (id shader) "diffuseTexture") 1)))

(bind-func shader_update_camera
  (lambda (shader:ShaderProgram* position target)
    (let ((direction:float* (salloc 8))
          (tmp:float* (pref-ptr direction 4)))
      (vvsub position target 3 tmp)
      (vnormalise tmp 3 direction)
      (pset! direction 3 0.0)
      (glUniform4fv (glGetUniformLocation (id shader) "CameraPos") 1 position)
      (glUniform4fv (glGetUniformLocation (id shader) "CameraDir") 1 direction)
      void)))

(bind-func shader_update_light
  (lambda (shader:ShaderProgram* position target angle power:float ambient diffuse specular)
                                        ;(vprint position 4)
                                        ;(vprint target 4)
    (glUniform1f (glGetUniformLocation (id shader) "ConstantAttenuation") 1.0)
    (glUniform1f (glGetUniformLocation (id shader) "LinearAttenuation") 0.0)
    (glUniform1f (glGetUniformLocation (id shader) "QuadraticAttenuation") 0.0)
    (glUniform1f (glGetUniformLocation (id shader) "SpotExponent") power)
    (glUniform1f (glGetUniformLocation (id shader) "SpotAngle") (- 1.0 (/ angle 180.0)))
    (glUniform4fv (glGetUniformLocation (id shader) "LightPos") 1 position)
    (glUniform4fv (glGetUniformLocation (id shader) "LightAmbient") 1 ambient)
    (glUniform4fv (glGetUniformLocation (id shader) "LightSpecular") 1 specular)
    (glUniform4fv (glGetUniformLocation (id shader) "LightDiffuse") 1 diffuse)
    (let ((direction:float* (salloc 4))
          (tmp:float* (salloc 4)))
      (vvsub target position 3 tmp)
      (vnormalise tmp 3 direction)
      (pset! direction 3 0.0)
      (glUniform4fv (glGetUniformLocation (id shader) "SpotDir") 1 direction))
    void))

(bind-func shader_update_lights
  (let ((i:i32 0)
        (ca:float* (alloc 5)) ;; contant attenuation
        (la:float* (alloc 5)) ;; linear attenuation
        (qa:float* (alloc 5)) ;; quadratic attenuation
        (sa:float* (alloc 5)) ;; spot angle
        (dir:float* (alloc (* 5 4))) ;; spot dir
        (tmp:float* (alloc (* 5 4))))
    (dotimes (i 5)
      (pset! ca i 1.0) (pset! la i 0.0) (pset! qa i 0.0))
    (lambda (shader:ShaderProgram* numlights:i32 position target angle:float* power ambient diffuse specular)
      (if (> numlights 5) (set! numlights 5))
      (dotimes (i numlights) (pset! sa i (- 1.0 (/ (pref angle i) 180.0))))
      (glUniform1i (glGetUniformLocation (id shader) "numLights") numlights)
      (glUniform1fv (glGetUniformLocation (id shader) "ConstantAttenuation") numlights ca)
      (glUniform1fv (glGetUniformLocation (id shader) "LinearAttenuation") numlights la)
      (glUniform1fv (glGetUniformLocation (id shader) "QuadraticAttenuation") numlights qa)
      (glUniform1fv (glGetUniformLocation (id shader) "SpotExponent") numlights power)
      (glUniform1fv (glGetUniformLocation (id shader) "SpotAngle") numlights sa)
      (glUniform4fv (glGetUniformLocation (id shader) "LightPos") numlights position)
      (glUniform4fv (glGetUniformLocation (id shader) "LightAmbient") numlights ambient)
      (glUniform4fv (glGetUniformLocation (id shader) "LightSpecular") numlights specular)
      (glUniform4fv (glGetUniformLocation (id shader) "LightDiffuse") numlights diffuse)
      (dotimes (i numlights)
        (vvsub (pref-ptr target (* i 4))
              (pref-ptr position (* i 4))
              3
              (pref-ptr tmp (* i 4)))
        (vnormalise (pref-ptr tmp (* i 4))
               3
               (pref-ptr dir (* i 4)))
        (pset! (pref-ptr dir (* i 4)) 3 0.0))
      (glUniform4fv (glGetUniformLocation (id shader) "SpotDir") numlights dir)
      void)))

;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices
  (lambda (shader:ShaderProgram* m v p)
    (let ((mv (salloc 48))
          (mvp (pref-ptr mv 16))
          (mn (pref-ptr mv 32)))
      ;;(mmul m 4 4 v 4 4 mv) ;; final mv set
      (mmmul m v mv) ;; final mv set
      (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
      (minverse mn 4 mvp) ;; using mvp as a temporary
      (mat4_to_mat3 mvp mn)  ;; final mn set
      ;;(mmul mv 4 4 p 4 4 mvp) ;; final mvp set
      (mmmul mv p mvp)
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelMatrix") 1 GL_FALSE m)
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "ViewMatrix") 1 GL_FALSE v)
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "ProjectionMatrix") 1 GL_FALSE p)
      (glUniformMatrix3fv (glGetUniformLocation (id shader) "NormalMatrix") 1 GL_FALSE mn)
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewMatrix") 1 GL_FALSE mv)
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
      void)))

;; uvw should be a 3x3
(bind-func shader_update_uvwmatrix
  (lambda (shader:ShaderProgram* uvmat:float*)
    (glUniformMatrix4fv (glGetUniformLocation (id shader) "UVMatrix") 1 GL_FALSE uvmat)
    void))

;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices_lv
  (let ((bias:float* (alloc 16)))
    (pfill! bias
            0.5 0.0 0.0 0.0
            0.0 0.5 0.0 0.0
            0.0 0.0 0.5 0.0
            0.5 0.5 0.5 1.0)
    (lambda (shader:ShaderProgram* m:float* v p:float* lv:float*) ;; lv light view
      (let ((mlv:float* (salloc 16))
            (mlvp:float* (salloc 16))
            (mlvpb:float* (salloc 16)))
        (mmmul m lv mlv)
        (mmmul mlv p mlvp)
        (mmmul mlvp bias mlvpb)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "LightModelViewProjectionMatrix") 1 GL_FALSE mlvpb))
      (let ((mv (salloc 48))
            (mvp (pref-ptr mv 16))
            (mn (pref-ptr mv 32)))
        ;;(mmul m 4 4 v 4 4 mv) ;; final mv set
        (mmmul m v mv) ;; final mv set
        (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
        (minverse mn 4 mvp) ;; using mvp as a temporary
        (mat4_to_mat3 mvp mn)  ;; final mn set
        ;;(mmul mv 4 4 p 4 4 mvp) ;; final mvp set
        (mmmul mv p mvp) ;; final mvp set
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelMatrix") 1 GL_FALSE m)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ViewMatrix") 1 GL_FALSE v)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ProjectionMatrix") 1 GL_FALSE p)
        (glUniformMatrix3fv (glGetUniformLocation (id shader) "NormalMatrix") 1 GL_FALSE mn)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewMatrix") 1 GL_FALSE mv)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
        void))))

;; when working with OpenGL
;; extempore's mmul is pre mutipled (not post as in GLSL)
;; so the same matrix mul is post in GLSL and pre in XTM (i.e. here!)
(bind-func shader_update_matrices_lvs
  (let ((i:i32 0)
        (mlvpb:float* (alloc (* 10 16)))
        (bias:float* (alloc 16)))
    (pfill! bias
            0.5 0.0 0.0 0.0
            0.0 0.5 0.0 0.0
            0.0 0.0 0.5 0.0
            0.5 0.5 0.5 1.0)
    (lambda (shader:ShaderProgram* m:float* v p:float* lights:i32 lv:float*) ;; lv is lights
      ;; view
      (dotimes (i lights)
        (let ((mlv:float* (salloc 16))
              (mlvp:float* (salloc 16)))
          (mmmul m (pref-ptr lv (* i 16)) mlv)
          (mmmul mlv p mlvp)
          (mmmul mlvp bias (pref-ptr mlvpb (* i 16)))))
      (glUniformMatrix4fv (glGetUniformLocation (id shader) "LightModelViewProjectionMatrix")
                          lights GL_FALSE mlvpb)
      (let ((mv (salloc 48))
            (mvp (pref-ptr mv 16))
            (mn (pref-ptr mv 32)))
        (mmmul m v mv) ;; final mv set
        (mtrans mv 4 4 mn) ;; using mn as a temporary here!!
        (minverse mn 4 mvp) ;; using mvp as a temporary
        (mat4_to_mat3 mvp mn)  ;; final mn set
        (mmmul mv p mvp) ;; final mvp set
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelMatrix") 1 GL_FALSE m)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ViewMatrix") 1 GL_FALSE v)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ProjectionMatrix") 1 GL_FALSE p)
        (glUniformMatrix3fv (glGetUniformLocation (id shader) "NormalMatrix") 1 GL_FALSE mn)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewMatrix") 1 GL_FALSE mv)
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "ModelViewProjectionMatrix") 1 GL_FALSE mvp)
        void))))

(bind-val XTM_EMIT_VCOLOUR i32 0)

(bind-func xtm_emit_vcolour
  (lambda (x)
    (set! XTM_EMIT_VCOLOUR x)
    void))

(bind-func shader_update_material
  (lambda (shader:ShaderProgram* ambient:float* diffuse:float* emissive:float* specular:float* shininess:float)
    (glUniform4fv (glGetUniformLocation (id shader) "MaterialAmbient") 1 ambient)
    (glUniform4fv (glGetUniformLocation (id shader) "MaterialDiffuse") 1 diffuse)
    (glUniform4fv (glGetUniformLocation (id shader) "MaterialSpecular") 1 specular)
    (glUniform4fv (glGetUniformLocation (id shader) "MaterialEmissive") 1 emissive)
    (glUniform1f (glGetUniformLocation (id shader) "MaterialShininess") shininess)
    (glUniform1i (glGetUniformLocation (id shader) "emitVColour") XTM_EMIT_VCOLOUR)
    void))


(bind-func array_4_ptr_copy
  (lambda (a:|4,float| data:float*)
    (pset! data 0 (aref a 0))
    (pset! data 1 (aref a 1))
    (pset! data 2 (aref a 2))
    (pset! data 3 (aref a 3))
    void))

(bind-func shader_update_material
  (let ((data:float* (alloc (* 4 4))) (i:i32 0))
    (lambda (shader:ShaderProgram* ambient:|4,float| diffuse:|4,float| emissive:|4,float| specular:|4,float| shininess:float)
      (array_4_ptr_copy ambient (pref-ptr data 0))
      (array_4_ptr_copy diffuse (pref-ptr data 4))
      (array_4_ptr_copy emissive (pref-ptr data 8))
      (array_4_ptr_copy specular (pref-ptr data 12))
      (glUniform4fv (glGetUniformLocation (id shader) "MaterialAmbient") 1 (pref-ptr data 0))
      (glUniform4fv (glGetUniformLocation (id shader) "MaterialDiffuse") 1 (pref-ptr data 4))
      (glUniform4fv (glGetUniformLocation (id shader) "MaterialEmissive") 1 (pref-ptr data 8))
      (glUniform4fv (glGetUniformLocation (id shader) "MaterialSpecular") 1 (pref-ptr data 12))
      (glUniform1f (glGetUniformLocation (id shader) "MaterialShininess") shininess)
      (glUniform1i (glGetUniformLocation (id shader) "emitVColour") XTM_EMIT_VCOLOUR)
      void)))

(bind-func shader_update_material
  (lambda (shader:ShaderProgram* diffuse:|4,float| shininess)
    (shader_update_material:[void,ShaderProgram*,|4,float|,|4,float|,|4,float|,|4,float|,float]*
     shader
     (array 0.0 0.0 0.0 1.0)
     diffuse
     (array 0.0 0.0 0.0 1.0)
     (array 0.0 0.0 0.0 1.0)
     shininess)))

(bind-func shader_update_bones
  (let ((bonesdat:float* (alloc (* 16 4 20))) ;; 16 (4x4 array) * 20 * 4 (bytes per float)
        (i:i32 0))
    ;; default to id matrix
    (dotimes (i 20) (fill_identity_matrix (pref-ptr bonesdat (* 16 i))))
    (lambda (shader:ShaderProgram* mesh:XTMMesh*)
      (let ((num_bones (tref mesh 12))
            (bones (tref mesh 13))
            (bone:XTMBone* null)
            (mymat:float* (alloc 16))
            (transmat:float* null))
        (fill_identity_matrix mymat)
        (translate_matrix mymat 2.0 2.0 2.0)
        ;; (dotimes (i 20) (fill_identity_matrix (pref-ptr bonesdat (* 16 i))))
        (dotimes (i num_bones)
          (set! bone (pref-ptr bones i))
          (set! transmat (tref bone 2))
          (memcpy (cast mymat i8*) (cast transmat i8*) (* 16 4))
          (if (= i -1)
              (begin
                (rotate_matrix mymat 50.0 0.0 1.0 0.0)
                (memcpy (cast (pref-ptr bonesdat (* 16 i)) i8*) (cast mymat i8*) (* 16 4)))
              (memcpy (cast (pref-ptr bonesdat (* 16 i)) i8*) (cast transmat i8*) (* 16 4))))
        ;; update 20 bones
        (glUniformMatrix4fv (glGetUniformLocation (id shader) "Bone") 20 GL_FALSE bonesdat)
        (gl_print_error "Error updating bones")
        void))))

(bind-val PROJECTION_TEXTURE_WEIGHT float 0.5)

(bind-func shader_update_projection_texture
  (lambda (shader:ShaderProgram* textureUnit texture:Texture*)
    (if (or (null? texture)
            (< (id texture) 1))
        (begin
          (glUniform1i (glGetUniformLocation (id shader) "isProjectionTextured") 0)
          (glUniform1i (glGetUniformLocation (id shader) "projectionTexture") textureUnit)
          (glUniform1f (glGetUniformLocation (id shader) "projectionTextureWeight") PROJECTION_TEXTURE_WEIGHT))
        (begin
          (bind texture textureUnit)
          (glUniform1f (glGetUniformLocation (id shader) "projectionTextureWeight") PROJECTION_TEXTURE_WEIGHT)
          (glUniform1i (glGetUniformLocation (id shader) "isProjectionTextured") 1)
          (glUniform1i (glGetUniformLocation (id shader) "projectionTexture") textureUnit)))
    (gl_print_error "Error setting up projection texture")
    void))

(bind-val ENV_MAP_WEIGHT float 1.0)

;; where texture is expected to be a CUBE texture
(bind-func shader_update_envmap
  (lambda (shader:ShaderProgram* textureUnit texture:Texture*)
    (if (or (null? texture) (< (id texture) 1))
        (begin
          (glUniform1i (glGetUniformLocation (id shader) "isEnvMapped") 0)
          (glUniform1f (glGetUniformLocation (id shader) "envMapWeight") ENV_MAP_WEIGHT)
          (glUniform1i (glGetUniformLocation (id shader) "envMap") textureUnit)
          void)
        (begin
          (bind_cube texture textureUnit)
          (glUniform1i (glGetUniformLocation (id shader) "isEnvMapped") 1)
          (glUniform1f (glGetUniformLocation (id shader) "envMapWeight") ENV_MAP_WEIGHT)
          (glUniform1i (glGetUniformLocation (id shader) "envMap") textureUnit)
          void))
    (gl_print_error "Error setting up envmap!")
    void))

(bind-func shader_prepare_draw
  (lambda (shader:ShaderProgram* tex:Texture* instances:i32 is_points:i1)
    (glUniform1i (glGetUniformLocation (id shader) "isPoints") (if is_points 1 0))
    (glUniform1i (glGetUniformLocation (id shader) "isTextured") (if (or (null? tex) is_points) 0 1))
    (glUniform1i (glGetUniformLocation (id shader) "diffuseTexture") 1)
    (glUniform1i (glGetUniformLocation (id shader) "instances") instances)
    (glUniform1i (glGetUniformLocation (id shader) "emitVColour") XTM_EMIT_VCOLOUR)
    void))

(bind-func shader_prepare_draw
  (lambda (shader:ShaderProgram* tex:Texture*)
    (shader_prepare_draw:[void,ShaderProgram*,Texture*,i32,i1]* shader tex 0 #f)
    void))

(bind-func shader_prepare_draw
  (lambda (shader:ShaderProgram* tex:Texture* pointTex:i1)
    (shader_prepare_draw:[void,ShaderProgram*,Texture*,i32,i1]* shader tex 0 pointTex)
    void))

(bind-func shader_prepare_draw
  (lambda (shader:ShaderProgram* instances:i32)
    (shader_prepare_draw:[void,ShaderProgram*,Texture*,i32,i1]* shader null instances #f)
    void))

(bind-func shader_prepare_draw
  (lambda (shader:ShaderProgram*)
    (shader_prepare_draw:[void,ShaderProgram*,Texture*,i32,i1]* shader null 0 #f)
    void))

(bind-func xtm_build_mesh_vbo
  (lambda (vao:VAO* verts:float* num_verts:i64)
    (let ((i:i64 0)
          (vert:float* null)
          (n1:float* (salloc 3))
          (norm:float* (salloc 3))
          (vbostride:i64 14) ;; 4d+3d+3d+4d
          (vbodata:float* (zalloc (* num_verts vbostride))))
      (dotimes (i num_verts)
        (set! vert (pref-ptr verts (* i 3)))
        (if (= (% i 3) 0)
            (if (> i (- num_verts 2))
                (begin (pfill! norm 0.0 1.0 0.0) 1)
                (begin
                  (vvcross vert (pref-ptr vert 3) n1)
                  (vsmul n1 -1.0 3 norm)
                  1))
            1)
        (pfill! (pref-ptr vbodata (* i vbostride))
                (pref vert 0) ;; x
                (pref vert 1) ;; y
                (pref vert 2) ;; z
                1.0) ;; position data needs w==1
        ;; auto gen normal
        (pfill! (pref-ptr vbodata (+ 4 (* i vbostride)))
                (pref norm 0)
                (pref norm 1)
                (pref norm 2))
        ;; auto gen texcoords
        (if (= (% i 3) 0)
            (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 0.0 0.0 0.0)
            (if (= (% i 3) 1)
                (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 0.5 1.0 0.0)
                (pfill! (pref-ptr vbodata (+ 7 (* i vbostride))) 1.0 0.0 0.0)))
        ;; default color is white
        (pfill! (pref-ptr vbodata (+ 10 (* i vbostride))) 1.0 1.0 1.0 1.0))
        ;; (pfill! (pref-ptr vbodata (+ 10 (* i vbostride))) 0.2 1.0 0.2 1.0))
      (let ((vbo (VBO vbodata (* num_verts vbostride) GL_STATIC_DRAW num_verts vbostride)))
        ;; (glBindBuffer GL_ARRAY_BUFFER 0)
        (set_attribute vao vbo 0 4 (i64toi32 vbostride) 0)
        (set_attribute vao vbo 1 3 (i64toi32 vbostride) 4)
        (set_attribute vao vbo 2 3 (i64toi32 vbostride) 7)
        (set_attribute vao vbo 3 4 (i64toi32 vbostride) 10)
        vbo))))

(bind-func xtm_make_model
  (lambda (name:String* verts:float* num_verts:i64 r g b)
    (let ((mesh:XTMMesh* (alloc))
          (node:XTMModel* (alloc))
          (transmat:float* (alloc 16))
          (vbostride:i32 14) ;; 4d+3d+3d+4d
          (vbodata:float* null)
          (shininess:float 1.0)
          (opacity:float 1.0)
          (diffuse:float* (alloc 4))
          (ambient:float* (alloc 4))
          (specular:float* (alloc 4))
          (emissive:float* (alloc 4))
          (vao (VAO))
          (vbo:VBO* (xtm_build_mesh_vbo vao verts num_verts)))
      (pfill! ambient 0.0 0.0 0.0 1.0)
      (pfill! diffuse r   g   b   1.0)
      (pfill! specular 1.0 1.0 1.0 1.0)
      (pfill! emissive 0.0 0.0 0.0 1.0)
      ;; null is for no texture
      (tfill! mesh vbo null diffuse ambient specular emissive shininess opacity GL_TRIANGLES num_verts vao name)
      (fill_identity_matrix transmat)
      (tfill! node name transmat null 0 null 1 mesh)
      node)))

(bind-type xtm_camera <float*,float*,float*>)

(bind-func xtm_get_camera
  (let ((camera:xtm_camera* (zalloc))
        (p:float* (zalloc 4))
        (t:float* (zalloc 4))
        (u:float* (zalloc 4)))
    (pfill! p 0.0 0.0 10.0 1.0)
    (pfill! t 0.0 0.0 0.0 1.0)
    (pfill! u 0.0 1.0 0.0 0.0)
    (tfill! camera p t u)
    (lambda ()
      camera)))

(bind-func xtm_camera_pos
  (lambda (x y z)
    (pfill! (tref (xtm_get_camera) 0) x y z 1.0)
    void))

(bind-func xtm_camera_tgt
  (lambda (x y z)
    (pfill! (tref (xtm_get_camera) 1) x y z 1.0)
    void))

(bind-func xtm_camera_up
  (lambda (x y z)
    (pfill! (tref (xtm_get_camera) 2) x y z 0.0)
    void))

(bind-func xtm_camera_view
  (let ((camera:xtm_camera* null))
    (lambda (view:float*)
      (set! camera (xtm_get_camera))
      (fill_view_matrix view (tref camera 0) (tref camera 1) (tref camera 2))
      void)))

;; same as camera view but with position at origin
(bind-func xtm_camera_view_centred
  (let ((camera:xtm_camera* null)
        (centre:float* (alloc 3)))
    (pfill! centre 0.0 0.0 0.0)
    (lambda (view:float*)
      (set! camera (xtm_get_camera))
      (fill_view_matrix view centre (tref camera 1) (tref camera 2))
      void)))

(bind-func xtm_update_camera
  (lambda (shader)
    (shader_update_camera shader (tref (xtm_get_camera) 0) (tref (xtm_get_camera) 1))
    void))

;; 0 position
;; 1 target
;; 2 up
;; 3 ambient
;; 4 diffuse
;; 5 specular
;; 6 power
;; 7 angle
;; 8 matrices
;; 9 numlights

;; (bind-type xtm_lights <|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|40,float|,|10,float|,|10,float|>)
(bind-type xtm_lights <float*,float*,float*,float*,float*,float*,float*,float*,float*,i32>)

(bind-func xtm_get_lights
  (let ((i 0)
        (lights:xtm_lights* (zalloc))
        (p:float* (zalloc (* 10 4)))
        (t:float* (zalloc (* 10 4)))
        (u:float* (zalloc (* 10 4)))
        (a:float* (zalloc (* 10 4)))
        (d:float* (zalloc (* 10 4)))
        (s:float* (zalloc (* 10 4)))
        (pows:float* (zalloc 10))
        (angs:float* (zalloc 10))
        (matrices:float* (zalloc (* 10 16))))
    (dotimes (i 10)
      (pfill! (pref-ptr d (* i 4)) 1.0 0.8 0.5 1.0)
      (pfill! (pref-ptr s (* i 4)) 1.0 1.0 1.0 1.0)
      (pfill! (pref-ptr a (* i 4)) 1.0 0.8 0.5 1.0)
      (pfill! (pref-ptr p (* i 4)) 1.0 10.0 10.0 1.0)
      (pfill! (pref-ptr t (* i 4)) 0.0 0.0 0.0 1.0) ;;looking at origin
      (pfill! (pref-ptr u (* i 4)) 0.0 1.0 0.0 0.0)
      (pfill! (pref-ptr angs i) 60.0)
      (pfill! (pref-ptr pows i) 30.0)
      (fill_view_matrix (pref-ptr matrices (* i 16))
                        (pref-ptr p (* i 4)) ;; position
                        (pref-ptr t (* i 4)) ;; target
                        (pref-ptr u (* i 4)))) ;; up
    (tfill! lights p t u a d s pows angs matrices 0)
    (lambda ()
      lights)))

(bind-func xtm_light_pos
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((a:float* (pref-ptr (tref lights 0) (* light 4))))
            (pfill! a x y z 1.0)
            void)))))

(bind-func xtm_light_tgt
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((a:float* (pref-ptr (tref lights 1) (* light 4))))
            (pfill! a x y z 1.0)
            void)))))

(bind-func xtm_light_up
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 x y z)
      (set! lights (xtm_get_lights))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((a:float* (pref-ptr (tref lights 2) (* light 4))))
            (pfill! a x y z 0.0)
            void)))))

(bind-func xtm_light_ambient
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((arr:float* (pref-ptr (tref lights 3) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_diffuse
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((arr:float* (pref-ptr (tref lights 4) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_specular
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 r g b a)
      (set! lights (xtm_get_lights))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (let ((arr:float* (pref-ptr (tref lights 5) (* light 4))))
            (pfill! arr r g b a)
            void)))))

(bind-func xtm_light_power
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 power)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (begin (pset! (tref lights 6) light power) void)))))

(bind-func xtm_light_angle
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 angle)
      (set! lights (xtm_get_lights))
      (if (> light (tref lights 9)) (tset! lights 9 light))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (begin (pset! (tref lights 7) light angle) void)))))

(bind-func xtm_light_view
  (let ((lights:xtm_lights* null))
    (lambda (light:i32 view:float*)
      (set! lights (xtm_get_lights))
      (set! light (- light 1))
      (if (or (< light 0) (> light 9))
          (begin (printf "No such light!\n") void)
          (begin (fill_view_matrix (pref-ptr (tref lights 8) (* light 16))
                                   (pref-ptr (tref lights 0) (* light 4)) ;; position
                                   (pref-ptr (tref lights 1) (* light 4)) ;; target
                                   (pref-ptr (tref lights 2) (* light 4))) ;; up
                 (if (not (null? view))
                     (mcopy (pref-ptr (tref lights 8) (* light 16)) 4 4 view))
                 void)))))

(bind-func xtm_update_lights
  (lambda (shader:ShaderProgram*)
    (let ((lights (xtm_get_lights)))
      (shader_update_lights shader (tref lights 9)
                            (tref lights 0) (tref lights 1)
                            (tref lights 7) (tref lights 6)
                            (tref lights 3) (tref lights 4)
                            (tref lights 5)))))

(bind-func xtm_update_matrices
  (lambda (shader:ShaderProgram* model:float* view:float* projection:float*)
    (let ((lights (xtm_get_lights)))
      (shader_update_matrices_lvs shader model view projection (tref lights 9) (tref lights 8)))))

;; draw vao
;; where vao is expected to have
;; index 0: vectices - MANDATORY
;; index 1: normals - optional
;; index 2: uvw's - optional
;; index 3: colours - optional
(bind-func xtm_draw_vao
  (lambda (vao:VAO* shader m v p type update_data:i1 sz tex:Texture* blend:i1)
    (xtm_update_matrices shader m v p)
    (let ((vbo (get_vbo vao 0))
          (elmts (i64toi32 (elements vbo))))
      ;; (println vbo)
      (if update_data (update vbo))
      (if (= type GL_POINTS)
          (glPointSize sz)
          (glLineWidth 1.0))
      (if blend
          (begin (glEnable GL_BLEND)
                 (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)))
                 ;; (glBlendFunc GL_SRC_COLOR GL_ONE_MINUS_SRC_COLOR)))
      (if (not (null? tex)) (bind tex 1:i32))
      (shader_prepare_draw shader tex 0 (if (= type GL_POINTS) #t #f))
      (draw vao type 0 elmts 0)
      (if (not (null? tex)) (unbind tex 1:i32))
      (if blend (glDisable GL_BLEND))
      void)))

(bind-func xtm_draw_vao
  (lambda (vao:VAO* shader m v p type update)
    (xtm_draw_vao:[void,VAO*,ShaderProgram*,float*,float*,float*,i32,i1,float,Texture*,i1]*
     vao shader m v p type update 1.0 null 0)))

(bind-func xtm_draw_mesh
  (let ((vert:i32 0)
        (instancesvbo:VBO* null)
        (norm:i32 1)
        (uvw:i32 2)
        (color:i32 3))
    (lambda (mesh:XTMMesh* shader:ShaderProgram* instances:i32 vbo:VBO*)
      (gl_print_error "Error BEFORE drawing XTMMesh!")
      ;; (println mesh)
      (let ((vao (tref mesh 10))
            (texture (tref mesh 1))
            (diffuse (tref mesh 2))
            (ambient (tref mesh 3))
            (specular (tref mesh 4))
            (emissive (tref mesh 5))
            (shininess (tref mesh 6))
            (facemode (tref mesh 8)))
        ;; (set! shininess (dtof 100.0))
        (if (not (null? ambient))
            (glUniform4fv (glGetUniformLocation (id shader) "MaterialAmbient") 1 ambient))
        (if (not (null? diffuse))
            (glUniform4fv (glGetUniformLocation (id shader) "MaterialDiffuse") 1 diffuse))
        (if (not (null? specular))
            (glUniform4fv (glGetUniformLocation (id shader) "MaterialSpecular") 1 specular))
        (if (not (null? specular))
            (glUniform4fv (glGetUniformLocation (id shader) "MaterialEmissive") 1 emissive))
        (glUniform1f (glGetUniformLocation (id shader) "MaterialShininess") shininess)
        (glUniform1i (glGetUniformLocation (id shader) "instances") instances)
        (glUniform1i (glGetUniformLocation (id shader) "emitVColour") XTM_EMIT_VCOLOUR)
        (glUniform1i (glGetUniformLocation (id shader) "isPoints") 0)
        (if (> (tref mesh 14) 0) ;; do we have any bones in our mesh!
            (begin
              (shader_update_bones shader mesh)))
        ;; (printf "texid %d\n" (id texture))
        ;; texture stuff
        (if (> (id texture) 0)
            (begin
              (bind texture 1)
              (glUniform1i (glGetUniformLocation (id shader) "isTextured") 1)
              (glUniform1i (glGetUniformLocation (id shader) "diffuseTexture") 1))
            (begin
              (glUniform1i (glGetUniformLocation (id shader) "isTextured") 0)))
        (gl_print_error "Error setting uniforms! in xtm_draw_mesh")
        ;;
        (set! instancesvbo (get_vbo vao 4))
        (if (and (> instances 0)
                 (<> (ptrtoi64 (cast instancesvbo i8*))
                     (ptrtoi64 (cast vbo i8*))))
            (begin
              (set_attribute vao vbo 4 16  36 0 #t)
              (set_attribute vao vbo 8 4   36 16 #t)
              (set_attribute vao vbo 9 16  36 20 #t)
              ))
        (gl_print_error "Error setting instance attrib in xtm_draw_mesh")
        ;; (println "instances" instances)
        (if (> instances 0)
            (draw vao facemode 0 (convert (tref mesh 9)) instances)
            (draw vao facemode 0 (convert (tref mesh 9))))
        ;; undo texture stuff
        (unbind texture 1)
        (gl_print_error "Error drawing XTMMesh!")
        void))))

(bind-func xtm_draw_mesh
  (lambda (mesh shader)
    (xtm_draw_mesh:[void,XTMMesh*,ShaderProgram*,i32,VBO*]* mesh shader 0 null)))

(bind-func xtm_draw_model
  (lambda (node:XTMModel* shader:ShaderProgram* model:float* view:float* projection:float* instances:i32 vbo:VBO*)
    (gl_print_error "Error before drawing XTMModel")
    (let ((i:i32 0)
          (lights (xtm_get_lights))
          (children (tref node 4))
          (meshes (tref node 6))
          (transmat:float* (tref node 1))
          (m2:float* (salloc 16))
          (m:float* (salloc 16)))
      ;; (println "instances:" instances)
      (if (null? transmat)
          (begin (memcpy (cast m i8*) (cast model i8*) (* 4 16)) 1)
          (begin
            (mtrans transmat 4 4 m2)
            (mmmul m2 model m)
            1))
      (xtm_update_matrices shader m view projection)
      ;; first draw meshes
      (dotimes (i (tref node 5))
        (xtm_draw_mesh (pref-ptr meshes i) shader instances vbo))
      (gl_print_error "Error drawing XTMMesh!")
      ;; then draw other children recursively
      (dotimes (i (tref node 3))
        (xtm_draw_model (pref-ptr children i) shader model view projection instances vbo))
      (gl_print_error "Error drawing XTMModel!")
      void)))

(bind-func xtm_draw_model
  (lambda (node:XTMModel* shader:ShaderProgram* model:float* view:float* projection:float*)
    (xtm_draw_model:[void,XTMModel*,ShaderProgram*,float*,float*,float*,i32,VBO*]* node shader model view projection 0 null)))

;; some globalvars to hold shader program names
(bind-val xtm_render_light_shader ShaderProgram*)
(bind-val xtm_render_simple_shader ShaderProgram*)
(bind-val xtm_render_simple_bone_shader ShaderProgram*)
(bind-val xtm_render_quad_shader ShaderProgram*)
(bind-val xtm_render_dof_shader ShaderProgram*)
(bind-val xtm_render_skybox_shader ShaderProgram*)
(bind-val xtm_render_x i32 0)
(bind-val xtm_render_y i32 0)
(bind-val xtm_render_w i32 1024)
(bind-val xtm_render_h i32 768)
(bind-val xtm_render_angle float 35.0)
(bind-val xtm_render_near float 0.1)
(bind-val xtm_render_far float 1000.0)

;; note that xtlang mmmul is pre-multiplied! (not post as GLSL)
(bind-func xtm_project
  (lambda (pt_in:float* pt_out:float* model view projection)
    (let ((x (pref pt_in 0))
          (y (pref pt_in 1))
          (z (pref pt_in 2))
          (vp_x (i32tof xtm_render_x)) ;; viewport x
          (vp_y (i32tof xtm_render_y)) ;; viewport y
          (vp_w (i32tof xtm_render_w))
          (vp_h (i32tof xtm_render_h))
          (vp_n xtm_render_near)
          (vp_f xtm_render_far)
          (mvp:float* (salloc 16))
          (tmp:float* (salloc 16))
          (vec:float* (salloc 4)))
      (mmmul model view tmp)
      (mmmul tmp projection mvp)
      (mmmul pt_in 1 4 mvp 4 4 vec)
      (if (<> (pref vec 3) 0.0)
          (vsmul vec (/ 1.0 (pref vec 3)) 4 pt_out)) ;; normalize W!
      (pset! pt_out 0 (* (+ 1.0 (pref pt_out 0)) 0.5 vp_w))
      (pset! pt_out 1 (* (+ 1.0 (pref pt_out 1)) 0.5 vp_h))
      (pset! pt_out 2 (+ (* (pref pt_out 2) (- vp_f vp_n)) vp_n))
      void)))

;; note that xtlang mmmul is pre-multiplied! (not post as GLSL)
(bind-func xtm_unproject
  (lambda (pt_in:float* pt_out:float* model view projection)
    (let ((x (pref pt_in 0))
          (y (pref pt_in 1))
          (z (pref pt_in 2))
          (vp_x (i32tof xtm_render_x)) ;; viewport x
          (vp_y (i32tof xtm_render_y)) ;; viewport y
          (vp_w (i32tof xtm_render_w))
          (vp_h (i32tof xtm_render_h))
          (tmp:float* (salloc 16))
          (tmp2:float* (salloc 16))
          (imvp:float* (salloc 16))
          (vec:float* (salloc 4))
          (out:float* (salloc 4)))
      (mmmul model view tmp)
      (mmmul tmp projection imvp)
      (invert_matrix imvp)
      (pset! vec 0 (- (* (/ x vp_w) 2.0) 1.0))
      (pset! vec 1 (- (* (/ y vp_h) 2.0) 1.0))
      (pset! vec 2 (- (* 2.0 z) 1.0))
      (pset! vec 3 1.0)
      (mmmul vec 1 4 imvp 4 4 out)
      (if (= (pref out 3) 0.0)
          void
          (begin
            (vsmul out (/ 1.0 (pref out 3)) 4 pt_out)  ;; make sure W is normalised!
            void)))))

(bind-func xtm_render_init_light_shader:[void,i8*,i8*]*
  (lambda (a1 a2)
    (set! xtm_render_light_shader (ShaderProgram (Str "Light-Shader") (Str a1) (Str a2)))
    (gl_print_error "Error initializing light shader")
    void))

(bind-func xtm_render_init_simple_shader
  (lambda (v:i8* f:i8*)
    (set! xtm_render_simple_shader (ShaderProgram (Str "Simple-Shader") (Str v) (Str f)))
    (gl_print_error "Error initializing simple shader")
    void))

(bind-func xtm_render_init_simple_bone_shader
  (lambda (v:i8* f:i8*)
    (set! xtm_render_simple_bone_shader (ShaderProgram (Str "Simple-Bone-Shader") (Str v) (Str f)))
    (gl_print_error "Error initializing simple bone shader")
    void))

(bind-func xtm_render_init_quad_shader
  (lambda (v:i8* f:i8*)
    (set! xtm_render_quad_shader (ShaderProgram (Str "QUAD-Shader") (Str v) (Str f)))
    (gl_print_error "Error initializing quad shader")
    void))

(bind-func xtm_render_init_dof_shader
  (lambda (v:i8* f:i8*)
    (set! xtm_render_dof_shader (ShaderProgram (Str "DOF-Shader") (Str v) (Str f)))
    (gl_print_error "Error initializing depth of field shader")
    void))

(bind-func xtm_render_init_skybox_shader
  (lambda (v:i8* f:i8*)
    (set! xtm_render_skybox_shader (ShaderProgram (Str "SkyBox-Shader") (Str v) (Str f)))
    (gl_print_error "Error initializing skybox shader")
    void))


(bind-val DRAW_QUAD_VAO VAO*)
(bind-val DRAW_QUAD_VBO VBO*)

(bind-func draw_quad
  (lambda (shader uvmat)
    (shader_update_uvwmatrix shader uvmat)
    (draw DRAW_QUAD_VAO GL_TRIANGLE_STRIP 0 4)
    (gl_print_error "Error drawing QUAD vao")
    void))

(bind-func init_draw_quad
  (lambda ()
    (let ((data:float* (alloc 28)))
      (pfill! data
              -1.0 -1.0 0. 1.   0. 0. 0.
              -1.0  1.0 0. 1.   0. 1. 0.
              1.0 -1.0 0. 1.   1. 0. 0.
              1.0  1.0 0. 1.   1. 1. 0.)
      (set! DRAW_QUAD_VAO (VAO))
      (set! DRAW_QUAD_VBO (VBO data 28))
      (set_attribute DRAW_QUAD_VAO DRAW_QUAD_VBO 0 4 7:i32 0)
      (set_attribute DRAW_QUAD_VAO DRAW_QUAD_VBO 2 3 7:i32 4)
      (gl_print_error "Error Initializing DRAW QUAD vao")
      void)))

;; update should be #f for static texture and #t for dynamic texture
(bind-func xtm_draw_tex
  (let ((idmat:float* (alloc 16)))
    (fill_identity_matrix idmat)
    (lambda (shader:ShaderProgram* tex:Texture* uvmat push_new_data:i1 alpha m v p)
      (start shader)
      (shader_update_matrices shader m v p)
      (if push_new_data (update tex))
      (bind tex 0)
      ;; (glEnable GL_BLEND) ;; alpha blending
      ;; (glBlendFunc GL_SRC_ALPHA GL_ONE_MINUS_SRC_ALPHA)
      (glUniform1i (glGetUniformLocation (id shader) "tex1") 0)
      (if (< alpha 0.0)
          (begin
            (glUniform1i (glGetUniformLocation (id shader) "override_alpha") 0))
          (begin
            (glUniform1i (glGetUniformLocation (id shader) "override_alpha") 1)
            (glUniform1f (glGetUniformLocation (id shader) "alpha") alpha)))
      (if (null? uvmat)
          (draw_quad shader idmat)
          (draw_quad shader uvmat))
      ;; (glDisable GL_BLEND)
      (unbind tex 0)
      (stop shader)
      void)))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* uvmat:float* update:i1 m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex uvmat update -1.0 m v p)
    void))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* uvmat:float* alpha:float m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex uvmat #f alpha m v p)
    void))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* uvmat:float* m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex uvmat #f -1.0 m v p)
    void))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* update:i1 m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex null update -1.0 m v p)
    void))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* alpha:float m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex null #f alpha m v p)
    void))

(bind-func xtm_draw_tex
  (lambda (shader:ShaderProgram* tex:Texture* m v p)
    (xtm_draw_tex:[void,ShaderProgram*,Texture*,float*,i1,float,float*,float*,float*]* shader tex null #f -1.0 m v p)
    void))

;; FBO named type taken from libs/external/gl.xtm

;; Framebuffer Object

;; fbo id          0
;; texture id      1
;; depth buffer id 2
;; width           3
;; height          4
;; (bind-type FBO <GLuint,GLuint,GLuint,GLsizei,GLsizei>)

;; creates an empty texture
;; suitable to back an FBO
;; (bind-func FBO_create_texture
;;   (lambda (width height)
;;     (let ((id:i32* (salloc))
;;           (tex:i32* (salloc)))
;;       (glGenRenderbuffers 1 id)
;;       (glBindRenderbuffer GL_RENDERBUFFER (pref id 0))
;;       (glRenderbufferStorage GL_RENDERBUFFER GL_RGBA8 width height)
;;       (glFramebufferRenderbuffer GL_FRAMEBUFFER GL_COLOR_ATTACHMENT0 GL_RENDERBUFFER (pref id 0))
;;       (glGenTextures 1 tex)
;;       (glBindTexture GL_TEXTURE_2D (pref tex 0))
;;       (glTexImage2D GL_TEXTURE_2D 0 GL_RGBA8 width height 0 GL_RGBA GL_UNSIGNED_BYTE null)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
;;       (glBindTexture GL_TEXTURE_2D 0)
;;       (pref tex 0))))

;; create fbo depth buffer
;; (bind-func FBO_create_depth_buffer
;;   (lambda (width height)
;;     (let ((id:i32* (salloc))
;;           (tex:i32* (salloc)))
;;       (glGenRenderbuffers 1 id)
;;       (glBindRenderbuffer GL_RENDERBUFFER (pref id 0))
;;       (glRenderbufferStorage GL_RENDERBUFFER GL_DEPTH_COMPONENT32 width height)
;;       ;; (glRenderbufferStorage GL_RENDERBUFFER GL_DEPTH_COMPONENT24 width height)
;;       (glFramebufferRenderbuffer GL_FRAMEBUFFER GL_DEPTH_ATTACHMENT GL_RENDERBUFFER (pref id 0))
;;       (glGenTextures 1 tex)
;;       (glBindTexture GL_TEXTURE_2D (pref tex 0))
;;       (glTexImage2D GL_TEXTURE_2D 0 GL_DEPTH_COMPONENT32 width height 0 GL_DEPTH_COMPONENT GL_FLOAT null)
;;       ;; (glTexImage2D GL_TEXTURE_2D 0 GL_DEPTH_COMPONENT24 width height 0 GL_DEPTH_COMPONENT GL_FLOAT null)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;       (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
;;       (glBindTexture GL_TEXTURE_2D 0)
;;       (pref tex 0))))

;; create and return a frame buffer struct (FBO)
;; if _texid is greater than 0 then use existing _texid
;; (bind-func FBO_create
;;   (lambda (width:i32 height:i32 _texid:i32 _depthid:i32)
;;     (let ((texid:i32 0)
;;           (depthid:i32 0)
;;           (fboid:i32* (salloc))
;;           (fbo:FBO* (halloc))) ;; heap alloc
;;       (glGenFramebuffers 1 fboid)
;;       ;; bind the fbo
;;       (glBindFramebuffer GL_FRAMEBUFFER (pref fboid 0))
;;       (if (> _texid 0) (set! texid _texid))
;;       (if (> _depthid 0) (set! texid _depthid))
;;       (set! texid (FBO_create_texture width height))
;;       (set! depthid (FBO_create_depth_buffer width height))
;;       ;; Attach the texture texid to the color buffer of our fbo
;;       (glFramebufferTexture2D GL_FRAMEBUFFER GL_COLOR_ATTACHMENT0 GL_TEXTURE_2D texid 0)
;;       ;; Attach the texture depthid to the depth buffer of our fbo
;;       (glFramebufferTexture2D GL_FRAMEBUFFER GL_DEPTH_ATTACHMENT GL_TEXTURE_2D depthid 0)
;;       (tfill! fbo (pref fboid 0) texid depthid width height)
;;       (let ((status:i32 (glCheckFramebufferStatus GL_FRAMEBUFFER))
;;             (err:i32 (glGetError)))
;;         (if (<> status GL_FRAMEBUFFER_COMPLETE)
;;             (if (<> err GL_NO_ERROR)
;;                 (begin (printf "GL ERR: FRAMEBUFFER err: %d\n" err)
;;                        (set! fbo (cast null FBO*))
;;                        1)
;;                 (begin
;;                   (printf "Possible framebuf error?: %d\n" err)
;;                   1))))
;;       (glClearColor 0.0 1.0 0.0 1.0)
;;       (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
;;       ;; unbind the frame buffer
;;       (glBindFramebuffer GL_FRAMEBUFFER 0)
;;       ;; return the extfbo struct
;;       fbo)))

;; fp represents the focal point
;; as a distance from the current camera location (in meters)
;;
;; dof is the depth of field 1.1 is very shallow 1.5 is quite deep
;;
;; (bind-func xtm_dof_fx
;;   (let ((show_depth:i32 1)
;;         (near 0.1)
;;         (far 5.0)
;;         (dof 1.01)
;;         (blur 2.0))
;;     (lambda (fbo:FBO* fp model view projection)
;;       (let ((shader xtm_render_dof_shader)
;;             (framebufsize:float* (alloc 2)))
;;         (set! fp 4.0) ;(+ 10.0:f (* 10.0 (cos (* 0.00001 (i64tof (now)))))))
;;         (glDisable GL_DEPTH_TEST)
;;         (start shader)
;;         ;; (glUseProgram (id shader))
;;         (shader_update_matrices shader model view projection)
;;         ;; (bind fbo)
;;         ;; (bind (depth_tex fbo) #t 0)
;;         ;; (glActiveTexture GL_TEXTURE0)
;;         ;; (glBindTexture GL_TEXTURE_2D (id (tref fbo 2)))
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)
;;         ;; (glActiveTexture GL_TEXTURE2)
;;         ;; (glBindTexture GL_TEXTURE_2D (id (tref fbo 1)))
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_S GL_CLAMP_TO_EDGE)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_WRAP_T GL_CLAMP_TO_EDGE)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MAG_FILTER GL_LINEAR)
;;         ;; (glTexParameteri GL_TEXTURE_2D GL_TEXTURE_MIN_FILTER GL_LINEAR)

;;         (bind (depth_tex fbo) #f 0)
;;         (glUniform1i (glGetUniformLocation (id shader) "dBuf") 0)
;;         (bind (colour_tex fbo) #f 2)
;;         (glUniform1i (glGetUniformLocation (id shader) "cBuf") 2)

;;         (glUniform1f (glGetUniformLocation (id shader) "blur") blur)
;;         (glUniform1f (glGetUniformLocation (id shader) "dof") dof)
;;         ;; ;; (println xtm_render_near xtm_render_far)
;;         (if (> near -0.01)
;;             (glUniform1f (glGetUniformLocation (id shader) "near") near)
;;             (glUniform1f (glGetUniformLocation (id shader) "near") xtm_render_near))
;;         (if (> far 0.0)
;;             (glUniform1f (glGetUniformLocation (id shader) "far") far)
;;             (glUniform1f (glGetUniformLocation (id shader) "far") xtm_render_far))
;;         (set! fp (/ fp (if (> far 0.0) far xtm_render_far)))
;;         (glUniform1f (glGetUniformLocation (id shader) "fp") fp)
;;         (pfill! framebufsize (i32tof xtm_render_w) (i32tof xtm_render_h))
;;         (glUniform2fv (glGetUniformLocation (id shader) "frameBufSize") 1 framebufsize)
;;         (glUniform1i (glGetUniformLocation (id shader) "show_depth") show_depth)
;;         (draw_quad) ;; 0.0 0.0 1.0 1.0 0.0 1.0 1.0)
;;         ;; (glActiveTexture GL_TEXTURE0)
;;         ;; (glBindTexture GL_TEXTURE_2D 0)
;;         ;; (glActiveTexture GL_TEXTURE2)
;;         ;; (glBindTexture GL_TEXTURE_2D 0)
;;         ;;(unbind fbo)
;;         (unbind (colour_tex fbo) 0)
;;         (unbind (depth_tex fbo) 2)
;;         (stop shader)
;;         void))))


(bind-val XTM_BACKGROUND_COLOUR /4,float/)

;;;;;;;;;;;;;
;;
;; SKY MAP
;;
;;;;;;;;;;;;;

(bind-val SKY_BOX_MODEL XTMModel*)
(bind-val SKY_BOX_TEXTURE Texture*)
(bind-val SKY_BOX i1 #f)
(bind-val SKY_BOX_SCALE float 500.0)

(bind-func xtm_skybox_init
  (lambda (model flipped:i1 front:String* back:String* top:String* bottom:String* left:String* right:String*)
    (set! SKY_BOX_MODEL model)
    (set! SKY_BOX_TEXTURE (Texture))
    (load_cube_data SKY_BOX_TEXTURE (i1toi32 flipped) front back top bottom left right)
    (update_cube SKY_BOX_TEXTURE)
    ;; (bind_cube SKY_BOX_TEXTURE #t 0) ;; send data to card
    ;; (unbind_cube SKY_BOX_TEXTURE 0)
    (set! SKY_BOX #t)
    void))

(bind-func xtm_skybox_fx
  (lambda (fbo:FBO* model:float* view:float* projection:float*)
    (let ((shader xtm_render_skybox_shader)
          (camera_pos:float* (tref (xtm_get_camera) 0)))
      ;; (glDepthMask GL_FALSE)
      (bind fbo)
      (start shader)
      (fill_identity_matrix model)
      (fill_pos_scale_matrix model
       (pref camera_pos 0) (pref camera_pos 1) (pref camera_pos 2) ;; position
       SKY_BOX_SCALE SKY_BOX_SCALE SKY_BOX_SCALE)                  ;; scale
      (shader_update_matrices shader model view projection)
      (bind_cube SKY_BOX_TEXTURE 0) ;; update off (sky never changes!)
      (glUniform1i (glGetUniformLocation (id shader) "tex1") 0)
      (xtm_draw_model SKY_BOX_MODEL shader model view projection)
      (unbind_cube SKY_BOX_TEXTURE 0)
      (stop shader)
      (unbind fbo)
      ;; (glDepthMask GL_TRUE)
      void)))

;;;;;;;;;;;;;;
;;
;; PROJECTED TEXTURE
;;
;;;;;;;;;;;;;;

(bind-val PROJECTION_TEXTURE Texture*)
(bind-val PROJECTION_TEXTURE_ON i1 #f)

(bind-func xtm_projection_texture_load
  (lambda (flipped:i1 filename:String*)
    (set! PROJECTION_TEXTURE (Texture))
    (load_data PROJECTION_TEXTURE (i1toi32 flipped) filename)
    (update PROJECTION_TEXTURE) ;; send data to card
    (set! PROJECTION_TEXTURE_ON #t)
    (set! PROJECTION_TEXTURE_WEIGHT 0.5:f)
    void))

(bind-func xtm_projecton_texture_weight
  (lambda (x)
    (set! PROJECTION_TEXTURE_WEIGHT x)
    void))

;;;;;;;;;;;;;;
;;
;; ENV MAP
;;
;;;;;;;;;;;;;;

(bind-val ENV_MAP_TEXTURE Texture*)
(bind-val ENV_MAP i1 #f)

(bind-func xtm_envmap_init
  (lambda (flipped:i1 front:String* back:String* top:String* bottom:String* left:String* right:String*)
    (set! ENV_MAP_TEXTURE (Texture))
    (load_cube_data ENV_MAP_TEXTURE (i1toi32 flipped) front back top bottom left right)
    (update_cube ENV_MAP_TEXTURE) ;; send data to card
    ;; (bind_cube ENV_MAP_TEXTURE #t 2) ;; send data to card
    ;; (unbind_cube SKY_BOX_TEXTURE 2)
    (set! ENV_MAP #t)
    (set! ENV_MAP_WEIGHT 1.0:f)
    void))

(bind-func xtm_envmap_weight
  (lambda (x)
    (set! ENV_MAP_WEIGHT x)
    void))

(bind-func xtm_envmap_as_skybox
  (lambda ()
    (set! ENV_MAP_TEXTURE SKY_BOX_TEXTURE)
    (set! ENV_MAP #t)
    void))

;;;;;;;;;;;;;
;;
;;  DOF
;;
;;;;;;;;;;;;;

(bind-val XTM_DOF_ON i1 #f)
(bind-val XTM_DOF_DEBUG i1 #f)
(bind-val XTM_DOF_AUTOFOCUS i1 #f)
(bind-val XTM_DOF_DISTANCE float 0.0)
(bind-val XTM_DOF_X float 0.5)
(bind-val XTM_DOF_Y float 0.5)
(bind-val XTM_DOF_FSTOP float 4.0)
(bind-val XTM_DOF_FLENGTH float 50.0)

(bind-func xtm_dof
  (lambda (distance fstop flength debug)
    (set! XTM_DOF_ON #t)
    (set! XTM_DOF_DEBUG debug)
    (set! XTM_DOF_AUTOFOCUS #f)
    (set! XTM_DOF_DISTANCE distance)
    (set! XTM_DOF_FSTOP fstop)
    (set! XTM_DOF_FLENGTH flength)
    void))

(bind-func xtm_dof
  (lambda (x y fstop flength debug)
    (set! XTM_DOF_ON #t)
    (set! XTM_DOF_DEBUG debug)
    (set! XTM_DOF_AUTOFOCUS #t)
    (set! XTM_DOF_X x)
    (set! XTM_DOF_X y)
    (set! XTM_DOF_FSTOP fstop)
    (set! XTM_DOF_FLENGTH flength)
    void))

(bind-func xtm_dof
  (lambda (distance fstop flength)
    (xtm_dof:[void,float,float,float,i1]* distance fstop flength #f)))

(bind-func xtm_dof
  (lambda (x y fstop flength)
    (xtm_dof:[void,float,float,float,float,i1]* x y fstop flength #f)))

(bind-func xtm_dof
  (lambda (distance)
    (xtm_dof:[void,float,float,float,i1]* distance 4.0 80.0 #f)))

(bind-func xtm_dof
  (lambda (x y)
    (xtm_dof:[void,float,float,float,float,i1]* x y 4.0 80.0 #f)))


;; focal depth (i.e. focal point) in meters
;; focal length in mm
;; fstop (camera)
;; show_focus draws orange colour at focus depth
(bind-func xtm_dof_fx
  (let ((idmat:float* (alloc 16)))
    (fill_identity_matrix idmat)
    (lambda (fbo:FBO* autofocus focusx focusy fdepth flength fstop show_focus model view projection)
      (let ((shader xtm_render_dof_shader)
            (focuspt:float* (salloc 2)))
        (fill_identity_matrix idmat)
        (glDisable GL_DEPTH_TEST)
        (start shader)
        (shader_update_matrices shader model view projection)
        (bind (depth_tex fbo) 0)
        (glUniform1i (glGetUniformLocation (id shader) "bgl_DepthTexture") 0)
        (bind (colour_tex fbo) 2)
        (glUniform1i (glGetUniformLocation (id shader) "bgl_RenderedTexture") 2)
        (glUniform1f (glGetUniformLocation (id shader) "znear") xtm_render_near)
        (glUniform1f (glGetUniformLocation (id shader) "zfar") xtm_render_far)
        (glUniform1f (glGetUniformLocation (id shader) "focalDepth") fdepth)
        (glUniform1f (glGetUniformLocation (id shader) "focalLength") flength)
        (glUniform1f (glGetUniformLocation (id shader) "fstop") fstop)
        (glUniform1i (glGetUniformLocation (id shader) "showFocus") show_focus)
        (glUniform1i (glGetUniformLocation (id shader) "autofocus") autofocus)
        (glUniform1f (glGetUniformLocation (id shader) "bgl_RenderedTextureWidth") (i32tof xtm_render_w))
        (glUniform1f (glGetUniformLocation (id shader) "bgl_RenderedTextureHeight") (i32tof xtm_render_h))
        (pfill! focuspt focusx focusy)
        (glUniform2fv (glGetUniformLocation (id shader) "focus") 1 focuspt)
        (draw_quad shader idmat)
        (unbind (colour_tex fbo) 0)
        (unbind (depth_tex fbo) 2)
        (stop shader)
        void))))

(bind-func xtm_dof_fx
  (lambda (fbo:FBO* fdepth flength fstop model view projection)
    (xtm_dof_fx:[void,FBO*,i32,float,float,float,float,float,i32,float*,float*,float*]* fbo 0 0.5 0.5 fdepth flength fstop 0 model view projection)))

(bind-func xtm_dof_fx
  (lambda (fbo:FBO* x y flength fstop model view projection)
    (xtm_dof_fx:[void,FBO*,i32,float,float,float,float,float,i32,float*,float*,float*]* fbo 1 x y 0.0 flength fstop 0 model view projection)))

(bind-func xtm_dof_fx
  (lambda (fbo:FBO* fdepth flength fstop show_depth model view projection)
    (xtm_dof_fx:[void,FBO*,i32,float,float,float,float,float,i32,float*,float*,float*]* fbo 0 0.5 0.5 fdepth flength fstop show_depth model view projection)))

(bind-func xtm_dof_fx
  (lambda (fbo:FBO* x y flength fstop show_depth model view projection)
    (xtm_dof_fx:[void,FBO*,i32,float,float,float,float,float,i32,float*,float*,float*]* fbo 1 x y 0.0 flength fstop show_depth model view projection)))

(bind-func xtm_render_fbo
  (let ((fbo:FBO* null))
    (lambda ()
      (if (null? fbo) (set! fbo (FBO xtm_render_w xtm_render_h #t)))
      fbo)))

(bind-func xtm_shadow_fbo
  (let ((fbo:FBO* null))
    (lambda ()
      (if (null? fbo) (set! fbo (FBO (ftoi32 (* 4.0 1024.0)) (ftoi32 (* 4.0 1024.0)) #t)))
      fbo)))


(bind-func xtm_render_init
  (lambda (w h)
    (let ((quad-vert (sys_slurp_file "libs/external/gl/quad_v.glsl"))
          (quad-frag (sys_slurp_file "libs/external/gl/quad_f.glsl"))
          (dof-frag (sys_slurp_file "libs/external/gl/dof_f.glsl"))
          (simple-vert (sys_slurp_file "libs/external/gl/simple_v.glsl"))
          (simple-frag (sys_slurp_file "libs/external/gl/simple_f.glsl"))
          (lights-vert (sys_slurp_file "libs/external/gl/lights_v.glsl"))
          (lights-frag (sys_slurp_file "libs/external/gl/lights_f.glsl"))
          (skybox-vert (sys_slurp_file "libs/external/gl/sky_v.glsl"))
          (skybox-frag (sys_slurp_file "libs/external/gl/sky_f.glsl")))
      (println "XTM RENDER SETUP on thread:" (thread_self))
      (println 'init 'draw 'quad)
      (init_draw_quad)
      (println 'init 'QUAD 'shader)
      (xtm_render_init_quad_shader quad-vert quad-frag)
      (println 'init 'DOF 'shader)
      (xtm_render_init_dof_shader quad-vert dof-frag)
      (println 'init 'SIMPLE 'shader)
      (xtm_render_init_simple_shader simple-vert simple-frag)
      ;; (println 'init 'SIMPLE_BONE 'shader)
      ;; (xtm_render_init_simple_bone_shader simple-bone-vert-xtm simple-frag)
      (println 'init 'LIGHT 'shader)
      (xtm_render_init_light_shader lights-vert lights-frag)
      (println 'init 'SKYBOX 'shader)
      (xtm_render_init_skybox_shader skybox-vert skybox-frag)
      (println 'all-shaders-initialized)
      (set! xtm_render_w w)
      (set! xtm_render_h h)
      (set! XTM_BACKGROUND_COLOUR (vector 0.7:float 0.7 0.7 1.0))
      (xtm_shadow_fbo)
      (gl_print_error "error setting-up xtm_shadow_fbo")
      (xtm_render_fbo)
      (gl_print_error "error setting-up xtm_render_fbo")
      (printf "XTM Render Setup Complete\n")
      void)))


(bind-alias XTMRENDERCB [void,i64,ShaderProgram*,float*,float*,float*,i8*]*)

(bind-func xtm_background_colour
  (lambda (r:float g b a)
    (set! XTM_BACKGROUND_COLOUR (vector r g b a))
    void))

(bind-func xtm_background_colour
  (lambda (r:float g b)
    (set! XTM_BACKGROUND_COLOUR (vector r g b 1.0))
    void))

;;
;; near  = 0.1
;; far   = 100.0
;; angle = 35.0
;;
(bind-func xtm_render
  (let ((i:i32 0)
        (frame:i64 0)
        (lights:xtm_lights* (xtm_get_lights))
        (camera:xtm_camera* (xtm_get_camera))
        (activelights:i32 0)
        (framebufsize:float* (alloc 2))
        (sh1:ShaderProgram* null)
        (sh2:ShaderProgram* null)
        (model:float* (alloc 16))
        (view:float* (alloc 16))
        (projection:float* (alloc 16))
        (shadow_fbo:FBO* null)
        (render_fbo:FBO* null))
    (lambda (pre:XTMRENDERCB opaque:XTMRENDERCB transparent:XTMRENDERCB post:XTMRENDERCB data:i8*)
      (set! shadow_fbo (xtm_shadow_fbo))
      (set! render_fbo (xtm_render_fbo))
      ;; (glShadeModel GL_SMOOTH)
      (glEnable GL_DEPTH_TEST)
      ;; (glEnable GL_TEXTURE_2D)
      ;; seutp projection matrix
      (fill_projection_matrix projection xtm_render_angle
                              (/ (i32tof xtm_render_w) (i32tof xtm_render_h))
                              xtm_render_near xtm_render_far)
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; pre - move lights cameras etc..
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (if (not (null? pre))
          (begin
            ;; each cycle set lights back to 0
            (tset! (xtm_get_lights) 9 0)
            (xtm_camera_view view)       ;; set view
            (fill_identity_matrix model) ;; set model
            (pre frame null model view projection data)))
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; calc shadow for each light into shadow_fbo
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (gl_print_error "prerender gl error")
      ;; (set! sh1 xtm_render_simple_bone_shader)
      (set! sh1 xtm_render_simple_shader)
      (start sh1) ;; start program
      (bind shadow_fbo) ;; bind fbo
      ;; clear shadow fbo
      (glClearColor 0.0 0.25 0.25 1.0)
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      ;; this all for shadows?
      (if (not (null? opaque))
          (dotimes (i (tref lights 9))
            ;; 4 x 4 shadow texture texture
            (glViewport (* (% i 4) 1024) (* (ftoi32 (/ (i32tof i) 4.0)) 1024) 1024 1024)
            (glEnable GL_CULL_FACE) ;; face culling ON for shadowmapping
            (glCullFace GL_FRONT)
            (fill_identity_matrix model)  ;; set model matrix
            (xtm_light_view (+ i 1) view) ;; set view matrix
            (xtm_update_matrices sh1 model view projection)
            (opaque frame sh1 model view projection data)
            (gl_print_error)
            void))
      ;; turn off shadow FBO
      (unbind shadow_fbo)
      (stop sh1)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; clear render fbo
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (bind render_fbo)
      (glClearColor (vref XTM_BACKGROUND_COLOUR 0)
                    (vref XTM_BACKGROUND_COLOUR 1)
                    (vref XTM_BACKGROUND_COLOUR 2)
                    (vref XTM_BACKGROUND_COLOUR 3))
      (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))
      (unbind render_fbo)

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; draw sky box if enabled
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (glViewport xtm_render_x xtm_render_y xtm_render_w xtm_render_h) ;; not sure if I need or want this line?
      (if SKY_BOX   ;; skybox is active texture 6
          (begin
            (xtm_camera_view view)       ;; setup view
            (fill_identity_matrix model) ;; setup model
            (xtm_skybox_fx render_fbo model view projection)))

      ;; (glDepthMask GL_TRUE)
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; main render to FBO using shadow fbo as shadow map
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (set! activelights (tref lights 9))
      (if (> activelights 5) (set! activelights (i64toi32 5)))
      ;; Finally render the scene to the window
      ;; using the shadow FBO's depth buffer as a shadow map
      (set! sh2 xtm_render_light_shader)
      (start sh2) ;; start program
      (bind render_fbo) ;; bind fbo
      (bind (depth_tex shadow_fbo) 0) ;; bind shadow texture (texunit 0)
      (glUniform1i (glGetUniformLocation (id sh2) "shadowMap") 0)
      (if ENV_MAP ;; env map bound to texture unit 4
          (shader_update_envmap sh2 2 ENV_MAP_TEXTURE)
          (shader_update_envmap sh2 2 null))
      (if PROJECTION_TEXTURE_ON  ;; projection texture bound to tex unit 5
          (shader_update_projection_texture sh2 3 PROJECTION_TEXTURE)
          (shader_update_projection_texture sh2 3 null))
      ;; draw scene
      (glViewport xtm_render_x xtm_render_y xtm_render_w xtm_render_h)
      (glDisable GL_CULL_FACE) ;; turn face culling off
      ;; clear main framebuffer (if no skybox)
      ;; (glClearColor 0.7 0.7 0.7 1.0)
      ;; (if #t ; (not SKY_BOX)
      ;;     (begin
      ;;       (glClearColor (vref XTM_BACKGROUND_COLOUR 0)
      ;;                     (vref XTM_BACKGROUND_COLOUR 1)
      ;;                     (vref XTM_BACKGROUND_COLOUR 2)
      ;;                     (vref XTM_BACKGROUND_COLOUR 3))
      ;;       (glClear (+ GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))))
      (if (not (null? opaque))
          (begin
            ;; setup matrices
            (fill_projection_matrix projection xtm_render_angle
                                    (/ (i32tof xtm_render_w) (i32tof xtm_render_h))
                                    xtm_render_near xtm_render_far)
            (xtm_camera_view view)       ;; setup view
            (fill_identity_matrix model) ;; setup model
            (xtm_update_lights sh2) ;; update lights on shader
            (xtm_update_camera sh2) ;; update camera on shader
            (xtm_update_matrices sh2 model view projection) ;; update mats on shader
            (opaque frame sh2 model view projection data)
            void))
      (gl_print_error "Error in XTM pipeline rendering Opaque!")

      (if (not (null? transparent))
          (begin
            ;; setup matrices
            (fill_projection_matrix projection xtm_render_angle
                                    (/ (i32tof xtm_render_w) (i32tof xtm_render_h))
                                    xtm_render_near xtm_render_far)
            (xtm_camera_view view)       ;; setup view
            (fill_identity_matrix model) ;; setup model
            (xtm_update_lights sh2) ;; update lights on shader
            (xtm_update_camera sh2) ;; update camera on shader
            (xtm_update_matrices sh2 model view projection) ;; update mats on shader
            (transparent frame sh2 model view projection data)
            void))
      (gl_print_error "Error in XTM pipeline rendering Transparent!")

      ;; turn everything off
      (unbind (depth_tex shadow_fbo))
      (unbind render_fbo)
      (stop sh2)
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; post - for fullscreen 2d stuff (drawing overlays) 2D fx etc..
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (glDisable GL_DEPTH_TEST)
      (fill_identity_matrix model)
      (fill_identity_matrix view)
      (fill_orthographic_matrix projection -1.0 1.0 -1.0 1.0 -1.0 1.0)
      (bind render_fbo)
      (if XTM_DOF_ON
          (if XTM_DOF_AUTOFOCUS
              (xtm_dof_fx render_fbo XTM_DOF_X XTM_DOF_Y XTM_DOF_FLENGTH XTM_DOF_FSTOP
                          (i1toi32 XTM_DOF_DEBUG) model view projection)
              (xtm_dof_fx render_fbo XTM_DOF_DISTANCE XTM_DOF_FLENGTH XTM_DOF_FSTOP
                          (i1toi32 XTM_DOF_DEBUG) model view projection)))
      (unbind render_fbo)
      ;; if post render is enabled it is the responsibility of the postrender
      ;; function to draw the render_fbo - which can be globally accessed calling (xtm_render_fbo)
      (if (null? post) ;; if no post then draw render_fbo out
          (xtm_draw_tex xtm_render_quad_shader (colour_tex render_fbo) model view projection)
          (post frame xtm_render_quad_shader model view projection data))
      (glEnable GL_DEPTH_TEST)
      (gl_print_error "Error in xtm_render")
      ;; if (xtm_dof ...) will get reset on next cycle
      (set! XTM_DOF_ON #f)
      (set! frame (+ frame 1)))))

(impc:aot:insert-footer "xtmgraphics-pipeline")
(define *xtmlib-graphics-pipeline-loaded* #t)
