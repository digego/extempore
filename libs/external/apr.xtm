;;; apr.xtm -- bindings for apache portable runtime

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libapr

;;; Commentary:

;; This is based on the headers from APR, which is licenced thus:

;; /* Licensed to the Apache Software Foundation (ASF) under one or more
;;  * contributor license agreements.  See the NOTICE file distributed with
;;  * this work for additional information regarding copyright ownership.
;;  * The ASF licenses this file to You under the Apache License, Version 2.0
;;  * (the "License"); you may not use this file except in compliance with
;;  * the License.  You may obtain a copy of the License at
;;  *
;;  *     http://www.apache.org/licenses/LICENSE-2.0
;;  *
;;  * Unless required by applicable law or agreed to in writing, software
;;  * distributed under the License is distributed on an "AS IS" BASIS,
;;  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;  * See the License for the specific language governing permissions and
;;  * limitations under the License.
;;  */

;; Currently, we only bind the apr_file_io, apr_file_info and apr_env
;; headers, but we may expand our bindings in the future

;;; Code:

(if *impc:compiler:with-cache* (sys:load "libs/aot-cache/apr.xtm" 'quiet))
(sys:load-preload-check 'apr)
(define *xtmlib-apr-loaded* #t)

(impc:aot:suppress-aot-do
 (sys:load "libs/base/base.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/base/base.xtm" 'quiet))

(impc:aot:insert-header "xtmapr")

(bind-dylib libapr
  (cond ((string=? (sys:platform) "OSX")
         (list "libapr-1.0.dylib"
               "/usr/local/opt/apr/libexec/lib/libapr-1.0.dylib"))
        ((string=? (sys:platform) "Linux") "libapr.so")
        ((string=? (sys:platform) "Windows") "libapr-1.dll"))
  "xtmapr")

(impc:aot:import-ll "xtmapr")

(bind-alias apr_status_t i32) ;; int
(bind-alias apr_time_t i64)
(bind-alias apr_interval_time_t i64)
(bind-alias apr_off_t i64)
(bind-alias apr_uid_t i32)
(bind-alias apr_gid_t i32)
(bind-alias apr_ino_t i64)
;; use as opaque i8*
(bind-alias apr_pool_t i8)
(bind-alias apr_file_t i8)
(bind-alias apr_array_header_t i8)

(bind-val APR_SUCCESS i32 0)

;; /**
;;  * Return a human readable string describing the specified error.
;;  * @param statcode The error code to get a string for.
;;  * @param buf A buffer to hold the error string.
;;  * @param bufsize Size of the buffer to hold the string.
;;  */
(bind-lib libapr apr_strerror [i8*,apr_status_t,i8*,size_t]*)

;;;;;;;;;;;;;;;;;
;; apr_errno.h ;;
;;;;;;;;;;;;;;;;;

;; /**
;;  * APR_OS_START_ERROR is where the APR specific error values start.
;;  */
(bind-val APR_OS_START_ERROR i32 20000)
;; /**
;;  * APR_OS_ERRSPACE_SIZE is the maximum number of errors you can fit
;;  *    into one of the error/status ranges below -- except for
;;  *    APR_OS_START_USERERR, which see.
;;  */
(bind-val APR_OS_ERRSPACE_SIZE i32 50000)
;; /**
;;  * APR_UTIL_ERRSPACE_SIZE is the size of the space that is reserved for
;;  * use within apr-util. This space is reserved above that used by APR
;;  * internally.
;;  * @note This number MUST be smaller than APR_OS_ERRSPACE_SIZE by a
;;  *       large enough amount that APR has sufficient room for its
;;  *       codes.
;;  */
(bind-val APR_UTIL_ERRSPACE_SIZE i32 20000)
;; /**
;;  * APR_OS_START_STATUS is where the APR specific status codes start.
;;  */
(bind-val APR_OS_START_STATUS i32 70000)
;; /**
;;  * APR_UTIL_START_STATUS is where APR-Util starts defining its
;;  * status codes.
;;  */
(bind-val APR_UTIL_START_STATUS i32 100000)
;; /**
;;  * APR_OS_START_USERERR are reserved for applications that use APR that
;;  *     layer their own error codes along with APR's.  Note that the
;;  *     error immediately following this one is set ten times farther
;;  *     away than usual, so that users of apr have a lot of room in
;;  *     which to declare custom error codes.
;;  *
;;  * In general applications should try and create unique error codes. To try
;;  * and assist in finding suitable ranges of numbers to use, the following
;;  * ranges are known to be used by the listed applications. If your
;;  * application defines error codes please advise the range of numbers it
;;  * uses to dev@apr.apache.org for inclusion in this list.
;;  *
;;  * Ranges shown are in relation to APR_OS_START_USERERR
;;  *
;;  * Subversion - Defined ranges, of less than 100, at intervals of 5000
;;  *              starting at an offset of 5000, e.g.
;;  *               +5000 to 5100,  +10000 to 10100
;;  *
;;  * Apache HTTPD - +2000 to 2999
;;  */
(bind-val APR_OS_START_USERERR i32 120000)
;; /**
;;  * APR_OS_START_CANONERR is where APR versions of errno values are defined
;;  *     on systems which don't have the corresponding errno.
;;  */
(bind-val APR_OS_START_CANONERR i32 620000)
;; /**
;;  * APR_OS_START_EAIERR folds EAI_ error codes from getaddrinfo() into
;;  *     apr_status_t values.
;;  */
(bind-val APR_OS_START_EAIERR i32 670000)
;; /**
;;  * APR_OS_START_SYSERR folds platform-specific system error values into
;;  *     apr_status_t values.
;;  */
(bind-val APR_OS_START_SYSERR i32 720000)

;; /**
;;  * @defgroup APR_ERROR_map APR Error Space
;;  * <PRE>
;;  * The following attempts to show the relation of the various constants
;;  * used for mapping APR Status codes.
;;  *
;;  *       0
;;  *
;;  *  20,000     APR_OS_START_ERROR
;;  *
;;  *         + APR_OS_ERRSPACE_SIZE (50,000)
;;  *
;;  *  70,000      70000
;;  *
;;  *         + APR_OS_ERRSPACE_SIZE - APR_UTIL_ERRSPACE_SIZE (30,000)
;;  *
;;  * 100,000      APR_UTIL_START_STATUS
;;  *
;;  *         + APR_UTIL_ERRSPACE_SIZE (20,000)
;;  *
;;  * 120,000      APR_OS_START_USERERR
;;  *
;;  *         + 10 x APR_OS_ERRSPACE_SIZE (50,000 * 10)
;;  *
;;  * 620,000      APR_OS_START_CANONERR
;;  *
;;  *         + APR_OS_ERRSPACE_SIZE (50,000)
;;  *
;;  * 670,000      APR_OS_START_EAIERR
;;  *
;;  *         + APR_OS_ERRSPACE_SIZE (50,000)
;;  *
;;  * 720,000      APR_OS_START_SYSERR
;;  *
;;  * </PRE>
;;  */

;; /** no error. */

;; /**
;;  * @defgroup APR_Error APR Error Values
;;  * <PRE>
;;  * <b>APR ERROR VALUES</b>
;;  * APR_ENOSTAT      APR was unable to perform a stat on the file
;;  * APR_ENOPOOL      APR was not provided a pool with which to allocate memory
;;  * APR_EBADDATE     APR was given an invalid date
;;  * APR_EINVALSOCK   APR was given an invalid socket
;;  * APR_ENOPROC      APR was not given a process structure
;;  * APR_ENOTIME      APR was not given a time structure
;;  * APR_ENODIR       APR was not given a directory structure
;;  * APR_ENOLOCK      APR was not given a lock structure
;;  * APR_ENOPOLL      APR was not given a poll structure
;;  * APR_ENOSOCKET    APR was not given a socket
;;  * APR_ENOTHREAD    APR was not given a thread structure
;;  * APR_ENOTHDKEY    APR was not given a thread key structure
;;  * APR_ENOSHMAVAIL  There is no more shared memory available
;;  * APR_EDSOOPEN     APR was unable to open the dso object.  For more
;;  *                  information call apr_dso_error().
;;  * APR_EGENERAL     General failure (specific information not available)
;;  * APR_EBADIP       The specified IP address is invalid
;;  * APR_EBADMASK     The specified netmask is invalid
;;  * APR_ESYMNOTFOUND Could not find the requested symbol
;;  * APR_ENOTENOUGHENTROPY Not enough entropy to continue
;;  * </PRE>
;;  *
;;  * <PRE>
;;  * <b>APR STATUS VALUES</b>
;;  * APR_INCHILD        Program is currently executing in the child
;;  * APR_INPARENT       Program is currently executing in the parent
;;  * APR_DETACH         The thread is detached
;;  * APR_NOTDETACH      The thread is not detached
;;  * APR_CHILD_DONE     The child has finished executing
;;  * APR_CHILD_NOTDONE  The child has not finished executing
;;  * APR_TIMEUP         The operation did not finish before the timeout
;;  * APR_INCOMPLETE     The operation was incomplete although some processing
;;  *                    was performed and the results are partially valid
;;  * APR_BADCH          Getopt found an option not in the option string
;;  * APR_BADARG         Getopt found an option that is missing an argument
;;  *                    and an argument was specified in the option string
;;  * APR_EOF            APR has encountered the end of the file
;;  * APR_NOTFOUND       APR was unable to find the socket in the poll structure
;;  * APR_ANONYMOUS      APR is using anonymous shared memory
;;  * APR_FILEBASED      APR is using a file name as the key to the shared memory
;;  * APR_KEYBASED       APR is using a shared key as the key to the shared memory
;;  * APR_EINIT          Ininitalizer value.  If no option has been found, but
;;  *                    the status variable requires a value, this should be used
;;  * APR_ENOTIMPL       The APR function has not been implemented on this
;;  *                    platform, either because nobody has gotten to it yet,
;;  *                    or the function is impossible on this platform.
;;  * APR_EMISMATCH      Two passwords do not match.
;;  * APR_EABSOLUTE      The given path was absolute.
;;  * APR_ERELATIVE      The given path was relative.
;;  * APR_EINCOMPLETE    The given path was neither relative nor absolute.
;;  * APR_EABOVEROOT     The given path was above the root path.
;;  * APR_EBUSY          The given lock was busy.
;;  * APR_EPROC_UNKNOWN  The given process wasn't recognized by APR
;;  * </PRE>
;;  * @{
;;  */
(bind-val APR_ENOSTAT i32 20001)
(bind-val APR_ENOPOOL i32 20002)
;; /* empty slot: +3 */
(bind-val APR_EBADDATE i32 20004)
(bind-val APR_EINVALSOCK i32 20005)
(bind-val APR_ENOPROC i32 20006)
(bind-val APR_ENOTIME i32 20007)
(bind-val APR_ENODIR i32 20008)
(bind-val APR_ENOLOCK i32 20009)
(bind-val APR_ENOPOLL i32 20010)
(bind-val APR_ENOSOCKET i32 20011)
(bind-val APR_ENOTHREAD i32 20012)
(bind-val APR_ENOTHDKEY i32 20013)
(bind-val APR_EGENERAL i32 20014)
(bind-val APR_ENOSHMAVAIL i32 20015)
(bind-val APR_EBADIP i32 20016)
(bind-val APR_EBADMASK i32 20017)
;; /* empty slot: +18 */
(bind-val APR_EDSOOPEN i32 20019)
(bind-val APR_EABSOLUTE i32 20020)
(bind-val APR_ERELATIVE i32 20021)
(bind-val APR_EINCOMPLETE i32 20022)
(bind-val APR_EABOVEROOT i32 20023)
(bind-val APR_EBADPATH i32 20024)
(bind-val APR_EPATHWILD i32 20025)
(bind-val APR_ESYMNOTFOUND i32 20026)
(bind-val APR_EPROC_UNKNOWN i32 20027)
(bind-val APR_ENOTENOUGHENTROPY i32 20028)

;; /**
;;  * @addtogroup APR_Error
;;  * @{
;;  */
(bind-val APR_INCHILD i32 70001)
(bind-val APR_INPARENT i32 70002)
(bind-val APR_DETACH i32 70003)
(bind-val APR_NOTDETACH i32 70004)
(bind-val APR_CHILD_DONE i32 70005)
(bind-val APR_CHILD_NOTDONE i32 70006)
(bind-val APR_TIMEUP i32 70007)
(bind-val APR_INCOMPLETE i32 70008)
;; /* empty slot: +9 */
;; /* empty slot: +10 */
;; /* empty slot: +11 */
(bind-val APR_BADCH i32 70012)
(bind-val APR_BADARG i32 70013)
(bind-val APR_EOF i32 70014)
(bind-val APR_NOTFOUND i32 70015)
;; /* empty slot: +16 */
;; /* empty slot: +17 */
;; /* empty slot: +18 */
(bind-val APR_ANONYMOUS i32 70019)
(bind-val APR_FILEBASED i32 70020)
(bind-val APR_KEYBASED i32 70021)
(bind-val APR_EINIT i32 70022)
(bind-val APR_ENOTIMPL i32 70023)
(bind-val APR_EMISMATCH i32 70024)
(bind-val APR_EBUSY i32 70025)

;;;;;;;;;;;;;;;;;;;
;; apr_general.h ;;
;;;;;;;;;;;;;;;;;;;

;; /**
;;  * Setup any APR internal data structures.  This MUST be the first function
;;  * called for any APR library. It is safe to call apr_initialize several
;;  * times as long as apr_terminate is called the same number of times.
;;  * @remark See apr_app_initialize if this is an application, rather than
;;  * a library consumer of apr.
;;  */
(bind-lib libapr apr_initialize [apr_status_t]*)

;; /**
;;  * Set up an application with normalized argc, argv (and optionally env) in
;;  * order to deal with platform-specific oddities, such as Win32 services,
;;  * code pages and signals.  This must be the first function called for any
;;  * APR program.
;;  * @param argc Pointer to the argc that may be corrected
;;  * @param argv Pointer to the argv that may be corrected
;;  * @param env Pointer to the env that may be corrected, may be NULL
;;  * @remark See apr_initialize if this is a library consumer of apr.
;;  * Otherwise, this call is identical to apr_initialize, and must be closed
;;  * with a call to apr_terminate at the end of program execution.
;;  */
(bind-lib libapr apr_app_initialize [apr_status_t,i32*,i8**,i8**]*)

;; /**
;;  * Tear down any APR internal data structures which aren't torn down
;;  * automatically. apr_terminate must be called once for every call to
;;  * apr_initialize() or apr_app_initialize().
;;  * @remark An APR program must call this function at termination once it
;;  *         has stopped using APR services.  The APR developers suggest using
;;  *         atexit to ensure this is called.  When using APR from a language
;;  *         other than C that has problems with the calling convention, use
;;  *         apr_terminate2() instead.
;;  */
(bind-lib libapr apr_terminate [void]*)

;; /**
;;  * Tear down any APR internal data structures which aren't torn down
;;  * automatically, same as apr_terminate
;;  * @remark An APR program must call either the apr_terminate or apr_terminate2
;;  *         function once it it has finished using APR services.  The APR
;;  *         developers suggest using atexit(apr_terminate) to ensure this is done.
;;  *         apr_terminate2 exists to allow non-c language apps to tear down apr,
;;  *         while apr_terminate is recommended from c language applications.
;;  */
(bind-lib libapr apr_terminate2 [void]*)

;;;;;;;;;;;;;;;;;
;; apr_pools.h ;;
;;;;;;;;;;;;;;;;;

(bind-alias apr_abortfunc_t [i32,i32]*)
(bind-alias apr_allocator_t i8)

;; /**
;;  * Pool debug levels
;;  *
;;  * <pre>
;;  * | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
;;  * ---------------------------------
;;  * |   |   |   |   |   |   |   | x |  General debug code enabled (useful in
;;  *                                    combination with --with-efence).
;;  *
;;  * |   |   |   |   |   |   | x |   |  Verbose output on stderr (report
;;  *                                    CREATE, CLEAR, DESTROY).
;;  *
;;  * |   |   |   | x |   |   |   |   |  Verbose output on stderr (report
;;  *                                    PALLOC, PCALLOC).
;;  *
;;  * |   |   |   |   |   | x |   |   |  Lifetime checking. On each use of a
;;  *                                    pool, check its lifetime.  If the pool
;;  *                                    is out of scope, abort().
;;  *                                    In combination with the verbose flag
;;  *                                    above, it will output LIFE in such an
;;  *                                    event prior to aborting.
;;  *
;;  * |   |   |   |   | x |   |   |   |  Pool owner checking.  On each use of a
;;  *                                    pool, check if the current thread is the
;;  *                                    pool's owner.  If not, abort().  In
;;  *                                    combination with the verbose flag above,
;;  *                                    it will output OWNER in such an event
;;  *                                    prior to aborting.  Use the debug
;;  *                                    function apr_pool_owner_set() to switch
;;  *                                    a pool's ownership.
;;  *
;;  * When no debug level was specified, assume general debug mode.
;;  * If level 0 was specified, debugging is switched off.
;;  * </pre>
;;  */


;; /*
;;  * APR memory structure manipulators (pools, tables, and arrays).
;;  */

;; /*
;;  * Initialization
;;  */

;; /**
;;  * Setup all of the internal structures required to use pools
;;  * @remark Programs do NOT need to call this directly.  APR will call this
;;  *      automatically from apr_initialize.
;;  * @internal
;;  */
(bind-lib libapr apr_pool_initialize [apr_status_t]*)

;; /**
;;  * Tear down all of the internal structures required to use pools
;;  * @remark Programs do NOT need to call this directly.  APR will call this
;;  *      automatically from apr_terminate.
;;  * @internal
;;  */
(bind-lib libapr apr_pool_terminate [void]*)


;; /*
;;  * Pool creation/destruction
;;  */

;; /**
;;  * Create a new pool.
;;  * @param newpool The pool we have just created.
;;  * @param parent The parent pool.  If this is NULL, the new pool is a root
;;  *        pool.  If it is non-NULL, the new pool will inherit all
;;  *        of its parent pool's attributes, except the apr_pool_t will
;;  *        be a sub-pool.
;;  * @param abort_fn A function to use if the pool cannot allocate more memory.
;;  * @param allocator The allocator to use with the new pool.  If NULL the
;;  *        allocator of the parent pool will be used.
;;  * @remark This function is thread-safe, in the sense that multiple threads
;;  *         can safely create subpools of the same parent pool concurrently.
;;  *         Similarly, a subpool can be created by one thread at the same
;;  *         time that another thread accesses the parent pool.
;;  */
(bind-lib libapr apr_pool_create_ex [apr_status_t,apr_pool_t**,apr_pool_t*,apr_abortfunc_t,apr_allocator_t*]*)

;; /**
;;  * Create a new pool.
;;  * @deprecated @see apr_pool_create_unmanaged_ex.
;;  */
(bind-lib libapr apr_pool_create_core_ex [apr_status_t,apr_pool_t**,apr_abortfunc_t,apr_allocator_t*]*)

;; /**
;;  * Create a new unmanaged pool.
;;  * @param newpool The pool we have just created.
;;  * @param abort_fn A function to use if the pool cannot allocate more memory.
;;  * @param allocator The allocator to use with the new pool.  If NULL a
;;  *        new allocator will be created with the new pool as owner.
;;  * @remark An unmanaged pool is a special pool without a parent; it will
;;  *         NOT be destroyed upon apr_terminate.  It must be explicitly
;;  *         destroyed by calling apr_pool_destroy, to prevent memory leaks.
;;  *         Use of this function is discouraged, think twice about whether
;;  *         you really really need it.
;;  * @warning Any child cleanups registered against the new pool, or
;;  *         against sub-pools thereof, will not be executed during an
;;  *         invocation of apr_proc_create(), so resources created in an
;;  *         "unmanaged" pool hierarchy will leak to child processes.
;;  */
(bind-lib libapr apr_pool_create_unmanaged_ex [apr_status_t,apr_pool_t**,apr_abortfunc_t,apr_allocator_t*]*)

;; /**
;;  * Debug version of apr_pool_create_ex.
;;  * @param newpool @see apr_pool_create.
;;  * @param parent @see apr_pool_create.
;;  * @param abort_fn @see apr_pool_create.
;;  * @param allocator @see apr_pool_create.
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @remark Only available when APR_POOL_DEBUG is defined.
;;  *         Call this directly if you have your apr_pool_create_ex
;;  *         calls in a wrapper function and wish to override
;;  *         the file_line argument to reflect the caller of
;;  *         your wrapper function.  If you do not have
;;  *         apr_pool_create_ex in a wrapper, trust the macro
;;  *         and don't call apr_pool_create_ex_debug directly.
;;  */
(bind-lib libapr apr_pool_create_ex_debug [apr_status_t,apr_pool_t**,apr_pool_t*,apr_abortfunc_t,apr_allocator_t*,i8*]*)

;; /**
;;  * Debug version of apr_pool_create_core_ex.
;;  * @deprecated @see apr_pool_create_unmanaged_ex_debug.
;;  */
(bind-lib libapr apr_pool_create_core_ex_debug [apr_status_t,apr_pool_t**,apr_abortfunc_t,apr_allocator_t*,i8*]*)

;; /**
;;  * Debug version of apr_pool_create_unmanaged_ex.
;;  * @param newpool @see apr_pool_create_unmanaged.
;;  * @param abort_fn @see apr_pool_create_unmanaged.
;;  * @param allocator @see apr_pool_create_unmanaged.
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @remark Only available when APR_POOL_DEBUG is defined.
;;  *         Call this directly if you have your apr_pool_create_unmanaged_ex
;;  *         calls in a wrapper function and wish to override
;;  *         the file_line argument to reflect the caller of
;;  *         your wrapper function.  If you do not have
;;  *         apr_pool_create_core_ex in a wrapper, trust the macro
;;  *         and don't call apr_pool_create_core_ex_debug directly.
;;  */
(bind-lib libapr apr_pool_create_unmanaged_ex_debug [apr_status_t,apr_pool_t**,apr_abortfunc_t,apr_allocator_t*,i8*]*)

;; /**
;;  * Create a new pool.
;;  * @param newpool The pool we have just created.
;;  * @param parent The parent pool.  If this is NULL, the new pool is a root
;;  *        pool.  If it is non-NULL, the new pool will inherit all
;;  *        of its parent pool's attributes, except the apr_pool_t will
;;  *        be a sub-pool.
;;  * @remark This function is thread-safe, in the sense that multiple threads
;;  *         can safely create subpools of the same parent pool concurrently.
;;  *         Similarly, a subpool can be created by one thread at the same
;;  *         time that another thread accesses the parent pool.
;;  */

;; /**
;;  * Find the pool's allocator
;;  * @param pool The pool to get the allocator from.
;;  */
(bind-lib libapr apr_pool_allocator_get [apr_allocator_t*,apr_pool_t*]*)

;; /**
;;  * Clear all memory in the pool and run all the cleanups. This also destroys all
;;  * subpools.
;;  * @param p The pool to clear
;;  * @remark This does not actually free the memory, it just allows the pool
;;  *         to re-use this memory for the next allocation.
;;  * @see apr_pool_destroy()
;;  */
                                        ;

;; /**
;;  * Debug version of apr_pool_clear.
;;  * @param p See: apr_pool_clear.
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @remark Only available when APR_POOL_DEBUG is defined.
;;  *         Call this directly if you have your apr_pool_clear
;;  *         calls in a wrapper function and wish to override
;;  *         the file_line argument to reflect the caller of
;;  *         your wrapper function.  If you do not have
;;  *         apr_pool_clear in a wrapper, trust the macro
;;  *         and don't call apr_pool_destroy_clear directly.
;;  */
(bind-lib libapr apr_pool_clear_debug [void,apr_pool_t*,i8*]*)

;; /**
;;  * Destroy the pool. This takes similar action as apr_pool_clear() and then
;;  * frees all the memory.
;;  * @param p The pool to destroy
;;  * @remark This will actually free the memory
;;  */
(bind-lib libapr apr_pool_destroy [void,apr_pool_t*]*)

;; /**
;;  * Debug version of apr_pool_destroy.
;;  * @param p See: apr_pool_destroy.
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @remark Only available when APR_POOL_DEBUG is defined.
;;  *         Call this directly if you have your apr_pool_destroy
;;  *         calls in a wrapper function and wish to override
;;  *         the file_line argument to reflect the caller of
;;  *         your wrapper function.  If you do not have
;;  *         apr_pool_destroy in a wrapper, trust the macro
;;  *         and don't call apr_pool_destroy_debug directly.
;;  */
(bind-lib libapr apr_pool_destroy_debug [void,apr_pool_t*,i8*]*)

;; /*
;;  * Memory allocation
;;  */

;; /**
;;  * Allocate a block of memory from a pool
;;  * @param p The pool to allocate from
;;  * @param size The amount of memory to allocate
;;  * @return The allocated memory
;;  */
(bind-lib libapr apr_palloc [i8*,apr_pool_t*,size_t]*)
;; #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
;; #endif;

;; /**
;;  * Debug version of apr_palloc
;;  * @param p See: apr_palloc
;;  * @param size See: apr_palloc
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @return See: apr_palloc
;;  */
(bind-lib libapr apr_palloc_debug [i8*,apr_pool_t*,size_t,i8*]*)
;; #if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
;; #endif;

;; /**
;;  * Allocate a block of memory from a pool and set all of the memory to 0
;;  * @param p The pool to allocate from
;;  * @param size The amount of memory to allocate
;;  * @return The allocated memory
;;  */
;; #if defined(DOXYGEN)
(bind-lib libapr apr_pcalloc [i8*,apr_pool_t*,size_t]*)

;; /**
;;  * Debug version of apr_pcalloc
;;  * @param p See: apr_pcalloc
;;  * @param size See: apr_pcalloc
;;  * @param file_line Where the function is called from.
;;  *        This is usually APR_POOL__FILE_LINE__.
;;  * @return See: apr_pcalloc
;;  */
(bind-lib libapr apr_pcalloc_debug [i8*,apr_pool_t*,size_t,i8*]*)


;; /*
;;  * Pool Properties
;;  */

;; /**
;;  * Set the function to be called when an allocation failure occurs.
;;  * @remark If the program wants APR to exit on a memory allocation error,
;;  *      then this function can be called to set the callback to use (for
;;  *      performing cleanup and then exiting). If this function is not called,
;;  *      then APR will return an error and expect the calling program to
;;  *      deal with the error accordingly.
;;  */
(bind-lib libapr apr_pool_abort_set [void,apr_abortfunc_t,apr_pool_t*]*)

;; /**
;;  * Get the abort function associated with the specified pool.
;;  * @param pool The pool for retrieving the abort function.
;;  * @return The abort function for the given pool.
;;  */
(bind-lib libapr apr_pool_abort_get [apr_abortfunc_t,apr_pool_t*]*)

;; /**
;;  * Get the parent pool of the specified pool.
;;  * @param pool The pool for retrieving the parent pool.
;;  * @return The parent of the given pool.
;;  */
(bind-lib libapr apr_pool_parent_get [apr_pool_t*,apr_pool_t*]*)

;; /**
;;  * Determine if pool a is an ancestor of pool b.
;;  * @param a The pool to search
;;  * @param b The pool to search for
;;  * @return True if a is an ancestor of b, NULL is considered an ancestor
;;  *         of all pools.
;;  * @remark if compiled with APR_POOL_DEBUG, this function will also
;;  * return true if A is a pool which has been guaranteed by the caller
;;  * (using apr_pool_join) to have a lifetime at least as long as some
;;  * ancestor of pool B.
;;  */
(bind-lib libapr apr_pool_is_ancestor [i32,apr_pool_t*,apr_pool_t*]*)

;; /**
;;  * Tag a pool (give it a name)
;;  * @param pool The pool to tag
;;  * @param tag  The tag
;;  */
(bind-lib libapr apr_pool_tag [void,apr_pool_t*,i8*]*)


;; /*
;;  * User data management
;;  */

;; /**
;;  * Set the data associated with the current pool
;;  * @param data The user data associated with the pool.
;;  * @param key The key to use for association
;;  * @param cleanup The cleanup program to use to cleanup the data (NULL if none)
;;  * @param pool The current pool
;;  * @warning The data to be attached to the pool should have a life span
;;  *          at least as long as the pool it is being attached to.
;;  *
;;  *      Users of APR must take EXTREME care when choosing a key to
;;  *      use for their data.  It is possible to accidentally overwrite
;;  *      data by choosing a key that another part of the program is using.
;;  *      Therefore it is advised that steps are taken to ensure that unique
;;  *      keys are used for all of the userdata objects in a particular pool
;;  *      (the same key in two different pools or a pool and one of its
;;  *      subpools is okay) at all times.  Careful namespace prefixing of
;;  *      key names is a typical way to help ensure this uniqueness.
;;  *
;;  */
(bind-lib libapr apr_pool_userdata_set [apr_status_t,i8*,i8*,[apr_status_t,i8*]*,apr_pool_t*]*)

;; /**
;;  * Set the data associated with the current pool
;;  * @param data The user data associated with the pool.
;;  * @param key The key to use for association
;;  * @param cleanup The cleanup program to use to cleanup the data (NULL if none)
;;  * @param pool The current pool
;;  * @note same as apr_pool_userdata_set(), except that this version doesn't
;;  *       make a copy of the key (this function is useful, for example, when
;;  *       the key is a string literal)
;;  * @warning This should NOT be used if the key could change addresses by
;;  *       any means between the apr_pool_userdata_setn() call and a
;;  *       subsequent apr_pool_userdata_get() on that key, such as if a
;;  *       static string is used as a userdata key in a DSO and the DSO could
;;  *       be unloaded and reloaded between the _setn() and the _get().  You
;;  *       MUST use apr_pool_userdata_set() in such cases.
;;  * @warning More generally, the key and the data to be attached to the
;;  *       pool should have a life span at least as long as the pool itself.
;;  *
;;  */
(bind-lib libapr apr_pool_userdata_setn [apr_status_t,i8*,i8*,[apr_status_t,i8*]*,apr_pool_t*]*)

;; /**
;;  * Return the data associated with the current pool.
;;  * @param data The user data associated with the pool.
;;  * @param key The key for the data to retrieve
;;  * @param pool The current pool.
;;  */
(bind-lib libapr apr_pool_userdata_get [apr_status_t,i8**,i8*,apr_pool_t*]*)

;; /**
;;  * @defgroup PoolCleanup  Pool Cleanup Functions
;;  *
;;  * Cleanups are performed in the reverse order they were registered.  That is:
;;  * Last In, First Out.  A cleanup function can safely allocate memory from
;;  * the pool that is being cleaned up. It can also safely register additional
;;  * cleanups which will be run LIFO, directly after the current cleanup
;;  * terminates.  Cleanups have to take caution in calling functions that
;;  * create subpools. Subpools, created during cleanup will NOT automatically
;;  * be cleaned up.  In other words, cleanups are to clean up after themselves.
;;  *
;;  * @{
;;  */

;; /**
;;  * Register a function to be called when a pool is cleared or destroyed
;;  * @param p The pool to register the cleanup with
;;  * @param data The data to pass to the cleanup function.
;;  * @param plain_cleanup The function to call when the pool is cleared
;;  *                      or destroyed
;;  * @param child_cleanup The function to call when a child process is about
;;  *                      to exec - this function is called in the child, obviously!
;;  */
(bind-lib libapr apr_pool_cleanup_register [void,apr_pool_t*,i8*,[apr_status_t,i8*]*,[apr_status_t,i8*]*]*)

;; /**
;;  * Register a function to be called when a pool is cleared or destroyed.
;;  *
;;  * Unlike apr_pool_cleanup_register which registers a cleanup
;;  * that is called AFTER all subpools are destroyed, this function registers
;;  * a function that will be called before any of the subpools are destroyed.
;;  *
;;  * @param p The pool to register the cleanup with
;;  * @param data The data to pass to the cleanup function.
;;  * @param plain_cleanup The function to call when the pool is cleared
;;  *                      or destroyed
;;  */
(bind-lib libapr apr_pool_pre_cleanup_register [void,apr_pool_t*,i8*,[apr_status_t,i8*]*]*)

;; /**
;;  * Remove a previously registered cleanup function.
;;  *
;;  * The cleanup most recently registered with @a p having the same values of
;;  * @a data and @a cleanup will be removed.
;;  *
;;  * @param p The pool to remove the cleanup from
;;  * @param data The data of the registered cleanup
;;  * @param cleanup The function to remove from cleanup
;;  * @remarks For some strange reason only the plain_cleanup is handled by this
;;  *          function
;;  */
(bind-lib libapr apr_pool_cleanup_kill [void,apr_pool_t*,i8*,[apr_status_t,i8*]*]*)

;; /**
;;  * Replace the child cleanup function of a previously registered cleanup.
;;  *
;;  * The cleanup most recently registered with @a p having the same values of
;;  * @a data and @a plain_cleanup will have the registered child cleanup
;;  * function replaced with @a child_cleanup.
;;  *
;;  * @param p The pool of the registered cleanup
;;  * @param data The data of the registered cleanup
;;  * @param plain_cleanup The plain cleanup function of the registered cleanup
;;  * @param child_cleanup The function to register as the child cleanup
;;  */
(bind-lib libapr apr_pool_child_cleanup_set [void,apr_pool_t*,i8*,[apr_status_t,i8*]*,[apr_status_t,i8*]*]*)


;; /**
;;  * Run the specified cleanup function immediately and unregister it.
;;  *
;;  * The cleanup most recently registered with @a p having the same values of
;;  * @a data and @a cleanup will be removed and @a cleanup will be called
;;  * with @a data as the argument.
;;  *
;;  * @param p The pool to remove the cleanup from
;;  * @param data The data to remove from cleanup
;;  * @param cleanup The function to remove from cleanup
;;  */
(bind-lib libapr apr_pool_cleanup_run [apr_status_t,apr_pool_t*,i8*,[apr_status_t,i8*]*]*)

;; /**
;;  * An empty cleanup function.
;;  *
;;  * Passed to apr_pool_cleanup_register() when no cleanup is required.
;;  *
;;  * @param data The data to cleanup, will not be used by this function.
;;  */
(bind-lib libapr apr_pool_cleanup_null [apr_status_t,i8*]*)

;; /**
;;  * Run all registered child cleanups, in preparation for an exec()
;;  * call in a forked child -- close files, etc., but *don't* flush I/O
;;  * buffers, *don't* wait for subprocesses, and *don't* free any
;;  * memory.
;;  */
(bind-lib libapr apr_pool_cleanup_for_exec [void]*)

;; /** @} */

;; /**
;;  * @defgroup PoolDebug Pool Debugging functions.
;;  *
;;  * pools have nested lifetimes -- sub_pools are destroyed when the
;;  * parent pool is cleared.  We allow certain liberties with operations
;;  * on things such as tables (and on other structures in a more general
;;  * sense) where we allow the caller to insert values into a table which
;;  * were not allocated from the table's pool.  The table's data will
;;  * remain valid as long as all the pools from which its values are
;;  * allocated remain valid.
;;  *
;;  * For example, if B is a sub pool of A, and you build a table T in
;;  * pool B, then it's safe to insert data allocated in A or B into T
;;  * (because B lives at most as long as A does, and T is destroyed when
;;  * B is cleared/destroyed).  On the other hand, if S is a table in
;;  * pool A, it is safe to insert data allocated in A into S, but it
;;  * is *not safe* to insert data allocated from B into S... because
;;  * B can be cleared/destroyed before A is (which would leave dangling
;;  * pointers in T's data structures).
;;  *
;;  * In general we say that it is safe to insert data into a table T
;;  * if the data is allocated in any ancestor of T's pool.  This is the
;;  * basis on which the APR_POOL_DEBUG code works -- it tests these ancestor
;;  * relationships for all data inserted into tables.  APR_POOL_DEBUG also
;;  * provides tools (apr_pool_find, and apr_pool_is_ancestor) for other
;;  * folks to implement similar restrictions for their own data
;;  * structures.
;;  *
;;  * However, sometimes this ancestor requirement is inconvenient --
;;  * sometimes it's necessary to create a sub pool where the sub pool is
;;  * guaranteed to have the same lifetime as the parent pool.  This is a
;;  * guarantee implemented by the *caller*, not by the pool code.  That
;;  * is, the caller guarantees they won't destroy the sub pool
;;  * individually prior to destroying the parent pool.
;;  *
;;  * In this case the caller must call apr_pool_join() to indicate this
;;  * guarantee to the APR_POOL_DEBUG code.
;;  *
;;  * These functions are only implemented when #APR_POOL_DEBUG is set.
;;  *
;;  * @{
;;  */
;; #if APR_POOL_DEBUG || defined(DOXYGEN)
;; /**
;;  * Guarantee that a subpool has the same lifetime as the parent.
;;  * @param p The parent pool
;;  * @param sub The subpool
;;  */
;; (bind-lib libapr apr_pool_join [void,apr_pool_t*,apr_pool_t*]*)

;; /**
;;  * Find a pool from something allocated in it.
;;  * @param mem The thing allocated in the pool
;;  * @return The pool it is allocated in
;;  */
;; (bind-lib libapr apr_pool_find [apr_pool_t*,i8*]*)

;; /**
;;  * Report the number of bytes currently in the pool
;;  * @param p The pool to inspect
;;  * @param recurse Recurse/include the subpools' sizes
;;  * @return The number of bytes
;;  */
;; (bind-lib libapr apr_pool_num_bytes [size_t,apr_pool_t*,i32]*)

;; /**
;;  * Lock a pool
;;  * @param pool The pool to lock
;;  * @param flag  The flag
;;  */
;; (bind-lib libapr apr_pool_lock [void,apr_pool_t*,i32]*)

;;;;;;;;;;;;;;;;;;;;;
;; apr_file_info.h ;;
;;;;;;;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_file_info File Information
;;  * @ingroup APR
;;  * @{
;;  */

;; /* Many applications use the type member to determine the
;;  * existance of a file or initialization of the file info,
;;  * so the APR_NOFILE value must be distinct from APR_UNKFILE.
;;  */

;; /** apr_filetype_e values for the filetype member of the
;;  * apr_file_info_t structure
;;  * @warning: Not all of the filetypes below can be determined.
;;  * For example, a given platform might not correctly report
;;  * a socket descriptor as APR_SOCK if that type isn't
;;  * well-identified on that platform.  In such cases where
;;  * a filetype exists but cannot be described by the recognized
;;  * flags below, the filetype will be APR_UNKFILE.  If the
;;  * filetype member is not determined, the type will be APR_NOFILE.
;;  */


(bind-alias apr_filetype_e enum)

(bind-val APR_NOFILE apr_filetype_e 0)     ;; no file type determined
(bind-val APR_REG apr_filetype_e 1)        ;; a regular file
(bind-val APR_DIR apr_filetype_e 2)        ;; a directory
(bind-val APR_CHR apr_filetype_e 3)        ;; a character device
(bind-val APR_BLK apr_filetype_e 4)        ;; a block device
(bind-val APR_PIPE apr_filetype_e 5)       ;; a FIFO / pipe
(bind-val APR_LNK apr_filetype_e 6)        ;; a symbolic link
(bind-val APR_SOCK apr_filetype_e 7)       ;; a [unix domain] socket
(bind-val APR_UNKFILE7 apr_filetype_e 127) ;; a file of some other unknown type

;; /**
;;  * @defgroup apr_file_permissions File Permissions flags
;;  * @{
;;  */

(bind-val APR_FPROT_USETID i32 #x8000)
(bind-val APR_FPROT_UREAD i32 #x0400)
(bind-val APR_FPROT_UWRITE i32 #x0200)
(bind-val APR_FPROT_UEXECUTE i32 #x0100)

(bind-val APR_FPROT_GSETID i32 #x4000)
(bind-val APR_FPROT_GREAD i32 #x0040)
(bind-val APR_FPROT_GWRITE i32 #x0020)
(bind-val APR_FPROT_GEXECUTE i32 #x0010)

(bind-val APR_FPROT_WSTICKY i32 #x2000)
(bind-val APR_FPROT_WREAD i32 #x0004)
(bind-val APR_FPROT_WWRITE i32 #x0002)
(bind-val APR_FPROT_WEXECUTE i32 #x0001)

(bind-val APR_FPROT_OS_DEFAULT i32 #x0FFF)

;; /* additional permission flags for apr_file_copy  and apr_file_append */
(bind-val APR_FPROT_FILE_SOURCE_PERMS i32 #x1000)


;; /**
;;  * Structure for referencing directories.
;;  */
(bind-alias apr_dir_t i8)
;; /**
;;  * Structure for determining file permissions.
;;  */
(bind-alias apr_fileperms_t i32)
;; #if (defined WIN32) || (defined NETWARE)
;; /**
;;  * Structure for determining the device the file is on.
;;  */
(bind-alias apr_dev_t i32)
;; #else
;; /**
;;  * Structure for determining the device the file is on.
;;  */
;; (bind-alias apr_dev_t dev_t)
;; #endif

;; /**
;;  * @defgroup apr_file_stat Stat Functions
;;  * @{
;;  */
;; /** file info structure */

(bind-val APR_FINFO_LINK i32 #x00000001)
(bind-val APR_FINFO_MTIME i32 #x00000010)
(bind-val APR_FINFO_CTIME i32 #x00000020)
(bind-val APR_FINFO_ATIME i32 #x00000040)
(bind-val APR_FINFO_SIZE i32 #x00000100)
(bind-val APR_FINFO_CSIZE i32 #x00000200)
(bind-val APR_FINFO_DEV i32 #x00001000)
(bind-val APR_FINFO_INODE i32 #x00002000)
(bind-val APR_FINFO_NLINK i32 #x00004000)
(bind-val APR_FINFO_TYPE i32 #x00008000)
(bind-val APR_FINFO_USER i32 #x00010000)
(bind-val APR_FINFO_GROUP i32 #x00020000)
(bind-val APR_FINFO_UPROT i32 #x00100000)
(bind-val APR_FINFO_GPROT i32 #x00200000)
(bind-val APR_FINFO_WPROT i32 #x00400000)
(bind-val APR_FINFO_ICASE i32 #x01000000)
(bind-val APR_FINFO_NAME i32 #x02000000)

(bind-val APR_FINFO_MIN i32 #x00008170)
(bind-val APR_FINFO_IDENT i32 #x00003000)
(bind-val APR_FINFO_OWNER i32 #x00030000)
(bind-val APR_FINFO_PROT i32 #x00700000)
(bind-val APR_FINFO_NORM i32 #x0073b170)
(bind-val APR_FINFO_DIRENT i32 #x02000000)

;; ;; /**
;; ;;  * The file information structure.  This is analogous to the POSIX
;; ;;  * stat structure.
;; ;;  */
;; struct apr_finfo_t {
;;     ;; /** Allocates memory and closes lingering handles in the specified pool */
;;     apr_pool_t *pool;
;;     ;; /** The bitmask describing valid fields of this apr_finfo_t structure
;;     ;;  *  including all available 'wanted' fields and potentially more */
;;     i32 valid;
;;     ;; /** The access permissions of the file.  Mimics Unix access rights. */
;;     apr_fileperms_t protection;
;;     ;; /** The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,
;;     ;;  * APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.
;;     ;;  * If the type cannot be determined, the value is APR_UNKFILE.
;;     ;;  */
;;     apr_filetype_e filetype;
;;     ;; /** The user id that owns the file */
;;     apr_uid_t user;
;;     ;; /** The group id that owns the file */
;;     apr_gid_t group;
;;     ;; /** The inode of the file. */
;;     apr_ino_t inode;
;;     ;; /** The id of the device the file is on. */
;;     apr_dev_t device;
;;     ;; /** The number of hard links to the file. */
;;     i32 nlink;
;;     ;; /** The size of the file */
;;     apr_off_t size;
;;     ;; /** The storage size consumed by the file */
;;     apr_off_t csize;
;;     ;; /** The time the file was last accessed */
;;     apr_time_t atime;
;;     ;; /** The time the file was last modified */
;;     apr_time_t mtime;
;;     ;; /** The time the file was created, or the inode was last changed */
;;     apr_time_t ctime;
;;     ;; /** The pathname of the file (possibly unrooted) */
;;     const char *fname;
;;     ;; /** The file's name (no path) in filesystem case */
;;     const char *name;
;;     ;; /** Unused */
;;     struct apr_file_t *filehand;
;; };

(bind-type apr_finfo_t <apr_pool_t*,i32,apr_fileperms_t,apr_filetype_e,apr_uid_t,apr_gid_t,apr_ino_t,apr_dev_t,i32,apr_off_t,apr_off_t,apr_time_t,apr_time_t,apr_time_t,i8*,i8*,apr_file_t*>
  "file information structure - analogous to the POSIX stat structure")

(bind-func print
  "specialised print function for apr_finfo*"
  (lambda (finfo:apr_finfo_t*)
    (if (null? finfo)
        (printf "<apr_finfo 0x0>")
        (printf "<apr_finfo %p
pool               : %p
valid fields       : %d
access permissions : %d
filetype           : %d
user ID            : %d
group ID           : %d
inode              : %lld
device             : %lld
hard links         : %d
size               : %lld
csize              : %lld
atime              : %lld
mtime              : %lld
ctime              : %lld
pathname           : %s
filename           : %s
>"
                finfo
                (tref finfo 0)
                (tref finfo 1)
                (tref finfo 2)
                (tref finfo 3)
                (tref finfo 4)
                (tref finfo 5)
                (tref finfo 6)
                (tref finfo 7)
                (tref finfo 8)
                (tref finfo 9)
                (tref finfo 10)
                (tref finfo 11)
                (tref finfo 12)
                (tref finfo 13)
                (tref finfo 14)
                (tref finfo 15)))
    void))


(bind-func toString
  "specialised toString function for apr_finfo*"
  (lambda (finfo:apr_finfo_t*)
    (let ((str:i8* (salloc 256)))
      (if (null? finfo)
          (sprintf str "<apr_finfo 0x0>")
          (sprintf str "<apr_finfo %p
pool               : %p
valid fields       : %d
access permissions : %d
filetype           : %d
user ID            : %d
group ID           : %d
inode              : %lld
device             : %lld
hard links         : %d
size               : %lld
csize              : %lld
atime              : %lld
mtime              : %lld
ctime              : %lld
pathname           : %s
filename           : %s
>"
                   finfo
                   (tref finfo 0)
                   (tref finfo 1)
                   (tref finfo 2)
                   (tref finfo 3)
                   (tref finfo 4)
                   (tref finfo 5)
                   (tref finfo 6)
                   (tref finfo 7)
                   (tref finfo 8)
                   (tref finfo 9)
                   (tref finfo 10)
                   (tref finfo 11)
                   (tref finfo 12)
                   (tref finfo 13)
                   (tref finfo 14)
                   (tref finfo 15)))
      (Str str))))


;; /**
;;  * get the specified file's stats.  The file is specified by filename,
;;  * instead of using a pre-opened file.
;;  * @param finfo Where to store the information about the file, which is
;;  * never touched if the call fails.
;;  * @param fname The name of the file to stat.
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_
;;                  values
;;  * @param pool the pool to use to allocate the new file.
;;  *
;;  * @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may
;;  *       not be filled in, and you need to check the @c finfo->valid bitmask
;;  *       to verify that what you're looking for is there.
;;  */

(bind-lib libapr apr_stat [apr_status_t,apr_finfo_t*,i8*,i32,apr_pool_t*]*)

;; /** @} */
;; /**
;;  * @defgroup apr_dir Directory Manipulation Functions
;;  * @{
;;  */

;; /**
;;  * Open the specified directory.
;;  * @param new_dir The opened directory descriptor.
;;  * @param dirname The full path to the directory (use / on all systems)
;;  * @param pool The pool to use.
;;  */

(bind-lib libapr apr_dir_open [apr_status_t,apr_dir_t**,i8*,apr_pool_t*]*)

;; /**
;;  * close the specified directory.
;;  * @param thedir the directory descriptor to close.
;;  */

(bind-lib libapr apr_dir_close [apr_status_t,apr_dir_t*]*)

;; /**
;;  * Read the next entry from the specified directory.
;;  * @param finfo the file info structure and filled in by apr_dir_read
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_
;;                  values
;;  * @param thedir the directory descriptor returned from apr_dir_open
;;  * @remark No ordering is guaranteed for the entries read.
;;  *
;;  * @note If @c APR_INCOMPLETE is returned all the fields in @a finfo may
;;  *       not be filled in, and you need to check the @c finfo->valid bitmask
;;  *       to verify that what you're looking for is there. When no more
;;  *       entries are available, APR_ENOENT is returned.
;;  */

(bind-lib libapr apr_dir_read [apr_status_t,apr_finfo_t*,i32,apr_dir_t*]*)

;; /**
;;  * Rewind the directory to the first entry.
;;  * @param thedir the directory descriptor to rewind.
;;  */

(bind-lib libapr apr_dir_rewind [apr_status_t,apr_dir_t*]*)
;; /** @} */

;; /**
;;  * @defgroup apr_filepath Filepath Manipulation Functions
;;  * @{
;;  */

;; /** Cause apr_filepath_merge to fail if addpath is above rootpath
;;  * @bug in APR 0.9 and 1.x, this flag's behavior is undefined
;;  * if the rootpath is NULL or empty.  In APR 2.0 this should be
;;  * changed to imply NOTABSOLUTE if the rootpath is NULL or empty.
;;  */
(bind-val APR_FILEPATH_NOTABOVEROOT i32 #x01)

;; /** internal: Only meaningful with APR_FILEPATH_NOTABOVEROOT */
(bind-val APR_FILEPATH_SECUREROOTTEST i32 #x02)

;; /** Cause apr_filepath_merge to fail if addpath is above rootpath,
;;  * even given a rootpath /foo/bar and an addpath ../bar/bash
;;  */
(bind-val APR_FILEPATH_SECUREROOT i32 #x03)

;; /** Fail apr_filepath_merge if the merged path is relative */
(bind-val APR_FILEPATH_NOTRELATIVE i32 #x04)

;; /** Fail apr_filepath_merge if the merged path is absolute */
(bind-val APR_FILEPATH_NOTABSOLUTE i32 #x08)

;; /** Return the file system's native path format (e.g. path delimiters
;;  * of ':' on MacOS9, '\' on Win32, etc.) */
(bind-val APR_FILEPATH_NATIVE i32 #x10)

;; /** Resolve the true case of existing directories and file elements
;;  * of addpath, (resolving any aliases on Win32) and append a proper
;;  * trailing slash if a directory
;;  */
(bind-val APR_FILEPATH_TRUENAME i32 #x20)

;; /**
;;  * Extract the rootpath from the given filepath
;;  * @param rootpath the root file path returned with APR_SUCCESS or APR_EINCOMPLETE
;;  * @param filepath the pathname to parse for its root component
;;  * @param flags the desired rules to apply, from
;;  * <PRE>
;;  *      APR_FILEPATH_NATIVE    Use native path separators (e.g. '\' on Win32)
;;  *      APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
;;  * </PRE>
;;  * @param p the pool to allocate the new path string from
;;  * @remark on return, filepath points to the first non-root character in the
;;  * given filepath.  In the simplest example, given a filepath of "/foo",
;;  * returns the rootpath of "/" and filepath points at "foo".  This is far
;;  * more complex on other platforms, which will canonicalize the root form
;;  * to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also
;;  * test for the validity of that root (e.g., that a drive d:/ or network
;;  * share //machine/foovol/).
;;  * The function returns APR_ERELATIVE if filepath isn't rooted (an
;;  * error), APR_EINCOMPLETE if the root path is ambiguous (but potentially
;;  * legitimate, e.g. "/" on Windows is incomplete because it doesn't specify
;;  * the drive letter), or APR_EBADPATH if the root is simply invalid.
;;  * APR_SUCCESS is returned if filepath is an absolute path.
;;  */
(bind-lib libapr apr_filepath_root [apr_status_t,i8**,i8**,i32,apr_pool_t*]*)

;; /**
;;  * Merge additional file path onto the previously processed rootpath
;;  * @param newpath the merged paths returned
;;  * @param rootpath the root file path (NULL uses the current working path)
;;  * @param addpath the path to add to the root path
;;  * @param flags the desired APR_FILEPATH_ rules to apply when merging
;;  * @param p the pool to allocate the new path string from
;;  * @remark if the flag APR_FILEPATH_TRUENAME is given, and the addpath
;;  * contains wildcard characters ('*', '?') on platforms that don't support
;;  * such characters within filenames, the paths will be merged, but the
;;  * result code will be APR_EPATHWILD, and all further segments will not
;;  * reflect the true filenames including the wildcard and following segments.
;;  */

(bind-lib libapr apr_filepath_merge [apr_status_t,i8**,i8*,i8*,i32,apr_pool_t*]*)

;; /**
;;  * Split a search path into separate components
;;  * @param pathelts the returned components of the search path
;;  * @param liststr the search path (e.g., <tt>getenv("PATH")</tt>)
;;  * @param p the pool to allocate the array and path components from
;;  * @remark empty path components do not become part of @a pathelts.
;;  * @remark the path separator in @a liststr is system specific;
;;  * e.g., ':' on Unix, ';' on Windows, etc.
;;  */
(bind-lib libapr apr_filepath_list_split [apr_status_t,apr_array_header_t**,i8*,apr_pool_t*]*)

;; /**
;;  * Merge a list of search path components into a single search path
;;  * @param liststr the returned search path; may be NULL if @a pathelts is empty
;;  * @param pathelts the components of the search path
;;  * @param p the pool to allocate the search path from
;;  * @remark emtpy strings in the source array are ignored.
;;  * @remark the path separator in @a liststr is system specific;
;;  * e.g., ':' on Unix, ';' on Windows, etc.
;;  */
(bind-lib libapr apr_filepath_list_merge [apr_status_t,i8**,apr_array_header_t*,apr_pool_t*]*)

;; /**
;;  * Return the default file path (for relative file names)
;;  * @param path the default path string returned
;;  * @param flags optional flag APR_FILEPATH_NATIVE to retrieve the
;;  *              default file path in os-native format.
;;  * @param p the pool to allocate the default path string from
;;  */
(bind-lib libapr apr_filepath_get [apr_status_t,i8**,i32,apr_pool_t*]*)

;; /**
;;  * Set the default file path (for relative file names)
;;  * @param path the default path returned
;;  * @param p the pool to allocate any working storage
;;  */
(bind-lib libapr apr_filepath_set [apr_status_t,i8*,apr_pool_t*]*)

;; /** The FilePath character encoding is unknown */
(bind-val APR_FILEPATH_ENCODING_UNKNOWN i32 0)

;; /** The FilePath character encoding is locale-dependent */
(bind-val APR_FILEPATH_ENCODING_LOCALE i32 1)

;; /** The FilePath character encoding is UTF-8 */
(bind-val APR_FILEPATH_ENCODING_UTF8 i32 2)

;; /**
;;  * Determine the encoding used internally by the FilePath functions
;;  * @param style points to a variable which receives the encoding style flag
;;  * @param p the pool to allocate any working storage
;;  * @remark Use @c apr_os_locale_encoding and/or @c apr_os_default_encoding
;;  * to get the name of the path encoding if it's not UTF-8.
;;  */
(bind-lib libapr apr_filepath_encoding [apr_status_t,i32*,apr_pool_t*]*)

;;;;;;;;;;;;;;;;;;;
;; apr_file_io.h ;;
;;;;;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_file_io File I/O Handling Functions
;;  * @ingroup APR
;;  * @{
;;  */

;; /**
;;  * @defgroup apr_file_open_flags File Open Flags/Routines
;;  * @{
;;  */

;; /* Note to implementors: Values in the range 0x00100000--0x80000000
;;    are reserved for platform-specific values. */

(bind-val APR_FOPEN_READ i32 #x00001)
(bind-val APR_FOPEN_WRITE i32 #x00002)
(bind-val APR_FOPEN_CREATE i32 #x00004)
(bind-val APR_FOPEN_APPEND i32 #x00008)
(bind-val APR_FOPEN_TRUNCATE i32 #x00010)
                                      ;;    to 0 length */
(bind-val APR_FOPEN_BINARY i32 #x00020)
           ;;       (This flag is ignored on UNIX
           ;; because it has no meaning)*/
(bind-val APR_FOPEN_EXCL i32 #x00040)
                                      ;;    and file exists. */
(bind-val APR_FOPEN_BUFFERED i32 #x00080)
(bind-val APR_FOPEN_DELONCLOSE i32 #x00100)
(bind-val APR_FOPEN_XTHREAD i32 #x00200)
                                      ;;    the file for use across multiple
                                      ;;    threads */
(bind-val APR_FOPEN_SHARELOCK i32 #x00400)
                                      ;;    higher level locked read/write
                                      ;;    access to support writes across
                                      ;;    process/machines */
(bind-val APR_FOPEN_NOCLEANUP i32 #x00800)
           ;;                               when the file is opened. The
           ;; apr_os_file_t handle in apr_file_t
           ;; will not be closed when the pool
           ;; is destroyed. */
(bind-val APR_FOPEN_SENDFILE_ENABLED i32 #x01000)
                                           ;;   file should support
                                           ;;   apr_socket_sendfile operation */
(bind-val APR_FOPEN_LARGEFILE i32 #x04000)
                                      ;;  * large file support, see WARNING below
                                      ;;  */
(bind-val APR_FOPEN_SPARSE i32 #x08000)
                                      ;;  * sparse file support, see WARNING below
                                      ;;  */
(bind-val APR_FOPEN_NONBLOCK i32 #x40000)
                                      ;;  * non blocking file io */

;; /** @def APR_FOPEN_LARGEFILE
;;  * @warning APR_FOPEN_LARGEFILE flag only has effect on some
;;  * platforms where sizeof(apr_off_t) == 4.  Where implemented, it
;;  * allows opening and writing to a file which exceeds the size which
;;  * can be represented by apr_off_t (2 gigabytes).  When a file's size
;;  * does exceed 2Gb, apr_file_info_get() will fail with an error on the
;;  * descriptor, likewise apr_stat()/apr_lstat() will fail on the
;;  * filename.  apr_dir_read() will fail with #APR_INCOMPLETE on a
;;  * directory entry for a large file depending on the particular
;;  * APR_FINFO_* flags.  Generally, it is not recommended to use this
;;  * flag.
;;  *
;;  * @def APR_FOPEN_SPARSE
;;  * @warning APR_FOPEN_SPARSE may, depending on platform, convert a
;;  * normal file to a sparse file.  Some applications may be unable
;;  * to decipher a sparse file, so it's critical that the sparse file
;;  * flag should only be used for files accessed only by APR or other
;;  * applications known to be able to decipher them.  APR does not
;;  * guarantee that it will compress the file into sparse segments
;;  * if it was previously created and written without the sparse flag.
;;  * On platforms which do not understand, or on file systems which
;;  * cannot handle sparse files, the flag is ignored by apr_file_open().
;;  *
;;  * @def APR_FOPEN_NONBLOCK
;;  * @warning APR_FOPEN_NONBLOCK is not implemented on all platforms.
;;  * Callers should be prepared for it to fail with #APR_ENOTIMPL.
;;  */

;; /** @} */

;; /**
;;  * @defgroup apr_file_seek_flags File Seek Flags
;;  * @{
;;  */

;; /* flags for apr_file_seek */
;; /** Set the file position */
(bind-val APR_SET i32 0)
;; /** Current */
(bind-val APR_CUR i32 1)
;; /** Go to end of file */
(bind-val APR_END i32 2)
;; /** @} */

;; /**
;;  * @defgroup apr_file_attrs_set_flags File Attribute Flags
;;  * @{
;;  */

;; /* flags for apr_file_attrs_set */
(bind-val APR_FILE_ATTR_READONLY i32 #x01)
(bind-val APR_FILE_ATTR_EXECUTABLE i32 #x02)
(bind-val APR_FILE_ATTR_HIDDEN i32 #x04)
;; /** @} */

;; /**
;;  * @defgroup apr_file_writev{_full} max iovec size
;;  * @{
;;  */
(bind-alias iovec i8)
(bind-val APR_MAX_IOVEC_SIZE i32 1024)

;; /** File attributes */
(bind-alias apr_fileattrs_t i32)

;; /** Type to pass as whence argument to apr_file_seek. */
(bind-alias apr_seek_where_t i32)

;; /* File lock types/flags */
;; /**
;;  * @defgroup apr_file_lock_types File Lock Types
;;  * @{
;;  */

(bind-val APR_FLOCK_SHARED i32 1)
                                        ;;    or thread can hold a shared lock
                                        ;;    at any given time. Essentially,
                                        ;;    this is a "read lock", preventing
                                        ;;    writers from establishing an
                                        ;;    exclusive lock. */
(bind-val APR_FLOCK_EXCLUSIVE i32 2)
                                        ;;    may hold an exclusive lock at any
                                        ;;    given time. This is analogous to
                                        ;;    a "write lock". */

(bind-val APR_FLOCK_TYPEMASK i32 #x000F)
(bind-val APR_FLOCK_NONBLOCK i32 #x0010)
                                        ;;    file lock */
;; /** @} */

;; /**
;;  * Open the specified file.
;;  * @param newf The opened file descriptor.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param flag Or'ed value of:
;;  * @li #APR_FOPEN_READ           open for reading
;;  * @li #APR_FOPEN_WRITE          open for writing
;;  * @li #APR_FOPEN_CREATE         create the file if not there
;;  * @li #APR_FOPEN_APPEND         file ptr is set to end prior to all writes
;;  * @li #APR_FOPEN_TRUNCATE       set length to zero if file exists
;;  * @li #APR_FOPEN_BINARY         not a text file
;;  * @li #APR_FOPEN_BUFFERED       buffer the data.  Default is non-buffered
;;  * @li #APR_FOPEN_EXCL           return error if #APR_FOPEN_CREATE and file exists
;;  * @li #APR_FOPEN_DELONCLOSE     delete the file after closing
;;  * @li #APR_FOPEN_XTHREAD        Platform dependent tag to open the file
;;  *                               for use across multiple threads
;;  * @li #APR_FOPEN_SHARELOCK      Platform dependent support for higher
;;  *                               level locked read/write access to support
;;  *                               writes across process/machines
;;  * @li #APR_FOPEN_NOCLEANUP      Do not register a cleanup with the pool
;;  *                               passed in on the @a pool argument (see below)
;;  * @li #APR_FOPEN_SENDFILE_ENABLED  Open with appropriate platform semantics
;;  *                               for sendfile operations.  Advisory only,
;;  *                               apr_socket_sendfile does not check this flag
;;  * @li #APR_FOPEN_LARGEFILE      Platform dependent flag to enable large file
;;  *                               support, see WARNING below
;;  * @li #APR_FOPEN_SPARSE         Platform dependent flag to enable sparse file
;;  *                               support, see WARNING below
;;  * @li #APR_FOPEN_NONBLOCK       Platform dependent flag to enable
;;  *                               non blocking file io
;;  * @param perm Access permissions for file.
;;  * @param pool The pool to use.
;;  * @remark If perm is #APR_FPROT_OS_DEFAULT and the file is being created,
;;  * appropriate default permissions will be used.
;;  * @remark By default, the returned file descriptor will not be
;;  * inherited by child processes created by apr_proc_create().  This
;;  * can be changed using apr_file_inherit_set().
;;  */
(bind-lib libapr apr_file_open [apr_status_t,apr_file_t**,i8*,i32,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Close the specified file.
;;  * @param file The file descriptor to close.
;;  */
(bind-lib libapr apr_file_close [apr_status_t,apr_file_t*]*)

;; /**
;;  * Delete the specified file.
;;  * @param path The full path to the file (using / on all systems)
;;  * @param pool The pool to use.
;;  * @remark If the file is open, it won't be removed until all
;;  * instances are closed.
;;  */
(bind-lib libapr apr_file_remove [apr_status_t,i8*,apr_pool_t*]*)

;; /**
;;  * Rename the specified file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @param pool The pool to use.
;;  * @warning If a file exists at the new location, then it will be
;;  * overwritten.  Moving files or directories across devices may not be
;;  * possible.
;;  */
(bind-lib libapr apr_file_rename [apr_status_t,i8*,i8*,apr_pool_t*]*)

;; /**
;;  * Create a hard link to the specified file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @remark Both files must reside on the same device.
;;  */
(bind-lib libapr apr_file_link [apr_status_t,i8*,i8*]*)

;; /**
;;  * Copy the specified file to another file.
;;  * @param from_path The full path to the original file (using / on all systems)
;;  * @param to_path The full path to the new file (using / on all systems)
;;  * @param perms Access permissions for the new file if it is created.
;;  *     In place of the usual or'd combination of file permissions, the
;;  *     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source
;;  *     file's permissions are copied.
;;  * @param pool The pool to use.
;;  * @remark The new file does not need to exist, it will be created if required.
;;  * @warning If the new file already exists, its contents will be overwritten.
;;  */
(bind-lib libapr apr_file_copy [apr_status_t,i8*,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Append the specified file to another file.
;;  * @param from_path The full path to the source file (use / on all systems)
;;  * @param to_path The full path to the destination file (use / on all systems)
;;  * @param perms Access permissions for the destination file if it is created.
;;  *     In place of the usual or'd combination of file permissions, the
;;  *     value #APR_FPROT_FILE_SOURCE_PERMS may be given, in which case the source
;;  *     file's permissions are copied.
;;  * @param pool The pool to use.
;;  * @remark The new file does not need to exist, it will be created if required.
;;  */
(bind-lib libapr apr_file_append [apr_status_t,i8*,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Are we at the end of the file
;;  * @param fptr The apr file we are testing.
;;  * @remark Returns #APR_EOF if we are at the end of file, #APR_SUCCESS otherwise.
;;  */
(bind-lib libapr apr_file_eof [apr_status_t,apr_file_t*]*)

;; /**
;;  * Open standard error as an apr file pointer.
;;  * @param thefile The apr file to use as stderr.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark The only reason that the apr_file_open_std* functions exist
;;  * is that you may not always have a stderr/out/in on Windows.  This
;;  * is generally a problem with newer versions of Windows and services.
;;  *
;;  * @remark The other problem is that the C library functions generally work
;;  * differently on Windows and Unix.  So, by using apr_file_open_std*
;;  * functions, you can get a handle to an APR struct that works with
;;  * the APR functions which are supposed to work identically on all
;;  * platforms.
;;  */
(bind-lib libapr apr_file_open_stderr [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard output as an apr file pointer.
;;  * @param thefile The apr file to use as stdout.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_stdout [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard input as an apr file pointer.
;;  * @param thefile The apr file to use as stdin.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_stdin [apr_status_t,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * open standard error as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stderr.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stderr [apr_status_t,apr_file_t**,i32,apr_pool_t*]*)

;; /**
;;  * open standard output as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stdout.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stdout [apr_status_t,apr_file_t**,i32,apr_pool_t*]*)

;; /**
;;  * open standard input as an apr file pointer, with flags.
;;  * @param thefile The apr file to use as stdin.
;;  * @param flags The flags to open the file with. Only the
;;  *              @li #APR_FOPEN_EXCL
;;  *              @li #APR_FOPEN_BUFFERED
;;  *              @li #APR_FOPEN_XTHREAD
;;  *              @li #APR_FOPEN_SHARELOCK
;;  *              @li #APR_FOPEN_SENDFILE_ENABLED
;;  *              @li #APR_FOPEN_LARGEFILE
;;  *
;;  *              flags should be used. The #APR_FOPEN_WRITE flag will
;;  *              be set unconditionally.
;;  * @param pool The pool to allocate the file out of.
;;  *
;;  * @remark See remarks for apr_file_open_stderr().
;;  */
(bind-lib libapr apr_file_open_flags_stdin [apr_status_t,apr_file_t**,i32,apr_pool_t*]*)

;; /**
;;  * Read data from the specified file.
;;  * @param thefile The file descriptor to read from.
;;  * @param buf The buffer to store the data to.
;;  * @param nbytes On entry, the number of bytes to read; on exit, the number
;;  * of bytes read.
;;  *
;;  * @remark apr_file_read() will read up to the specified number of
;;  * bytes, but never more.  If there isn't enough data to fill that
;;  * number of bytes, all of the available data is read.  The third
;;  * argument is modified to reflect the number of bytes read.  If a
;;  * char was put back into the stream via ungetc, it will be the first
;;  * character returned.
;;  *
;;  * @remark It is not possible for both bytes to be read and an #APR_EOF
;;  * or other error to be returned.  #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_read [apr_status_t,apr_file_t*,i8*,size_t*]*)

;; /**
;;  * Write data to the specified file.
;;  * @param thefile The file descriptor to write to.
;;  * @param buf The buffer which contains the data.
;;  * @param nbytes On entry, the number of bytes to write; on exit, the number
;;  *               of bytes written.
;;  *
;;  * @remark apr_file_write() will write up to the specified number of
;;  * bytes, but never more.  If the OS cannot write that many bytes, it
;;  * will write as many as it can.  The third argument is modified to
;;  * reflect the * number of bytes written.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_write [apr_status_t,apr_file_t*,i8*,size_t*]*)

;; /**
;;  * Write data from iovec array to the specified file.
;;  * @param thefile The file descriptor to write to.
;;  * @param vec The array from which to get the data to write to the file.
;;  * @param nvec The number of elements in the struct iovec array. This must
;;  *             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function
;;  *             will fail with #APR_EINVAL.
;;  * @param nbytes The number of bytes written.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  #APR_EINTR is never returned.
;;  *
;;  * @remark apr_file_writev() is available even if the underlying
;;  * operating system doesn't provide writev().
;;  */
(bind-lib libapr apr_file_writev [apr_status_t,apr_file_t*,iovec*,size_t,size_t*]*)

;; /**
;;  * Read data from the specified file, ensuring that the buffer is filled
;;  * before returning.
;;  * @param thefile The file descriptor to read from.
;;  * @param buf The buffer to store the data to.
;;  * @param nbytes The number of bytes to read.
;;  * @param bytes_read If non-NULL, this will contain the number of bytes read.
;;  *
;;  * @remark apr_file_read_full() will read up to the specified number of
;;  * bytes, but never more.  If there isn't enough data to fill that
;;  * number of bytes, then the process/thread will block until it is
;;  * available or EOF is reached.  If a char was put back into the
;;  * stream via ungetc, it will be the first character returned.
;;  *
;;  * @remark It is possible for both bytes to be read and an error to be
;;  * returned.  And if *bytes_read is less than nbytes, an accompanying
;;  * error is _always_ returned.
;;  *
;;  * @remark #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_read_full [apr_status_t,apr_file_t*,i8*,size_t,size_t*]*)

;; /**
;;  * Write data to the specified file, ensuring that all of the data is
;;  * written before returning.
;;  * @param thefile The file descriptor to write to.
;;  * @param buf The buffer which contains the data.
;;  * @param nbytes The number of bytes to write.
;;  * @param bytes_written If non-NULL, set to the number of bytes written.
;;  *
;;  * @remark apr_file_write_full() will write up to the specified number of
;;  * bytes, but never more.  If the OS cannot write that many bytes, the
;;  * process/thread will block until they can be written. Exceptional
;;  * error such as "out of space" or "pipe closed" will terminate with
;;  * an error.
;;  *
;;  * @remark It is possible for both bytes to be written and an error to
;;  * be returned.  And if *bytes_written is less than nbytes, an
;;  * accompanying error is _always_ returned.
;;  *
;;  * @remark #APR_EINTR is never returned.
;;  */
(bind-lib libapr apr_file_write_full [apr_status_t,apr_file_t*,i8*,size_t,size_t*]*)


;; /**
;;  * Write data from iovec array to the specified file, ensuring that all of the
;;  * data is written before returning.
;;  * @param thefile The file descriptor to write to.
;;  * @param vec The array from which to get the data to write to the file.
;;  * @param nvec The number of elements in the struct iovec array. This must
;;  *             be smaller than #APR_MAX_IOVEC_SIZE.  If it isn't, the function
;;  *             will fail with #APR_EINVAL.
;;  * @param nbytes The number of bytes written.
;;  *
;;  * @remark apr_file_writev_full() is available even if the underlying
;;  * operating system doesn't provide writev().
;;  */
(bind-lib libapr apr_file_writev_full [apr_status_t,apr_file_t*,iovec*,size_t,size_t*]*)
;; /**
;;  * Write a character into the specified file.
;;  * @param ch The character to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_putc [apr_status_t,i8,apr_file_t*]*)

;; /**
;;  * Read a character from the specified file.
;;  * @param ch The character to read into
;;  * @param thefile The file descriptor to read from
;;  */
(bind-lib libapr apr_file_getc [apr_status_t,i8*,apr_file_t*]*)

;; /**
;;  * Put a character back onto a specified stream.
;;  * @param ch The character to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_ungetc [apr_status_t,i8,apr_file_t*]*)

;; /**
;;  * Read a line from the specified file
;;  * @param str The buffer to store the string in.
;;  * @param len The length of the string
;;  * @param thefile The file descriptor to read from
;;  * @remark The buffer will be NUL-terminated if any characters are stored.
;;  *         The newline at the end of the line will not be stripped.
;;  */
(bind-lib libapr apr_file_gets [apr_status_t,i8*,i32,apr_file_t*]*)

;; /**
;;  * Write the string into the specified file.
;;  * @param str The string to write.
;;  * @param thefile The file descriptor to write to
;;  */
(bind-lib libapr apr_file_puts [apr_status_t,i8*,apr_file_t*]*)

;; /**
;;  * Flush the file's buffer.
;;  * @param thefile The file descriptor to flush
;;  */
(bind-lib libapr apr_file_flush [apr_status_t,apr_file_t*]*)

;; /**
;;  * Transfer all file modified data and metadata to disk.
;;  * @param thefile The file descriptor to sync
;;  */
(bind-lib libapr apr_file_sync [apr_status_t,apr_file_t*]*)

;; /**
;;  * Transfer all file modified data to disk.
;;  * @param thefile The file descriptor to sync
;;  */
(bind-lib libapr apr_file_datasync [apr_status_t,apr_file_t*]*)

;; /**
;;  * Duplicate the specified file descriptor.
;;  * @param new_file The structure to duplicate into.
;;  * @param old_file The file to duplicate.
;;  * @param p The pool to use for the new file.
;;  * @remark *new_file must point to a valid apr_file_t, or point to NULL.
;;  */

(bind-lib libapr apr_file_dup [apr_status_t,apr_file_t**,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Duplicate the specified file descriptor and close the original
;;  * @param new_file The old file that is to be closed and reused
;;  * @param old_file The file to duplicate
;;  * @param p        The pool to use for the new file
;;  *
;;  * @remark new_file MUST point at a valid apr_file_t. It cannot be NULL.
;;  */
(bind-lib libapr apr_file_dup2 [apr_status_t,apr_file_t*,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Move the specified file descriptor to a new pool
;;  * @param new_file Pointer in which to return the new apr_file_t
;;  * @param old_file The file to move
;;  * @param p        The pool to which the descriptor is to be moved
;;  * @remark Unlike apr_file_dup2(), this function doesn't do an
;;  *         OS dup() operation on the underlying descriptor; it just
;;  *         moves the descriptor's apr_file_t wrapper to a new pool.
;;  * @remark The new pool need not be an ancestor of old_file's pool.
;;  * @remark After calling this function, old_file may not be used
;;  */
(bind-lib libapr apr_file_setaside [apr_status_t,apr_file_t**,apr_file_t*,apr_pool_t*]*)

;; /**
;;  * Give the specified apr file handle a new buffer
;;  * @param thefile  The file handle that is to be modified
;;  * @param buffer   The buffer
;;  * @param bufsize  The size of the buffer
;;  * @remark It is possible to add a buffer to previously unbuffered
;;  *         file handles, the #APR_FOPEN_BUFFERED flag will be added to
;;  *         the file handle's flags. Likewise, with buffer=NULL and
;;  *         bufsize=0 arguments it is possible to make a previously
;;  *         buffered file handle unbuffered.
;;  */
(bind-lib libapr apr_file_buffer_set [apr_status_t,apr_file_t*,i8*,size_t]*)

;; /**
;;  * Get the size of any buffer for the specified apr file handle
;;  * @param thefile  The file handle
;;  */
(bind-lib libapr apr_file_buffer_size_get [size_t,apr_file_t*]*)

;; /**
;;  * Move the read/write file offset to a specified byte within a file.
;;  * @param thefile The file descriptor
;;  * @param where How to move the pointer, one of:
;;  *              @li #APR_SET  --  set the offset to offset
;;  *              @li #APR_CUR  --  add the offset to the current position
;;  *              @li #APR_END  --  add the offset to the current file size
;;  * @param offset The offset to move the pointer to.
;;  * @remark The third argument is modified to be the offset the pointer
;;           was actually moved to.
;;  */
(bind-lib libapr apr_file_seek [apr_status_t,apr_file_t*,apr_seek_where_t,apr_off_t*]*)

;; /**
;;  * Create an anonymous pipe.
;;  * @param in The newly created pipe's file for reading.
;;  * @param out The newly created pipe's file for writing.
;;  * @param pool The pool to operate on.
;;  * @remark By default, the returned file descriptors will be inherited
;;  * by child processes created using apr_proc_create().  This can be
;;  * changed using apr_file_inherit_unset().
;;  * @bug  Some platforms cannot toggle between blocking and nonblocking,
;;  * and when passing a pipe as a standard handle to an application which
;;  * does not expect it, a non-blocking stream will fluxor the client app.
;;  * @deprecated @see apr_file_pipe_create_ex()
;;  */
(bind-lib libapr apr_file_pipe_create [apr_status_t,apr_file_t**,apr_file_t**,apr_pool_t*]*)

;; /**
;;  * Create an anonymous pipe which portably supports async timeout options.
;;  * @param in The newly created pipe's file for reading.
;;  * @param out The newly created pipe's file for writing.
;;  * @param blocking one of these values defined in apr_thread_proc.h;
;;  *                 @li #APR_FULL_BLOCK
;;  *                 @li #APR_READ_BLOCK
;;  *                 @li #APR_WRITE_BLOCK
;;  *                 @li #APR_FULL_NONBLOCK
;;  * @param pool The pool to operate on.
;;  * @remark By default, the returned file descriptors will be inherited
;;  * by child processes created using apr_proc_create().  This can be
;;  * changed using apr_file_inherit_unset().
;;  * @remark Some platforms cannot toggle between blocking and nonblocking,
;;  * and when passing a pipe as a standard handle to an application which
;;  * does not expect it, a non-blocking stream will fluxor the client app.
;;  * Use this function rather than apr_file_pipe_create() to create pipes
;;  * where one or both ends require non-blocking semantics.
;;  */
(bind-lib libapr apr_file_pipe_create_ex [apr_status_t,apr_file_t**,apr_file_t**,i32,apr_pool_t*]*)

;; /**
;;  * Create a named pipe.
;;  * @param filename The filename of the named pipe
;;  * @param perm The permissions for the newly created pipe.
;;  * @param pool The pool to operate on.
;;  */
(bind-lib libapr apr_file_namedpipe_create [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Get the timeout value for a pipe or manipulate the blocking state.
;;  * @param thepipe The pipe we are getting a timeout for.
;;  * @param timeout The current timeout value in microseconds.
;;  */
(bind-lib libapr apr_file_pipe_timeout_get [apr_status_t,apr_file_t*,apr_interval_time_t*]*)

;; /**
;;  * Set the timeout value for a pipe or manipulate the blocking state.
;;  * @param thepipe The pipe we are setting a timeout on.
;;  * @param timeout The timeout value in microseconds.  Values < 0 mean wait
;;  *        forever, 0 means do not wait at all.
;;  */
(bind-lib libapr apr_file_pipe_timeout_set [apr_status_t,apr_file_t*,apr_interval_time_t]*)

;; /** file (un)locking functions. */

;; /**
;;  * Establish a lock on the specified, open file. The lock may be advisory
;;  * or mandatory, at the discretion of the platform. The lock applies to
;;  * the file as a whole, rather than a specific range. Locks are established
;;  * on a per-thread/process basis; a second lock by the same thread will not
;;  * block.
;;  * @param thefile The file to lock.
;;  * @param type The type of lock to establish on the file.
;;  */
(bind-lib libapr apr_file_lock [apr_status_t,apr_file_t*,i32]*)

;; /**
;;  * Remove any outstanding locks on the file.
;;  * @param thefile The file to unlock.
;;  */
(bind-lib libapr apr_file_unlock [apr_status_t,apr_file_t*]*)

;; /**accessor and general file_io functions. */

;; /**
;;  * return the file name of the current file.
;;  * @param new_path The path of the file.
;;  * @param thefile The currently open file.
;;  */

(bind-lib libapr apr_file_name_get [apr_status_t,i8**,apr_file_t*]*)

;; /**
;;  * Return the data associated with the current file.
;;  * @param data The user data associated with the file.
;;  * @param key The key to use for retrieving data associated with this file.
;;  * @param file The currently open file.
;;  */

(bind-lib libapr apr_file_data_get [apr_status_t,i8**,i8*,apr_file_t*]*)

;; /**
;;  * Set the data associated with the current file.
;;  * @param file The currently open file.
;;  * @param data The user data to associate with the file.
;;  * @param key The key to use for associating data with the file.
;;  * @param cleanup The cleanup routine to use when the file is destroyed.
;;  */

(bind-lib libapr apr_file_data_set [apr_status_t,apr_file_t*,i8*,i8*,apr_status_t*]*)

;; /**
;;  * set the specified file's permission bits.
;;  * @param fname The file (name) to apply the permissions to.
;;  * @param perms The permission bits to apply to the file.
;;  *
;;  * @warning Some platforms may not be able to apply all of the
;;  * available permission bits; #APR_INCOMPLETE will be returned if some
;;  * permissions are specified which could not be set.
;;  *
;;  * @warning Platforms which do not implement this feature will return
;;  * #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_perms_set [apr_status_t,i8*,apr_fileperms_t]*)

;; /**
;;  * Set attributes of the specified file.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param attributes Or'd combination of
;;  *            @li #APR_FILE_ATTR_READONLY   - make the file readonly
;;  *            @li #APR_FILE_ATTR_EXECUTABLE - make the file executable
;;  *            @li #APR_FILE_ATTR_HIDDEN     - make the file hidden
;;  * @param attr_mask Mask of valid bits in attributes.
;;  * @param pool the pool to use.
;;  * @remark This function should be used in preference to explicit manipulation
;;  *      of the file permissions, because the operations to provide these
;;  *      attributes are platform specific and may involve more than simply
;;  *      setting permission bits.
;;  * @warning Platforms which do not implement this feature will return
;;  *      #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_attrs_set [apr_status_t,i8*,apr_fileattrs_t,apr_fileattrs_t,apr_pool_t*]*)

;; /**
;;  * Set the mtime of the specified file.
;;  * @param fname The full path to the file (using / on all systems)
;;  * @param mtime The mtime to apply to the file.
;;  * @param pool The pool to use.
;;  * @warning Platforms which do not implement this feature will return
;;  *      #APR_ENOTIMPL.
;;  */
(bind-lib libapr apr_file_mtime_set [apr_status_t,i8*,apr_time_t,apr_pool_t*]*)

;; /**
;;  * Create a new directory on the file system.
;;  * @param path the path for the directory to be created. (use / on all systems)
;;  * @param perm Permissions for the new directory.
;;  * @param pool the pool to use.
;;  */

(bind-lib libapr apr_dir_make [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /** Creates a new directory on the file system, but behaves like
;;  * 'mkdir -p'. Creates intermediate directories as required. No error
;;  * will be reported if PATH already exists.
;;  * @param path the path for the directory to be created. (use / on all systems)
;;  * @param perm Permissions for the new directory.
;;  * @param pool the pool to use.
;;  */
(bind-lib libapr apr_dir_make_recursive [apr_status_t,i8*,apr_fileperms_t,apr_pool_t*]*)

;; /**
;;  * Remove directory from the file system.
;;  * @param path the path for the directory to be removed. (use / on all systems)
;;  * @param pool the pool to use.
;;  * @remark Removing a directory which is in-use (e.g., the current working
;;  * directory, or during apr_dir_read, or with an open file) is not portable.
;;  */

(bind-lib libapr apr_dir_remove [apr_status_t,i8*,apr_pool_t*]*)

;; /**
;;  * get the specified file's stats.
;;  * @param finfo Where to store the information about the file.
;;  * @param wanted The desired apr_finfo_t fields, as a bit flag of APR_FINFO_* values
;;  * @param thefile The file to get information about.
;;  */

(bind-lib libapr apr_file_info_get [apr_status_t,apr_finfo_t*,i32,apr_file_t*]*)


;; /**
;;  * Truncate the file's length to the specified offset
;;  * @param fp The file to truncate
;;  * @param offset The offset to truncate to.
;;  * @remark The read/write file offset is repositioned to offset.
;;  */
(bind-lib libapr apr_file_trunc [apr_status_t,apr_file_t*,apr_off_t]*)

;; /**
;;  * Retrieve the flags that were passed into apr_file_open()
;;  * when the file was opened.
;;  * @return i32 the flags
;;  */
(bind-lib libapr apr_file_flags_get [i32,apr_file_t*]*)

;; /**
;;  * Get the pool used by the file.
;;  */
;; APR_POOL_DECLARE_ACCESSOR(file);

;; /**
;;  * Set a file to be inherited by child processes.
;;  *
;;  */
;; APR_DECLARE_INHERIT_SET(file);

;; /**
;;  * Unset a file from being inherited by child processes.
;;  */
;; APR_DECLARE_INHERIT_UNSET(file);

;; /**
;;  * Open a temporary file
;;  * @param fp The apr file to use as a temporary file.
;;  * @param templ The template to use when creating a temp file.
;;  * @param flags The flags to open the file with. If this is zero,
;;  *              the file is opened with
;;  *              #APR_FOPEN_CREATE | #APR_FOPEN_READ | #APR_FOPEN_WRITE |
;;  *              #APR_FOPEN_EXCL | #APR_FOPEN_DELONCLOSE
;;  * @param p The pool to allocate the file out of.
;;  * @remark
;;  * This function  generates  a unique temporary file name from template.
;;  * The last six characters of template must be XXXXXX and these are replaced
;;  * with a string that makes the filename unique. Since it will  be  modified,
;;  * template must not be a string constant, but should be declared as a character
;;  * array.
;;  *
;;  */
(bind-lib libapr apr_file_mktemp [apr_status_t,apr_file_t**,i8*,i32,apr_pool_t*]*)


;; /**
;;  * Find an existing directory suitable as a temporary storage location.
;;  * @param temp_dir The temp directory.
;;  * @param p The pool to use for any necessary allocations.
;;  * @remark
;;  * This function uses an algorithm to search for a directory that an
;;  * an application can use for temporary storage.
;;  *
;;  */
(bind-lib libapr apr_temp_dir_get [apr_status_t,i8**,apr_pool_t*]*)

;;;;;;;;;;;;;;;
;; apr_env.h ;;
;;;;;;;;;;;;;;;

;; /**
;;  * @defgroup apr_env Functions for manipulating the environment
;;  * @ingroup APR
;;  * @{
;;  */

;; /**
;;  * Get the value of an environment variable
;;  * @param value the returned value, allocated from @a pool
;;  * @param envvar the name of the environment variable
;;  * @param pool where to allocate @a value and any temporary storage from
;;  */
(bind-lib libapr apr_env_get [apr_status_t,i8**,i8*,apr_pool_t*]*)

;; /**
;;  * Set the value of an environment variable
;;  * @param envvar the name of the environment variable
;;  * @param value the value to set
;;  * @param pool where to allocate temporary storage from
;;  */
(bind-lib libapr apr_env_set [apr_status_t,i8*,i8*,apr_pool_t*]*)

;; /**
;;  * Delete a variable from the environment
;;  * @param envvar the name of the environment variable
;;  * @param pool where to allocate temporary storage from
;;  */
(bind-lib libapr apr_env_delete [apr_status_t,i8*,apr_pool_t*]*)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; xtlang helper functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; this is just a scheme wrapper
(bind-func apr_init
  (lambda ()
    (apr_initialize)))

;; in apr.h, this is actually a C preprocessor macro
(bind-func apr_pool_create
  (lambda ()
    (let ((pool:apr_pool_t** (salloc)))
      (apr_pool_create_ex pool null null null)
      (pref pool 0))))

(bind-func apr_pool_create
  (lambda (parent)
    (let ((pool:apr_pool_t** (salloc)))
      (apr_pool_create_ex pool parent null null)
      (pref pool 0))))

(impc:aot:do-at-runtime (apr_init))

(impc:aot:insert-footer "xtmapr")
(define *xtmlib-apr-loaded* #t)
