;; vert shader
(define passthrough-vert
"// VERTEX SHADER
// #version 330

out vec2 TexCoord;

void main() {
   // pass through texture coordinate
   //TexCoord =  gl_TextureMatrix[0].st * gl_MultiTexCoord0.st;
   TexCoord = gl_MultiTexCoord0.st;
   gl_FrontColor = gl_Color;
   //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; //this same as line below
   gl_Position = ftransform();
}")


;; frag shader
(define passthrough-frag
"//  FRAGMENT SHADER
// #version 330
#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

in vec2 TexCoord;

out vec4 xtmColour

void main() {
   xtmColour = texture2DRect(tex1,TexCoord);
}")


;; frag shader
(define greyscale-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

in vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(vec3(grey),alpha);
}")


;; sepia
(define sepia-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

in vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   float grey = dot(texture2DRect(tex1,TexCoord).rgb, vec3(0.299, 0.587, 0.114));
   gl_FragColor = vec4(grey*vec3(1.2,1.0,0.8),alpha);
}")


(define invert-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;

in vec2 TexCoord;

void main() {
   float alpha = texture2DRect(tex1,TexCoord).a;
   vec4 colour = texture2DRect(tex1,TexCoord);
   gl_FragColor = vec4(1.0 - colour.rgb,alpha);
}")


(define gaussian-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
   vec4 sample[25];
   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
   }

   gl_FragColor = ((1.0  * (sample[0] + sample[4]  + sample[20] + sample[24])) +
             (4.0  * (sample[1] + sample[3]  + sample[5]  + sample[9] + sample[15] + sample[19] + sample[21] + sample[23])) +
             (7.0  * (sample[2] + sample[10] + sample[14] + sample[22])) +
             (16.0 * (sample[6] + sample[8]  + sample[16] + sample[18])) +
             (26.0 * (sample[7] + sample[11] + sample[13] + sample[17])) +
             (41.0 * sample[12])
             ) / 273.0;
   //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
}")


;;  Blur (median filter)
(define blur-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
   gl_FragColor = vec4(0.0);

   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      gl_FragColor += texture2DRect(tex1, TexCoord + texoffset[i]);
   }

   gl_FragColor /= 25.0;
}")


;;  sharpen
(define sharpen-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
    vec4 sample[25];

    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 25.0 * sample[12];

    for (int i = 0; i < 25; i++)
    {
       if (i != 12)
          gl_FragColor -= sample[i];
    }
}")

(define dilate-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
   vec4 sample[25];
   vec4 maxValue = vec4(0.0);

   for (int i = 0; i < 25; i++)
   {
      // Sample a grid around and including our texel
      sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);

      // Keep the maximum value
      maxValue = max(sample[i], maxValue);
   }

   gl_FragColor = maxValue;
}")


(define erode-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
    vec4 sample[25];
    vec4 minValue = vec4(1.0);

    for (int i = 0; i < 25; i++)
    {
        // Sample a grid around and including our texel
        sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);

        // Keep the minimum value
        minValue = min(sample[i], minValue);
    }
    gl_FragColor = minValue;
}")


(define edge-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex1;
uniform float     time;
uniform vec2      texoffset[25];

in vec2 TexCoord;

void main() {
    vec4 sample[25];

    for (int i = 0; i < 25; i++)
    {
       // Sample a grid around and including our texel
       sample[i] = texture2DRect(tex1, TexCoord + texoffset[i]);
    }

    gl_FragColor = 24.0 * sample[12];

    for (int i = 0; i < 25; i++)
    {
  if (i != 12)
     gl_FragColor -= sample[i];
    }
}")


(define blend-frag
"//  FRAGMENT SHADER
// #version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect baseBuf;
uniform sampler2DRect blendBuf;
uniform float       time;
uniform float       opacity;

in vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(baseBuf, TexCoord);
    vec4 blend = texture2DRect(blendBuf, TexCoord);

    vec4 result = blend + base;
         result = clamp(result, 0.0, 1.0);

    gl_FragColor = mix(base, result, opacity);
}")


;; vert shader
(define particles-vert
"// VERTEX SHADER
// GLSL 1.2 compatible


in vec2 myVertex;
in vec4 myColour;
in float mySize;
in vec2 myVelocity;
in float myState;

void main() {
   gl_PointSize = mySize;
   if(myState > 0.0) {
     gl_FrontColor = myColour;
   }else{
     gl_FrontColor = vec4(0.0,0.0,0.0,0.0);
   }
   gl_Position = gl_ProjectionMatrix * gl_ModelViewMatrix * vec4(myVertex.xy,0.0,1.0);
   //TexCoord = gl_MultiTexCoord0.st;
}")

(define particles-frag
"//  FRAGMENT SHADER
#version 330

#extension GL_ARB_texture_rectangle : disable

uniform sampler2D tex1;

in vec2 TexCoord;

void main() {
   gl_FragColor = texture(tex1,gl_PointCoord)*gl_Color;
   //gl_FragColor = gl_Color;
}")


(define green-frag
"//  FRAGMENT SHADER
#version 330

#extension GL_ARB_texture_rectangle : enable

uniform sampler2DRect tex_back;
uniform sampler2DRect tex_front;
uniform vec4 color;
uniform float width;
uniform float height;
uniform float scale_front;
uniform int flipx;
uniform int flipy;

in vec2 TexCoord;

void main() {
    vec4 base = texture2DRect(tex_back, TexCoord);
    float x = (flipx==0) ? TexCoord.x : width-TexCoord.x;
    float y = (flipy==0) ? TexCoord.y : height-TexCoord.y;
    vec4 blend = texture2DRect(tex_front, vec2(x*scale_front,y*scale_front));

    if(color == blend) {
      gl_FragColor = base;
    }else{
      gl_FragColor = blend;
    }
}")


;; (define dof-frag
;;   "
;; #version 330

;; #extension GL_ARB_texture_rectangle : enable

;; uniform sampler2DRect dBuf;
;; uniform sampler2DRect cBuf;
;; //uniform vec2 frameBufSize;
;; uniform float blur;
;; uniform float fp;  // focal point
;; uniform int show_depth;
;; uniform float dfact; // depth factor (shorten or make longer)
;; uniform float near;
;; uniform float far;

;; in vec2 TexCoord;

;; // const float near = 0.1;
;; // const float far = 1000.0;
;; const vec2 frameBufSize = vec2(1.0,1.0);

;; vec4 blurKawase( const sampler2DRect tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
;;  // Function assumes that tex is using bilinear hardware filtering

;;  vec2 dUV = (iteration + 0.5) / texSize;

;;  vec4 col = texture2DRect( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
;;  col += texture2DRect( tex, texCoord + dUV );            // Top right
;;  col += texture2DRect( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
;;  col += texture2DRect( tex, texCoord - dUV );            // Bottom left

;;  return col * 0.25;
;; }

;; void main( void ) {
;;         // get z depth from dBuf tex
;;  float depth = texture2DRect(dBuf,TexCoord).x;

;;         // scale depth buffer
;;         depth *= far-near;
;;         depth = (far+near)-depth;
;;         depth = abs(depth - fp); // fp focal point

;;         // show_depth is true display depth buffer
;;         if (show_depth == 1) {
;;           gl_FragColor = vec4(depth,depth,depth,1.0);
;;         } else { // else apply depth blur
;;           gl_FragColor = blurKawase( cBuf, TexCoord, frameBufSize, depth * blur);
;;         }
;; }
;; ")


(define light-vert
  "
#version 330

out vec3 N, L, E, V;
out float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  gl_Position = ModelViewProjectionMatrix * gl_Vertex;
  vec4 vPosition = ModelViewMatrix * gl_Vertex;
  //gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix * gl_Vertex;
  //vec4 vPosition = ViewMatrix * ModelMatrix * gl_Vertex;
  N = NormalMatrix * gl_Normal; //normal
  L = (LightPos - (ModelMatrix * gl_Vertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
}
")

(define light-frag
  "
#version 330

in vec3 N, L, E, V;
in float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  vec4 Color = vec4(0.0,0.0,0.0,0.0);

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  gl_FragColor = vec4((ambient + diffuse + specular).xyz,1.0);
}
")

(define simple-vert
  "
#version 330

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

void main() {
   gl_Position = ModelViewProjectionMatrix * gl_Vertex;
}
")

(define simple-vert-xtm
  "
#version 330

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

void main() {
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define simple-bone-vert-xtm
  "
#version 330

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 Bone[20];

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 4) in vec4 xtmBoneIndexes;
layout (location = 5) in vec4 xtmBoneWeights;
layout (location = 6) in int xtmActiveBones;

void main() {
   vec4 newVertex;
   vec4 newNormal;
   int index;
   if(1 > 0) { //xtmActiveBones > 3) {
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
     index=int(xtmBoneIndexes.z);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.z;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.z;
     index=int(xtmBoneIndexes.w);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.w;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.w;
   }else if(xtmActiveBones > 2){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
     index=int(xtmBoneIndexes.z);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.z;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.z;
   }else if(xtmActiveBones > 1){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
   }else if(xtmActiveBones > 0){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
   } else {
     newVertex = xtmVertex;
     newNormal = vec4(xtmNormal, 0.0);
   }
   gl_Position = ModelViewProjectionMatrix * newVertex;
}
")

(define simple-frag
  "
#version 330

out vec4 xtmColour;

void main() {
   xtmColour = vec4(1.0,0.0,0.0,1.0);
}
")

(define quad-vert
  "
#version 330

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

out vec2 UVCoord;

void main() {
   UVCoord = xtmUVW.st;
   gl_Position = ModelViewProjectionMatrix * xtmVertex;
}
")

(define quad-frag
  "
#version 330

uniform sampler2D tex1;
in vec2 UVCoord;
out vec4 xtmColour;

void main() {
   xtmColour = texture(tex1,UVCoord);
}
")

(define light-and-shade-vert-xtm
  "
// #version 120

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

out vec3 N, L, E, V;
out float D;

uniform vec4 LightPos;
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix;

out vec4 lightVertexPosition;
out vec3 UVWCoord;
out vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  L = (LightPos - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos.w == 0.0) L = LightPos.xyz; // i.e. if LightPos is already a direction vector
  D = length(L); // distance from source to light
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColour;
  lightVertexPosition = LightModelViewProjectionMatrix * xtmVertex;
}
")


(define light-and-shade-frag
  "
#version 330

in vec3 N, L, E, V;
in float D;

uniform vec4 LightAmbient;
uniform vec4 LightDiffuse;
uniform vec4 LightSpecular;
uniform float ConstantAttenuation;
uniform float LinearAttenuation;
uniform float QuadraticAttenuation;
uniform float SpotAngle;
uniform vec4 SpotDir;
uniform float SpotExponent;
uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition;
in vec3 UVWCoord;
in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 LL = normalize(L); // light vector
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  attenuation = 1.0 / (ConstantAttenuation + (LinearAttenuation * D) + (QuadraticAttenuation * D * D));

  spotDot = dot(-LL, normalize(SpotDir.xyz));

  if(spotDot < SpotAngle)
    spotAttenuation = 0.0;

else
    spotAttenuation = pow(spotDot, SpotExponent);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient * MaterialAmbient * attenuation;
  diffuse = LightDiffuse * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition;
  lightVertexPosition2 /= lightVertexPosition2.w;

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,lightVertexPosition2.xy+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
     vec4 texcolor = LightDiffuse * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
     xtmColour = vec4((texcolor.xyz*shadowValue),1.0);
  } else {
     xtmColour = vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }
}
")


(define xtmvert-xtm
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
out vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;
  for(int i=0; j<numlights; i++, j+=1.0) {
    L[i] = (LightPos[i] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
    if(LightPos[i].w == 0.0) L[i] = LightPos[i].xyz; // i.e. if LightPos is already a direction vector
    D[i] = length(L[i]);
    lightVertexPosition[i] = LightModelViewProjectionMatrix[i] * xtmVertex;
  }
  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  Color = xtmColour;
}
")


;; (define xtmfrag
;;   "
;; #version 330

;; in vec3 N, E, V;
;; in vec3 L[10];
;; in float D[10];

;; uniform vec4 LightAmbient[10];
;; uniform vec4 LightDiffuse[10];
;; uniform vec4 LightSpecular[10];
;; uniform float ConstantAttenuation[10];
;; uniform float LinearAttenuation[10];
;; uniform float QuadraticAttenuation[10];
;; uniform float SpotAngle[10];
;; uniform vec4 SpotDir[10];
;; uniform float SpotExponent[10];

;; uniform float numlights;

;; uniform vec4 CameraDir;
;; uniform float MaterialShininess;
;; uniform vec4 MaterialAmbient;
;; uniform vec4 MaterialDiffuse;
;; uniform vec4 MaterialSpecular;

;; uniform mat4 ModelMatrix;
;; uniform mat4 ViewMatrix;
;; uniform mat4 ProjectionMatrix;
;; uniform mat3 NormalMatrix;
;; uniform mat4 ModelViewMatrix;
;; uniform mat4 ModelViewProjectionMatrix;

;; uniform sampler2D shadowMap;
;; uniform sampler2D tex1;
;; uniform float IsTextured;

;; in vec4 lightVertexPosition[10];
;; in vec3 UVWCoord;
;; in vec4 Color;

;; out vec4 xtmColour;

;; void main()
;; {
;;   vec4 outcolor = vec4(0.0);
;;   float j = 0.5;
;;   vec4 ambient,diffuse,specular;
;;   vec3 HV;
;;   float pf; // powerfactor
;;   float nDotHV, nDotLL;
;;   float attenuation, spotDot, spotAttenuation;
;;   vec4 TexColor; // texture color

;;   vec3 NN = normalize(N); // surface normal
;;   vec3 EE = normalize(E); // eye vector
;;   vec3 VV = normalize(V); // vertex 3d

;;   for(int i=0; j<numlights; i++, j+=1.0)
;;   {
;;     vec3 LL = normalize(L[i]); // light vector
;;     attenuation = 1.0 / (ConstantAttenuation[i] + (LinearAttenuation[i] * D[i]) + (QuadraticAttenuation[i] * D[i] * D[i]));
;;     spotDot = dot(-LL, normalize(SpotDir[i].xyz));

;;     if(spotDot < SpotAngle[i])
;;       spotAttenuation = 0.0;
;;     else
;;       spotAttenuation = pow(spotDot, SpotExponent[i]);

;;     attenuation *= spotAttenuation;

;;     HV = normalize(LL+EE); // half vector
;;     nDotLL = max(0.0, dot(NN,LL));
;;     nDotHV = max(0.0, dot(NN,HV));

;;     if(nDotLL==0.0)
;;       pf = 0.0;
;;     else
;;       pf = pow(nDotHV, MaterialShininess);

;;     ambient = LightAmbient[i] * MaterialAmbient * attenuation;
;;     diffuse = LightDiffuse[i] * MaterialDiffuse * nDotLL * attenuation;
;;     specular = LightSpecular[i] * MaterialSpecular * pf * attenuation;

;;     //calc shadows
;;     float shadowValue = 0.0;
;;     vec4 lightVertexPosition2 = lightVertexPosition[i];
;;     lightVertexPosition2 /= lightVertexPosition2.w;

;;     float aa = mod((j-0.5),4.0);
;;     float bb = floor((j-0.5)/4.0);
;;     vec2 offset = vec2(0.25*aa,0.25*bb);

;;     // softer shadowing by adding dither
;;     for(float x=-0.0004; x<=0.0004; x+=0.0002) {
;;       for(float y=-0.0004; y<=0.0004; y+=0.0002) {
;;         if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
;;           shadowValue+=1.0;
;;       }
;;     }
;;     shadowValue/=16.0;

;;     if(IsTextured>0.5) {
;;       vec4 texcolor = LightDiffuse[i] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
;;       outcolor += vec4((texcolor.xyz*shadowValue),1.0);
;;     } else {
;;       outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
;;     }
;;   }
;;   float nl = numlights;
;;   if(numlights<0.5) {
;;     nl = 1.0;
;;     float dotE = max(0.0, dot(NN,EE));
;;     if(IsTextured>0.5) {
;;       outcolor.xyz = texture(tex1,UVWCoord.xy).xyz*dotE;
;;     }else{
;;       outcolor.xyz = MaterialDiffuse.xyz*dotE;
;;     }
;;   }
;;   xtmColour = vec4(outcolor.xyz/nl,1.0);
;; }
;; ")


(define xtmfrag_nolight
  "
#version 330

in vec3 N, E, V;
in vec3 L[10];
in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 TexColor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    outcolor.xyz = texture(tex1,UVWCoord.xy).xyz*dotE;
  }else{
    outcolor.xyz = MaterialDiffuse.xyz*dotE;
  }
  xtmColour = vec4(outcolor.xyz,1.0);
}
")

(define xtmvert0
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 4) in mat4 xtmIMat;    // instance matrix
layout (location = 8) in vec4 xtmIColour;    // instance colour

out vec3 N, E, V;

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;
uniform int instances;

out vec3 UVWCoord;
out vec4 vColour;

void main()
{
  vec4 vPosition;
  vec4 vpos;
  if (instances > 0) {
    vpos = xtmIMat * xtmVertex;
  } else {
    vpos = xtmVertex;
  }

  gl_Position = ModelViewProjectionMatrix * vpos; //xtmVertex;
  vPosition = ModelViewMatrix * vpos; //xtmVertex;

  N = NormalMatrix * xtmNormal;
  float j = 0.5;

  V = vPosition.xyz;
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  if (instances > 0) {
    vColour = xtmIColour;
  } else {
    vColour = xtmColour;
  }
}
")

(define xtmvert
"
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 4) in mat4 xtmIMat;       // instance matrix
layout (location = 8) in vec4 xtmIColour;    // instance colour

out vec3 N, E, V;
out vec3 L[5];
out float D[5];

uniform vec4 LightPos[5];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[5];

uniform int numLights;
uniform int instances;

out vec4 lightVertexPosition[5];
out vec3 UVWCoord;
out vec4 vColour;

void main()
{
  vec4 vPosition;
  vec4 vpos;
  int k;

  if (instances > 0) {
    vpos = xtmIMat * xtmVertex;
  } else {
    vpos = xtmVertex;
  }

  gl_Position = ModelViewProjectionMatrix * vpos;
  vPosition = ModelViewMatrix * vpos;

  N = NormalMatrix * xtmNormal;
  float j = 0.5;

  for (k = 0; k < numLights; k++) {
    L[k] = (LightPos[k] - (ModelMatrix * vpos)).xyz; // vector from source to light
    if(LightPos[k].w == 0.0) L[k] = LightPos[k].xyz; // i.e. if LightPos is already a direction vector
    D[k] = length(L[k]);
    lightVertexPosition[k] = LightModelViewProjectionMatrix[k] * vpos;
  }

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  if (instances > 0) {
    vColour = xtmIColour;
  } else {
    vColour = vec4(1.0); //xtmColour;
  }
}
")

(define xtmfrag
"
#version 330

in vec3 N, E, V;
in vec3 L[5];
in float D[5];

uniform vec4 LightAmbient[5];
uniform vec4 LightDiffuse[5];
uniform vec4 LightSpecular[5];
uniform float ConstantAttenuation[5];
uniform float LinearAttenuation[5];
uniform float QuadraticAttenuation[5];
uniform float SpotAngle[5];
uniform vec4 SpotDir[5];
uniform float SpotExponent[5];

uniform int numLights;
uniform int instances;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[5];
in vec3 UVWCoord;
in vec4 vColour;

out vec4 xtmColour;

float calcAttenuation(int idx) {
  vec3 LL = normalize(L[idx]); // light vector
  float attenuation = 1.0 / (ConstantAttenuation[idx] + (LinearAttenuation[idx] * D[idx]) + (QuadraticAttenuation[idx] * D[idx] * D[idx]));
  float spotDot = dot(-LL, normalize(SpotDir[idx].xyz));
  float spotAttenuation = 0.0;
  if (spotDot >= SpotAngle[idx]) {
   spotAttenuation = pow(spotDot, SpotExponent[idx]);
  }
  attenuation *= spotAttenuation;
  return attenuation;
}

float calcShadow(int idx) {
  //calc shadows
  float j = 0.5 + float(idx);
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[idx];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;
  return shadowValue;
}

vec4 calcFrag(int idx, vec3 NN, vec3 EE, float attenuation, float shadowValue) {
  vec3 LL = normalize(L[idx]); // light vector
  vec4 outcolor, ambient, diffuse, specular, texcolour;
  vec3 HV = normalize(LL+EE); // half vector
  float pf = 0.0;
  float nDotLL = max(0.0, dot(NN,LL));
  float nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL > 0.0) {
    pf = pow(nDotHV, MaterialShininess);
  }

  ambient  = LightAmbient[idx]   * MaterialAmbient  * attenuation;
  diffuse  = LightDiffuse[idx]   * MaterialDiffuse  * attenuation * nDotLL;
  specular = LightSpecular[idx]  * MaterialSpecular * attenuation * pf;

  if(IsTextured>0.5) {
    texcolour = diffuse * texture(tex1,UVWCoord.xy) * vColour;
    outcolor = vec4(texcolour.xyz*shadowValue,texcolour.a);
  } else {
    outcolor = vec4(((ambient + diffuse + specular).xyz*shadowValue*vColour.xyz),vColour.a);
  }
  return outcolor;
}

void main()
{
  vec4 outcolour = vec4(0.0);
  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d
  float attenuation, shadowValue;

  if(numLights > 0) { // light 1
    attenuation = calcAttenuation(0);
    shadowValue = calcShadow(0);
    outcolour += calcFrag(0,NN,EE,attenuation,shadowValue);
  }

  if(numLights > 1) { // light 2
    attenuation = calcAttenuation(1);
    shadowValue = calcShadow(1);
    outcolour += calcFrag(1,NN,EE,attenuation,shadowValue);
  }

  if(numLights > 2) { // light 3
    attenuation = calcAttenuation(2);
    shadowValue = calcShadow(2);
    outcolour += calcFrag(2,NN,EE,attenuation,shadowValue);
  }

  if(numLights > 3) { // light 4
    attenuation = calcAttenuation(3);
    shadowValue = calcShadow(3);
    outcolour += calcFrag(3,NN,EE,attenuation,shadowValue);
  }

  if(numLights > 4) { // light 5
    attenuation = calcAttenuation(4);
    shadowValue = calcShadow(4);
    outcolour += calcFrag(4,NN,EE,attenuation,shadowValue);
  }

  if(numLights < 1) { // NO LIGHTS!
    float dotE = max(0.0, dot(NN,EE));
    if(IsTextured>0.5) {
      outcolour = texture(tex1,UVWCoord.xy) * dotE * vColour;
    }else{
      outcolour = vec4(MaterialDiffuse.xyz*vColour.xyz*dotE,MaterialDiffuse.a*vColour.a);
    }
  } else {
    outcolour /= float(numLights);
  }

  xtmColour = outcolour;
}
")


(define xtmvertbone1
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 4) in vec4 xtmBoneIndexes;
layout (location = 5) in vec4 xtmBoneWeights;
layout (location = 6) in float xtmActiveBones;

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 Bone[20];

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
// out vec4 Color;


void main()
{
   vec4 newVertex;
   vec4 newNormal;
   vec3 new3Normal;
   int index;
   if(int(xtmActiveBones) > 4) {
     newVertex = vec4(0.0,0.0,0.0,0.0);
     newNormal = newVertex;
   }else if(int(xtmActiveBones) > 3) {
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
     index=int(xtmBoneIndexes.z);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.z;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.z;
     index=int(xtmBoneIndexes.w);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.w;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.w;
   }else if(int(xtmActiveBones) > 2){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
     index=int(xtmBoneIndexes.z);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.z;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.z;
   }else if(int(xtmActiveBones) > 1){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
     index=int(xtmBoneIndexes.y);
     newVertex += (Bone[index] * xtmVertex) * xtmBoneWeights.y;
     newNormal += (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.y;
   }else if(int(xtmActiveBones) > 0){
     index=int(xtmBoneIndexes.x);
     newVertex = (Bone[index] * xtmVertex) * xtmBoneWeights.x;
     newNormal = (Bone[index] * vec4(xtmNormal, 0.0)) * xtmBoneWeights.x;
   } else {
     newVertex = xtmVertex;
     newNormal = vec4(xtmNormal, 0.0);
   }
  new3Normal = newNormal.xyz;

  gl_Position = ModelViewProjectionMatrix * newVertex;
  vec4 vPosition = ModelViewMatrix * newVertex;
  N = NormalMatrix * new3Normal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * newVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * newVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  // Color = xtmColour;
}
")

(define xtmfrag0
  "
#version 330

in vec3 N, E, V;
//in vec3 L[10];
//in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;
uniform int instances;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

//in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
in vec4 vColour;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  float dotE = max(0.0, dot(NN,EE));
  if(IsTextured>0.5) {
    if(instances > 0) {
       texcolor = texture(tex1,UVWCoord.xy) * vColour;
    } else {
       texcolor = texture(tex1,UVWCoord.xy);
    }
    outcolor = vec4(texcolor.xyz*dotE,texcolor.a);
  }else{
    if(instances > 0) {
       outcolor = vec4(MaterialDiffuse.xyz*dotE*vColour.xyz,MaterialDiffuse.a*vColour.a);
    } else {
       outcolor = vec4(MaterialDiffuse.xyz*dotE,MaterialDiffuse.a);
    }
  }
  xtmColour = outcolor;
}
")



(define xtmvert2
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 7) in mat4 xtmIMat; // instance matrix

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;
uniform int instances;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
// out vec4 Color;


void main()
{
  vec4 vpos;
  if (instances > 0) {
     vpos = xtmIMat * xtmVertex;
  } else {
     vpos = xtmVertex;
  }

  gl_Position = ModelViewProjectionMatrix * vpos;
  vec4 vPosition = ModelViewMatrix * vpos;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * vpos)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * vpos;

  L[1] = (LightPos[1] - (ModelMatrix * vpos)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * vpos;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  // Color = xtmColour;
}
")

(define xtmfrag2
  "
#version 330

in vec3 N, E, V;
in vec3 L[10];
in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
// in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    vec4 texcolor = LightDiffuse[0] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  xtmColour = vec4(outcolor.xyz,1.0);
}
")

(define xtmvert3
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;
layout (location = 7) in mat4 xtmIMat; // instance matrix

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;
uniform int instances;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
// out vec4 Color;


void main()
{
  vec4 vpos;

  if (instances > 0) {
     vpos = xtmIMat * xtmVertex;
  } else {
     vpos = xtmVertex;
  }

  gl_Position = ModelViewProjectionMatrix * vpos;
  vec4 vPosition = ModelViewMatrix * vpos;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * vpos)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * vpos;

  L[1] = (LightPos[1] - (ModelMatrix * vpos)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * vpos;

  L[2] = (LightPos[2] - (ModelMatrix * vpos)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * vpos;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  // Color = xtmColour;
}
")

(define xtmfrag3
  "
#version 330

in vec3 N, E, V;
in vec3 L[10];
in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
// in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  xtmColour = vec4(outcolor.xyz,1.0);
}
")

(define xtmvert4
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
// out vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  // Color = xtmColour;
}
")

(define xtmfrag4
  "
#version 330

in vec3 N, E, V;
in vec3 L[10];
in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
// in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  xtmColour = vec4(outcolor.xyz,1.0);
}
")

(define xtmvert5
  "
#version 330

layout (location = 0) in vec4 xtmVertex;
layout (location = 1) in vec3 xtmNormal;
layout (location = 2) in vec3 xtmUVW;
layout (location = 3) in vec4 xtmColour;

out vec3 N, E, V;
out vec3 L[10];
out float D[10];

uniform vec4 LightPos[10];
uniform vec4 CameraPos;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform mat4 LightModelViewProjectionMatrix[10];

uniform float numlights;

out vec4 lightVertexPosition[10];
out vec3 UVWCoord;
// out vec4 Color;


void main()
{
  gl_Position = ModelViewProjectionMatrix * xtmVertex;
  vec4 vPosition = ModelViewMatrix * xtmVertex;
  N = NormalMatrix * xtmNormal; //normal
  float j = 0.5;

  L[0] = (LightPos[0] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[0].w == 0.0) L[0] = LightPos[0].xyz; // i.e. if LightPos is already a direction vector
  D[0] = length(L[0]);
  lightVertexPosition[0] = LightModelViewProjectionMatrix[0] * xtmVertex;

  L[1] = (LightPos[1] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[1].w == 0.0) L[1] = LightPos[1].xyz; // i.e. if LightPos is already a direction vector
  D[1] = length(L[1]);
  lightVertexPosition[1] = LightModelViewProjectionMatrix[1] * xtmVertex;

  L[2] = (LightPos[2] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[2].w == 0.0) L[2] = LightPos[2].xyz; // i.e. if LightPos is already a direction vector
  D[2] = length(L[2]);
  lightVertexPosition[2] = LightModelViewProjectionMatrix[2] * xtmVertex;

  L[3] = (LightPos[3] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[3].w == 0.0) L[3] = LightPos[3].xyz; // i.e. if LightPos is already a direction vector
  D[3] = length(L[3]);
  lightVertexPosition[3] = LightModelViewProjectionMatrix[3] * xtmVertex;

  L[4] = (LightPos[4] - (ModelMatrix * xtmVertex)).xyz; // vector from source to light
  if(LightPos[4].w == 0.0) L[4] = LightPos[4].xyz; // i.e. if LightPos is already a direction vector
  D[4] = length(L[4]);
  lightVertexPosition[4] = LightModelViewProjectionMatrix[4] * xtmVertex;

  V = vPosition.xyz; // vertex (3d)
  E = (CameraPos - vPosition).xyz; // vector from source to eye
  UVWCoord = xtmUVW;
  // Color = xtmColour;
}
")

(define xtmfrag5
  "
#version 330

in vec3 N, E, V;
in vec3 L[10];
in float D[10];

uniform vec4 LightAmbient[10];
uniform vec4 LightDiffuse[10];
uniform vec4 LightSpecular[10];
uniform float ConstantAttenuation[10];
uniform float LinearAttenuation[10];
uniform float QuadraticAttenuation[10];
uniform float SpotAngle[10];
uniform vec4 SpotDir[10];
uniform float SpotExponent[10];

uniform float numlights;

uniform vec4 CameraDir;
uniform float MaterialShininess;
uniform vec4 MaterialAmbient;
uniform vec4 MaterialDiffuse;
uniform vec4 MaterialSpecular;

uniform mat4 ModelMatrix;
uniform mat4 ViewMatrix;
uniform mat4 ProjectionMatrix;
uniform mat3 NormalMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;

uniform sampler2D shadowMap;
uniform sampler2D tex1;
uniform float IsTextured;

in vec4 lightVertexPosition[10];
in vec3 UVWCoord;
// in vec4 Color;

out vec4 xtmColour;

void main()
{
  vec4 outcolor = vec4(0.0);
  float j = 0.5;
  vec4 ambient,diffuse,specular;
  vec3 HV;
  float pf; // powerfactor
  float nDotHV, nDotLL;
  float attenuation, spotDot, spotAttenuation;
  vec4 texcolor; // texture color

  vec3 NN = normalize(N); // surface normal
  vec3 EE = normalize(E); // eye vector
  vec3 VV = normalize(V); // vertex 3d

  // light 1
  vec3 LL = normalize(L[0]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[0] + (LinearAttenuation[0] * D[0]) + (QuadraticAttenuation[0] * D[0] * D[0]));
  spotDot = dot(-LL, normalize(SpotDir[0].xyz));

  if(spotDot < SpotAngle[0])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[0]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[0] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[0] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[0] * MaterialSpecular * pf * attenuation;

  //calc shadows
  float shadowValue = 0.0;
  vec4 lightVertexPosition2 = lightVertexPosition[0];
  lightVertexPosition2 /= lightVertexPosition2.w;

  float aa = mod((j-0.5),4.0);
  float bb = floor((j-0.5)/4.0);
  vec2 offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[0] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 2
  j += 1.0;
  LL = normalize(L[1]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[1] + (LinearAttenuation[1] * D[1]) + (QuadraticAttenuation[1] * D[1] * D[1]));
  spotDot = dot(-LL, normalize(SpotDir[1].xyz));

  if(spotDot < SpotAngle[1])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[1]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[1] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[1] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[1] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[1];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[1] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 3
  j += 1.0;
  LL = normalize(L[2]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[2] + (LinearAttenuation[2] * D[2]) + (QuadraticAttenuation[2] * D[2] * D[2]));
  spotDot = dot(-LL, normalize(SpotDir[2].xyz));

  if(spotDot < SpotAngle[2])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[2]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[2] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[2] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[2] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[2];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[2] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 4
  j += 1.0;
  LL = normalize(L[3]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[3] + (LinearAttenuation[3] * D[3]) + (QuadraticAttenuation[3] * D[3] * D[3]));
  spotDot = dot(-LL, normalize(SpotDir[3].xyz));

  if(spotDot < SpotAngle[3])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[3]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[3] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[3] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[3] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[3];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[3] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  // light 5
  j += 1.0;
  LL = normalize(L[4]); // light vector
  attenuation = 1.0 / (ConstantAttenuation[4] + (LinearAttenuation[4] * D[4]) + (QuadraticAttenuation[4] * D[4] * D[4]));
  spotDot = dot(-LL, normalize(SpotDir[4].xyz));

  if(spotDot < SpotAngle[4])
    spotAttenuation = 0.0;
  else
    spotAttenuation = pow(spotDot, SpotExponent[4]);

  attenuation *= spotAttenuation;

  HV = normalize(LL+EE); // half vector
  nDotLL = max(0.0, dot(NN,LL));
  nDotHV = max(0.0, dot(NN,HV));

  if(nDotLL==0.0)
    pf = 0.0;
  else
    pf = pow(nDotHV, MaterialShininess);

  ambient = LightAmbient[4] * MaterialAmbient * attenuation;
  diffuse = LightDiffuse[4] * MaterialDiffuse * nDotLL * attenuation;
  specular = LightSpecular[4] * MaterialSpecular * pf * attenuation;

  //calc shadows
  shadowValue = 0.0;
  lightVertexPosition2 = lightVertexPosition[4];
  lightVertexPosition2 /= lightVertexPosition2.w;

  aa = mod((j-0.5),4.0);
  bb = floor((j-0.5)/4.0);
  offset = vec2(0.25*aa,0.25*bb);

  // softer shadowing by adding dither
  for(float x=-0.0004; x<=0.0004; x+=0.0002) {
    for(float y=-0.0004; y<=0.0004; y+=0.0002) {
      if(texture(shadowMap,(lightVertexPosition2.xy*0.25)+offset+vec2(x,y)).r >= lightVertexPosition2.z)
        shadowValue+=1.0;
    }
  }
  shadowValue/=16.0;

  if(IsTextured>0.5) {
    texcolor = LightDiffuse[4] * texture(tex1,UVWCoord.xy) * nDotLL * attenuation;
    outcolor += vec4((texcolor.xyz*shadowValue),1.0);
  } else {
    outcolor += vec4(((ambient + diffuse + specular).xyz*shadowValue),1.0);
  }

  xtmColour = vec4(outcolor.xyz,1.0);
}
")

;; (define dof-frag
;; "
;; #version 330

;; uniform sampler2D dBuf;
;; uniform sampler2D cBuf;
;; uniform float blur;
;; uniform float dof;
;; uniform float fp;  // focal point
;; uniform int show_depth;
;; uniform float near;
;; uniform float far;
;; uniform vec2 frameBufSize;

;; in vec2 UVCoord;

;; out vec4 xtmColour;

;; vec4 blurKawase( const sampler2D tex, const vec2 texCoord, const vec2 texSize, const float iteration ) {
;;  // Function assumes that tex is using bilinear hardware filtering

;;  vec2 dUV = (iteration + 0.5) / texSize;

;;  vec4 col = texture( tex, texCoord + vec2( -dUV.x, dUV.y ) );	// Top left
;;  col += texture( tex, texCoord + dUV );            // Top right
;;  col += texture( tex, texCoord + vec2( dUV.x, -dUV.y ) );      // Bottom right
;;  col += texture( tex, texCoord - dUV );            // Bottom left

;;  return col * 0.25;
;; }

;; void main( void ) {
;;   // get z depth from dBuf tex
;;  float depth = texture(dBuf,UVCoord).x;
;;   // linearly scale depth buffer
;;   depth = (near*2.0) / ((far+near) - (depth*(far-near)));
;;   // depth to focal point
;;   depth = log(1.0+abs(depth-fp)) / log(dof);

;;   // show_depth is true display depth buffer
;;   if (show_depth == 1) {
;;     xtmColour = vec4(depth,depth,depth,1.0);
;;   } else if (show_depth == -1) { // else show colour buf (no blur)
;;     xtmColour = texture( cBuf, UVCoord );
;;   } else { // else apply depth blur
;;     xtmColour = blurKawase( cBuf, UVCoord, frameBufSize, depth * blur);
;;   }

;;   //xtmColour = texture(cBuf,UVCoord); //vec4(0.0,1.0,0.0,1.0);
;; }
;; ")


;; DoF with bokeh GLSL shader v2.4
;; by Martins Upitis (martinsh) (devlog-martinsh.blogspot.com)
;; public domain.
;;
(define dof-frag
  "
#version 330

uniform sampler2D bgl_RenderedTexture;
uniform sampler2D bgl_DepthTexture;
uniform float bgl_RenderedTextureWidth;
uniform float bgl_RenderedTextureHeight;

#define PI  3.14159265

float width = bgl_RenderedTextureWidth; //texture width
float height = bgl_RenderedTextureHeight; //texture height

vec2 texel = vec2(1.0/width,1.0/height);

//uniform variables from external script

uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below
uniform float focalLength; //focal length in mm
uniform float fstop; //f-stop value
uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)
uniform bool autofocus; // autofocus on or off
uniform vec2 focus;     // autofocus point if auto is on (0,0 bottom left 1,1 top right)

/*
make sure that these two values are the same for your camera, otherwise distances will be wrong.
*/

float znear = 0.1; //camera clipping start
float zfar = 100.0; //camera clipping end

//------------------------------------------
//user variables

int samples = 3; //samples on the first ring
int rings = 3; //ring count

bool manualdof = false; //manual dof calculation
float ndofstart = 1.0; //near dof blur start
float ndofdist = 2.0; //near dof blur falloff distance
float fdofstart = 1.0; //far dof blur start
float fdofdist = 3.0; //far dof blur falloff distance

float CoC = 0.03;//circle of confusion size in mm (35mm film = 0.03mm)

bool vignetting = true; //use optical lens vignetting?
float vignout = 1.3; //vignetting outer border
float vignin = 0.0; //vignetting inner border
float vignfade = 22.0; //f-stops till vignete fades

//bool autofocus = false; //use autofocus in shader? disable if you use external focalDepth value
//vec2 focus = vec2(0.5,0.5); // autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)
float maxblur = 1.0; //clamp value of max blur (0.0 = no blur,1.0 default)

float threshold = 0.5; //highlight threshold;
float gain = 2.0; //highlight gain;

float bias = 0.5; //bokeh edge bias
float fringe = 0.7; //bokeh chromatic aberration/fringing

bool noise = true; //use noise instead of pattern for sample dithering
float namount = 0.0001; //dither amount

bool depthblur = false; //blur the depth buffer?
float dbsize = 1.25; //depthblursize

/*
next part is experimental
not looking good with small sample and ring count
looks okay starting from samples = 4, rings = 4
*/

bool pentagon = false; //use pentagon as bokeh shape?
float feather = 0.4; //pentagon shape feather

in vec2 UVCoord;

out vec4 xtmColour;

//------------------------------------------


float penta(vec2 coords) //pentagonal shape
{
  float scale = float(rings) - 1.3;
  vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);
  vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);
  vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);
  vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);
  vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);
  vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);

  vec4  one = vec4( 1.0 );

  vec4 P = vec4((coords),vec2(scale, scale));

  vec4 dist = vec4(0.0);
  float inorout = -4.0;

  dist.x = dot( P, HS0 );
  dist.y = dot( P, HS1 );
  dist.z = dot( P, HS2 );
  dist.w = dot( P, HS3 );

  dist = smoothstep( -feather, feather, dist );

  inorout += dot( dist, one );

  dist.x = dot( P, HS4 );
  dist.y = HS5.w - abs( P.z );

  dist = smoothstep( -feather, feather, dist );
  inorout += dist.x;

  return clamp( inorout, 0.0, 1.0 );
}

float bdepth(vec2 coords) //blurring depth
{
  float d = 0.0;
  float kernel[9];
  vec2 offset[9];

  vec2 wh = vec2(texel.x, texel.y) * dbsize;

  offset[0] = vec2(-wh.x,-wh.y);
  offset[1] = vec2( 0.0, -wh.y);
  offset[2] = vec2( wh.x -wh.y);

  offset[3] = vec2(-wh.x,  0.0);
  offset[4] = vec2( 0.0,   0.0);
  offset[5] = vec2( wh.x,  0.0);

  offset[6] = vec2(-wh.x, wh.y);
  offset[7] = vec2( 0.0,  wh.y);
  offset[8] = vec2( wh.x, wh.y);

  kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;
  kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;
  kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;


  for( int i=0; i<9; i++ )
  {
    float tmp = texture(bgl_DepthTexture, coords + offset[i]).r;
    d += tmp * kernel[i];
  }

  return d;
}


vec3 color(vec2 coords,float blur) //processing the sample
{
  vec3 col = vec3(0.0);

  col.r = texture(bgl_RenderedTexture,coords + vec2(0.0,1.0)*texel*fringe*blur).r;
  col.g = texture(bgl_RenderedTexture,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;
  col.b = texture(bgl_RenderedTexture,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;

  vec3 lumcoeff = vec3(0.299,0.587,0.114);
  float lum = dot(col.rgb, lumcoeff);
  float thresh = max((lum-threshold)*gain, 0.0);
  return col+mix(vec3(0.0),col,thresh*blur);
}

vec2 rand(vec2 coord) //generating noise/pattern texture for dithering
{
  float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;
  float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;

  if (noise)
  {
    noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;
    noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;
  }
  return vec2(noiseX,noiseY);
}

vec3 debugFocus(vec3 col, float blur, float depth)
{
  float edge = 0.002*depth; //distance based edge smoothing
  float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);
  float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);

  col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);
  col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);

  return col;
}

float linearize(float depth)
{
  return -zfar * znear / (depth * (zfar - znear) - zfar);
}

float vignette()
{
  float dist = distance(UVCoord.xy, vec2(0.5,0.5));
  dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);
  return clamp(dist,0.0,1.0);
}

void main()
{
  //scene depth calculation

  float depth = linearize(texture(bgl_DepthTexture,UVCoord.xy).x);

  if (depthblur)
  {
    depth = linearize(bdepth(UVCoord.xy));
  }

  //focal plane calculation

  float fDepth = focalDepth;

  if (autofocus)
  {
    fDepth = linearize(texture(bgl_DepthTexture,focus).x);
  }

  //dof blur factor calculation

  float blur = 0.0;

  if (manualdof)
  {
    float a = depth-fDepth; //focal plane
    float b = (a-fdofstart)/fdofdist; //far DoF
    float c = (-a-ndofstart)/ndofdist; //near Dof
    blur = (a>0.0)?b:c;
  }

  else
  {
    float f = focalLength; //focal length in mm
    float d = fDepth*1000.0; //focal plane in mm
    float o = depth*1000.0; //depth in mm

    float a = (o*f)/(o-f);
    float b = (d*f)/(d-f);
    float c = (d-f)/(d*fstop*CoC);

    blur = abs(a-b)*c;
  }

  blur = clamp(blur,0.0,1.0);

  // calculation of pattern for ditering

  vec2 noise = rand(UVCoord.xy)*namount*blur;

  // getting blur x and y step factor

  float w = (1.0/width)*blur*maxblur+noise.x;
  float h = (1.0/height)*blur*maxblur+noise.y;

  // calculation of final color

  vec3 col = vec3(0.0);

  if(blur < 0.05) //some optimization thingy
  {
    col = texture(bgl_RenderedTexture, UVCoord.xy).rgb;
  }

  else
  {
    col = texture(bgl_RenderedTexture, UVCoord.xy).rgb;
    float s = 1.0;
    int ringsamples;

    for (int i = 1; i <= rings; i += 1)
    {
      ringsamples = i * samples;

      for (int j = 0 ; j < ringsamples ; j += 1)
      {
        float step = PI*2.0 / float(ringsamples);
        float pw = (cos(float(j)*step)*float(i));
        float ph = (sin(float(j)*step)*float(i));
        float p = 1.0;
        if (pentagon)
        {
          p = penta(vec2(pw,ph));
        }
        col += color(UVCoord.xy + vec2(pw*w,ph*h),blur)*mix(1.0,(float(i))/(float(rings)),bias)*p;
        s += 1.0*mix(1.0,(float(i))/(float(rings)),bias)*p;
      }
    }
    col /= s; //divide by sample count
  }

  if (showFocus)
  {
    col = debugFocus(col, blur, depth);
  }

  if (vignetting)
  {
    col *= vignette();
  }

  xtmColour.rgb = col;
  xtmColour.a = 1.0;
}
")

(define lense-flare-frag
  "
#version 330

float noise(float t)
{
  return texture2D(iChannel0,vec2(t,.0)/iChannelResolution[0].xy).x;
}
float noise(vec2 t)
{
  return texture2D(iChannel0,t/iChannelResolution[0].xy).x;
}

vec3 lensflare(vec2 uv,vec2 pos)
{
  vec2 main = uv-pos;
  vec2 uvd = uv*(length(uv));

  float ang = atan(main.x,main.y);
  float dist=length(main); dist = pow(dist,.1);
  float n = noise(vec2(ang*16.0,dist*32.0));

  float f0 = 1.0/(length(uv-pos)*16.0+1.0);

  f0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8);

  float f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;

  float f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;
  float f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;
  float f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;

  vec2 uvx = mix(uv,uvd,-0.5);

  float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;
  float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;
  float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;

  uvx = mix(uv,uvd,-.4);

  float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;
  float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;
  float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;

  uvx = mix(uv,uvd,-0.5);

  float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;
  float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;
  float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;

  vec3 c = vec3(.0);

  c.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;
  c = c*1.3 - vec3(length(uvd)*.05);
  c+=vec3(f0);

  return c;
}

vec3 cc(vec3 color, float factor,float factor2) // color modifier
{
  float w = color.x+color.y+color.z;
  return mix(color,vec3(w)*factor,w*factor2);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
  vec2 uv = fragCoord.xy / iResolution.xy - 0.5;
  uv.x *= iResolution.x/iResolution.y; //fix aspect ratio
  vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);
  mouse.x *= iResolution.x/iResolution.y; //fix aspect ratio
  if (iMouse.z<.5)
  {
    mouse.x=sin(iGlobalTime)*.5;
    mouse.y=sin(iGlobalTime*.913)*.5;
  }

  vec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);
  color -= noise(fragCoord.xy)*.015;
  color = cc(color,.5,.1);
  fragColor = vec4(color,1.0);
}
")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; convenience functions for setting up a gl loop on another process

(define gl-loop
  (lambda (time delta-t)
    (gl_render)
    ;; this won't work in Scheme
    ;; (glfw_swap_buffers window)
    (let* ((cb-lookahead 0.1)
           (t (+ (now) (* cb-lookahead delta-t *second*)))
           (missed-frames (quotient (real->integer (- t time))
                                    (real->integer (* delta-t *second*))))
           (newtime (+ time (* (* (+ missed-frames 2) delta-t) *second*))))
      (if (> missed-frames 0)
          (begin (print-with-colors *impc:compiler:pretty-print-error-color* 'default #t
                                    (print "Warning"))
                 (print ": ")
                 (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                                    (print "gl-loop"))
                 (print " couldn't handle the load, dropped ")
                 (print-with-colors *impc:compiler:pretty-print-code-color* 'default #f
                                    (print missed-frames))
                 (print " frames\n")))
      (callback (* newtime cb-lookahead) 'gl-loop newtime delta-t))))

(define xtm-setup-and-start-gl-loop
  (lambda (width height fps start-time)
    (xtm_render_setup width height)
    (gl-loop start-time (/ 1 fps))
    ;; not sure about the best way to see if this function succeeds
    #t))

(define ipc:bind-xtmrender-vars
  (lambda (proc)
    (ipc:bind-func proc 'xtm_render_init_quad_shader)
    (ipc:bind-func proc 'xtm_render_init_simple_shader)
    (ipc:bind-func proc 'xtm_render_init_light_shader xtm_render_init_light_shader)
    ;; frag shaders
    (ipc:define proc 'simple-frag simple-frag)
    (ipc:define proc 'quad-frag quad-frag)
    (ipc:define proc 'xtmfrag0 xtmfrag0)
    (ipc:define proc 'xtmfrag xtmfrag)
    (ipc:define proc 'xtmfrag_nolight xtmfrag_nolight)
    (ipc:define proc 'xtmfrag1 xtmfrag1)
    (ipc:define proc 'xtmfrag2 xtmfrag2)
    (ipc:define proc 'xtmfrag3 xtmfrag3)
    (ipc:define proc 'xtmfrag4 xtmfrag4)
    (ipc:define proc 'xtmfrag5 xtmfrag5)
    ;; vert shaders
    (ipc:define proc 'simple-vert-xtm simple-vert-xtm)
    (ipc:define proc 'simple-bone-vert-xtm simple-bone-vert-xtm)
    (ipc:define proc 'quad-vert quad-vert)
    (ipc:define proc 'xtmvert-xtm xtmvert-xtm)
    (ipc:define proc 'xtmvert xtmvert)
    ;; (ipc:define proc 'xtmvert1 xtmvert1)
    ;; (ipc:define proc 'xtmvert2 xtmvert2)
    ;; (ipc:define proc 'xtmvert3 xtmvert3)
    ;; (ipc:define proc 'xtmvert4 xtmvert4)
    ;; (ipc:define proc 'xtmvert5 xtmvert5)
    (ipc:bind-func proc 'xtm_render_setup_a xtm_render_setup_a)
    (ipc:bind-func proc 'xtm_render_setup_b xtm_render_setup_b)
    (ipc:bind-func proc 'xtm_render_setup_c xtm_render_setup_c)
    (ipc:define proc 'xtm_render_setup xtm_render_setup)
    (ipc:bind-func proc 'xtm_render xtm_render)))

(define ipc:graphics-setup
  (lambda (proc width height fullscreen fps start-time)
    (if (not (impc:ti:closure-exists? "post"))
        (bind-func post:XTMRENDERCB
          (lambda (frame shader m v p data)
            void)))
    (if (not (impc:ti:closure-exists? "gl_render"))
        (bind-func gl_render
          (lambda ()
            (xtm_render null null null  post null)
            void)))
    (begin (ipc:bind-func proc 'gl_render gl_render)
           (ipc:bind-func proc 'post post)
           (print "Binding ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "gl_render"))
           (print " on ")
           (print-with-colors 'cyan 'default #t (print proc))
           (print " process\nMake sure you ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "ipc:bind-func"))
           (print " any functions which ")
           (print-with-colors *impc:compiler:pretty-print-name-color* 'default #t
                              (print "gl_render"))
           (print " calls in that process as well\ne.g. (ipc:bind-func" proc "'fn_name fn_name)\n"))
    (ipc:define proc 'gl-loop gl-loop)
    ;; (ipc:define proc 'xtm-create-gl-context xtm-create-gl-context)
    (ipc:define proc 'xtm-setup-and-start-gl-loop xtm-setup-and-start-gl-loop)
    ;; (if (not (ipc:call proc 'xtm-create-gl-context width height fullscreen))
    ;;     (print-with-colors *impc:compiler:pretty-print-error-color* 'default #t
    ;;                        (print "Error creating gl context.")))
    (begin
      (ipc:bind-xtmrender-vars proc)
      (ipc:call proc 'xtm-setup-and-start-gl-loop width height fps start-time)
      (begin (print "\nStarted xtm render loop on ")
             (print-with-colors 'cyan 'default #t (print proc))
             (print " process.\n\n")))))
