;;; gui.xtm -- simple 2D GUI library

;; Author: Ben Swift
;; Keywords: extempore
;; Required dylibs: libGL, libglfw3, libnanovg

;;; Commentary:

;;

;;; Code:

(if *impc:compiler:with-cache* (sys:load "libs/aot-cache/gui.xtm" 'quiet))
(sys:load-preload-check 'gui)
(define *xtmlib-gui-loaded* #t)

(impc:aot:suppress-aot-do
 (sys:load "libs/base/base.xtm")
 (sys:load "libs/external/nanovg.xtm")
 (sys:load "libs/external/glfw3.xtm"))
(impc:aot:insert-forms (sys:load "libs/base/base.xtm" 'quiet))
(impc:aot:insert-forms (sys:load "libs/external/nanovg.xtm" 'quiet))
(impc:aot:insert-forms (sys:load "libs/external/glfw3.xtm" 'quiet))

(impc:aot:insert-header "xtmgui")
(impc:aot:import-ll "xtmgui")

;; 0. id
;; 1. split
;; 2. type (flags)
;; 3. callback (to draw widget, handle events)
;; 4. parent widget
;; 5. left child widget
;; 6. right child widget
(bind-type Widget <i32,float,i64,[void,Widget*,Rect*]*,Widget*,Widget*,Widget*> (printer? . #f))

(bind-alias WidgetCB [void,Widget*,Rect*]*)

;; accessors
(bind-func Widget_id
  (lambda (widget:Widget*)
    (tref widget 0)))

(bind-func Widget_split
  (lambda (widget:Widget*)
    (tref widget 1)))

(bind-func Widget_set_split
  (lambda (widget:Widget* split)
    (tset! widget 1 split)))

(bind-func Widget_type
  (lambda (widget:Widget*)
    (tref widget 2)))

(bind-func Widget_set_type
  (lambda (widget:Widget* type)
    (tset! widget 2 type)))

(bind-func Widget_type_add_flags
  (lambda (widget:Widget* flags)
    (tset! widget 2 (bor flags (tref widget 2)))))

(bind-func Widget_type_remove_flags
  (lambda (widget:Widget* flags)
    (tset! widget 2 (& (~ flags) (tref widget 2)))))

(bind-func Widget_cb
  (lambda (widget:Widget*)
    (tref widget 3)))

(bind-func Widget_set_cb
  (lambda (widget:Widget* cb:WidgetCB)
    (tset! widget 3 cb)))

(bind-func Widget_parent
  (lambda (widget:Widget*)
    (tref widget 4)))

(bind-func Widget_set_parent
  (lambda (child:Widget* parent)
    (tset! child 4 parent)))

(bind-func Widget_left_child
  (lambda (widget:Widget*)
    (tref widget 5)))

(bind-func Widget_set_left_child
  (lambda (parent:Widget* child)
    (tset! parent 5 child)))

(bind-func Widget_right_child
  (lambda (widget:Widget*)
    (tref widget 6)))

(bind-func Widget_set_right_child
  (lambda (parent:Widget* child)
    (tset! parent 6 child)))

(bind-func print
  (lambda (widget:Widget*)
    (if (null? widget)
        (printf "<Widget 0x0>")
        (printf "<Widget %p\n        id=%d\n        split=%.3f\n        type=%lld\n        parent=%p\n        Lchild=%p\n        Rchild=%p\n>"
                widget
                (Widget_id widget)
                (convert (Widget_split widget) double)
                (Widget_type widget)
                ;; (Widget_cb widget) ;; callback
                (Widget_parent widget)
                (Widget_left_child widget)
                (Widget_right_child widget)))
    void))

(bind-func toString
  (lambda (widget:Widget*)
    (let ((s:i8* (salloc 1024)))
      (if (null? widget)
          (sprintf s "<Widget 0x0>")
          (sprintf s
                   "<Widget %p\n        id=%d\n        split=%.3f\n        type=%lld\n        parent=%p\n        Lchild=%p\n        Rchild=%p\n>"
                   widget
                   (Widget_id widget)
                   (convert (Widget_split widget) double)
                   (Widget_type widget)
                   ;; (Widget_cb widget) ;; callback
                   (Widget_parent widget)
                   (Widget_left_child widget)
                   (Widget_right_child widget)))
      (String s))))

;; not sure why the conversion to i64 is necessary - this was a result
;; of the most recent SB generics update
(bind-func equal
  "naive pointer equality check for Widgets"
  (lambda (w1:Widget* w2:Widget*)
    (= (convert w1 i64) (convert w2 i64))))

;; create

(bind-func Widget_with_cb
  (lambda (id split type cb:WidgetCB)
    (Widget_h id split type cb null null null)))

;; destroy (free)

;; this should really fix up the widget tree as well, but that makes
;; it a fair bit more complicated. left as an excercise to the reader :)
(bind-func Widget_free
  (lambda (widget:Widget*)
    (free widget)))

(bind-func Widget_leaf_p
  (lambda (widget:Widget*)
    (and (null? (Widget_left_child widget))
         (null? (Widget_right_child widget)))))

(bind-func Widget_internal_p
  (lambda (widget:Widget*)
    (not (Widget_leaf_p widget))))

(bind-func Widget_parent_p
  (lambda (child parent)
    (equal (Widget_parent child) parent)))

(bind-func Widget_child_p
  (lambda (parent:Widget* child:Widget*)
    (or (equal (Widget_left_child parent) child)
        (equal (Widget_right_child parent) child))))

;; walk the widget tree, applying fn to each widget
(bind-func Widget_walk_preorder
  (lambda (widget:Widget* visit_fn:[Widget*,Widget*]*)
    (if (null? widget)
        widget
        (begin
          (visit_fn widget)
          (Widget_walk_preorder (Widget_left_child widget) visit_fn)
          (Widget_walk_preorder (Widget_right_child widget) visit_fn)))))

(bind-func Widget_walk_inorder
  (lambda (widget:Widget* visit_fn:[Widget*,Widget*]*)
    (if (null? widget)
        widget
        (begin
          (Widget_walk_inorder (Widget_left_child widget) visit_fn)
          (visit_fn widget)
          (Widget_walk_inorder (Widget_right_child widget) visit_fn)))))

(bind-func Widget_walk_postorder
  (lambda (widget:Widget* visit_fn:[Widget*,Widget*]*)
    (if (null? widget)
        widget
        (begin
          (Widget_walk_postorder (Widget_left_child widget) visit_fn)
          (Widget_walk_postorder (Widget_right_child widget) visit_fn)
          (visit_fn widget)
          null))))

;; returns the first widget for which pred returns true
(bind-func Widget_find_preorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (and (not (null? widget)) (pred widget))
        widget
        (if (not (null? widget))
            (begin
              (let ((left:Widget* (Widget_find_preorder (Widget_left_child widget) pred)))
                (if (not (null? left))
                  left
                  (Widget_find_preorder (Widget_right_child widget) pred))))
            null))))

;; this is untested
(bind-func Widget_find_inorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (not (null? widget))
        (begin
          (Widget_find_inorder (Widget_left_child widget) pred)
          (if (and (not (null? widget)) (pred widget))
              widget

              (Widget_find_inorder (Widget_right_child widget) pred)))
        null)))

;; this is untested
(bind-func Widget_find_postorder
  (lambda (widget:Widget* pred:[i1,Widget*]*)
    (if (not (null? widget))
        (begin
          (Widget_find_postorder (Widget_left_child widget) pred)
          (Widget_find_postorder (Widget_right_child widget) pred)
          (if (and (not (null? widget)) (pred widget)) widget
              null))
        widget)))

;; the GUI type

;; 0. GLFW window
;; 1. nanovg context
;; 2. root widget
;; 3. width
;; 4. height
;; 5. pixel ratio
(bind-type GUI <GLFWwindow*,NVGcontext*,Widget*,float,float,float> (printer? . #f))

;; accessors
(bind-func GUI_window
  (lambda (gui:GUI*)
    (tref gui 0)))

(bind-func GUI_context
  (lambda (gui:GUI*)
    (tref gui 1)))

(bind-func GUI_root
  (lambda (gui:GUI*)
    (tref gui 2)))

(bind-func GUI_set_root
  (lambda (gui:GUI* widget)
    (tset! gui 2 widget)))

(bind-func GUI_width
  (lambda (gui:GUI*)
    (tref gui 3)))

(bind-func GUI_height
  (lambda (gui:GUI*)
    (tref gui 4)))

(bind-func GUI_pixel_ratio
  (lambda (gui:GUI*)
    (tref gui 5)))

(bind-func print
  (lambda (gui:GUI*)
    (if (null? gui)
        (printf "<GUI 0x0>")
        (printf "<GUI %p\n     window=%p\n     context=%p\n     root=%p\n     width=%.1f\n     height=%.1f\n     pixelRatio=%.1f\n>"
                gui
                (GUI_window gui)
                (GUI_context gui)
                (GUI_root gui)
                (convert (GUI_width gui) double)
                (convert (GUI_height gui) double)
                (convert (GUI_pixel_ratio gui) double)))
    void))

(bind-func toString
  (lambda (gui:GUI*)
    (let ((s:i8* (salloc 1024)))
      (if (null? gui)
          (sprintf s "<GUI 0x0>")
          (sprintf s
                   "<GUI %p\n     window=%p\n     context=%p\n     root=%p\n     width=%.1f\n     height=%.1f\n     pixelRatio=%.1f\n>"
                   gui
                   (GUI_window gui)
                   (GUI_context gui)
                   (GUI_root gui)
                   (convert (GUI_width gui) double)
                   (convert (GUI_height gui) double)
                   (convert (GUI_pixel_ratio gui) double)))
      (String s))))

;; this is the global gui structure - there can only be one in each
;; Extempore process

(bind-val EXTEMPORE_GUI GUI* (GUI_h null null null 0.0 0.0 0.0))

(bind-func gui_window_size_callback
  (lambda (window:GLFWwindow* width:i32 height:i32)
    (tset! EXTEMPORE_GUI 3 (convert width))
    (tset! EXTEMPORE_GUI 4 (convert height))
    (glViewport 0 0 width height)
    void))

(bind-func gui_init
  (lambda (width height)
    ;; (if (not (null? EXTEMPORE_GUI))
    ;;     (begin
    ;;       (println "Extempore GUI is already initialised, and cannot be re-initialised.")
    ;;       EXTEMPORE_GUI))
    (let ((ww:i32* (alloc))
          (wh:i32* (alloc))
          (fbw:i32* (alloc))
          (fbh:i32* (alloc))
          (window null)
          (vg null))
      ;; set up GLFW
      (glfwSetErrorCallback (convert (get_native_fptr glfw_error_callback)))
      (glfwInit)
      (set! window (glfw_init_and_create_interaction_window width height))
      (glfwSetWindowSizeCallback window (convert (get_native_fptr gui_window_size_callback)))
      ;; (glfwSetInputMode window GLFW_STICKY_KEYS 1)
      ;; (glfwSetInputMode window GLFW_STICKY_MOUSE_BUTTONS 1)
      ;; set up nanovg
      (set! vg (nvg_create_context))
      (glfwGetWindowSize window ww wh)
      (glfwGetFramebufferSize window fbw fbh)
      ;; create the new GUI data type
      (set! EXTEMPORE_GUI
            (GUI_h
             window
             vg
             null
             (convert (pref ww 0) float)
             (convert (pref wh 0) float)
             (/ (convert (pref fbw 0) float) (convert (pref ww 0) float)))))))

(bind-val GUI_SPLIT_VERTICAL i64 (<< 1 0))
;; (bind-val GUI_SPLIT_HORIZONTAL i64 (<< 1 1))

(bind-func Widget_split_vertical_p
  (lambda (widget)
    (= (& GUI_SPLIT_VERTICAL (Widget_type widget))
       GUI_SPLIT_VERTICAL)))

(bind-func Widget_split_horizontal_p
  (lambda (widget)
    (not (Widget_split_vertical_p widget))))

;; walks the tree in pre-order
(bind-func gui_render_subtree
  (lambda (widget:Widget* bounds:Rect*)
    (if (null? widget)
        widget
        (if (and (null? (Widget_left_child widget))
                 (null? (Widget_right_child widget)))
            ;; if a leaf node, set the nanovg transform matrix and
            ;; call the render callback
            (let ((winWidth (GUI_width EXTEMPORE_GUI))
                  (winHeight (GUI_height EXTEMPORE_GUI))
                  (vg (GUI_context EXTEMPORE_GUI))
                  (cb (Widget_cb widget)))
              ;; (nvgResetTransform vg)
              ;; (nvgTranslate vg x y)
              ;; (nvgScale vg w h)
              (cb widget bounds)
              null)
            ;; otherwise recurse into the child widgets
            (let ((split (Widget_split widget)))
              ;; recurse into children
              (if (Widget_split_vertical_p widget)
                  ;; split vertically
                  (begin
                    (let ((sub_bounds:Rect* (zalloc)))
                      (tfill! sub_bounds
                              (tref bounds 0)
                              (tref bounds 1)
                              (tref bounds 2)
                              (floor (* split (tref bounds 3))))
                      (gui_render_subtree (Widget_left_child widget)
                                          sub_bounds))
                    (let ((sub_bounds:Rect* (zalloc)))
                      (tfill! sub_bounds
                              (tref bounds 0)
                              (floor (+ (tref bounds 1)
                                 (* split (tref bounds 3))))
                              (tref bounds 2)
                              (ceil (* (- 1. split) (tref bounds 3))))
                      (gui_render_subtree (Widget_right_child widget)
                                          sub_bounds)))
                  ;; split horizontally
                  (begin
                    (let ((sub_bounds:Rect* (zalloc)))
                      (tfill! sub_bounds
                              (tref bounds 0)
                              (tref bounds 1)
                              (floor (* split (tref bounds 2)))
                              (tref bounds 3))
                      (gui_render_subtree (Widget_left_child widget)
                                          sub_bounds))
                    (let ((sub_bounds:Rect* (zalloc)))
                      (tfill! sub_bounds
                              (floor (+ (tref bounds 0)
                                 (* split (tref bounds 2))))
                              (tref bounds 1)
                              (ceil (* (- 1. split) (tref bounds 2)))
                              (tref bounds 3))
                      (gui_render_subtree (Widget_right_child widget)
                                          sub_bounds)))))))))

(bind-func gui_render
  (lambda ()
    (if (not (null? (GUI_window EXTEMPORE_GUI)))
      (begin
        (glClear (bitwise-or GL_COLOR_BUFFER_BIT
                             GL_DEPTH_BUFFER_BIT
                             GL_STENCIL_BUFFER_BIT))
        (nvgBeginFrame (GUI_context EXTEMPORE_GUI)
                       (convert (GUI_width EXTEMPORE_GUI))
                       (convert (GUI_height EXTEMPORE_GUI))
                       (GUI_pixel_ratio EXTEMPORE_GUI))
        (gui_render_subtree (GUI_root EXTEMPORE_GUI) (Rect 0. 0. (GUI_width EXTEMPORE_GUI) (GUI_height EXTEMPORE_GUI)))
        (nvgEndFrame (GUI_context EXTEMPORE_GUI))
        (glfwPollEvents)
        (glfwSwapBuffers (GUI_window EXTEMPORE_GUI)))
      void)))

;; some useful helper search functions

(bind-func gui_find_parent
  (lambda (widget:Widget*)
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     (lambda (w)
       (Widget_parent_p widget w)))))

(bind-func gui_find_leaf_preorder
  (lambda ()
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_leaf_inorder
  (lambda ()
    (Widget_find_inorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_leaf_postorder
  (lambda ()
    (Widget_find_postorder
     (GUI_root EXTEMPORE_GUI)
     Widget_leaf_p)))

(bind-func gui_find_widget_with_id
  (lambda (id)
    (Widget_find_preorder
     (GUI_root EXTEMPORE_GUI)
     (lambda (w)
       (= (Widget_id w) id)))))

(bind-func gui_find_next_id
  (lambda ()
    (let ((top_id -1))
      (Widget_walk_preorder
       (GUI_root EXTEMPORE_GUI)
       (lambda (w)
         (if (> (Widget_id w) top_id)
             (set! top_id (Widget_id w)))
         null))
      top_id)))

;; this is the all-singing, all-dancing "base" widget add function.
;; see below for helper functions which use sensible default
;; parameters
(bind-func gui_add_widget
  "add a new widget to the GUI

@param new_widget - widget to add
@param parent_widget - widget to split
@param split_size - relative size of the two new widgets, in (0,1)
@param vertical_p - split windows vertically? {0,1} otherwise split horizontally

If parent_widget is null, new_widget becomes the new GUI root node.
"
  (lambda (new_widget:Widget* parent_widget:Widget* split_size vertical_p:i32)
    (cond ((not (Widget_leaf_p new_widget))
           (println "gui_add_widget: cannot add non-leaf widget")
           0:i1)
          ((not (null? (gui_find_widget_with_id (Widget_id new_widget))))
           (println "gui_add_widget: cannot add widget, a widget with id equal" (Widget_id new_widget) "is already in the tree")
           0:i1)
          ((not (and (> split_size 0.)
                     (< split_size 1.)))
           (println "gui_add_widget: split_size must be between 0. and 1.")
           0:i1)
          ((null? parent_widget)
           (Widget_set_split new_widget split_size)
           (GUI_set_root EXTEMPORE_GUI new_widget)
           1:i1)
          (else
           (let ((grandparent_widget (Widget_parent parent_widget))
                 (new_lchild parent_widget)
                 (new_rchild new_widget)
                 (new_parent (Widget_h -1 ;; internal nodes have id -1
                                       split_size
                                       (Widget_type parent_widget)
                                       null
                                       grandparent_widget
                                       new_lchild
                                       new_rchild)))
             (if (<> vertical_p 0)
                 (Widget_type_add_flags new_parent GUI_SPLIT_VERTICAL))
             ;; reconnect the widget tree
             (Widget_set_parent new_lchild new_parent)
             (Widget_set_parent new_rchild new_parent)
             (if (null? grandparent_widget)
                 (GUI_set_root EXTEMPORE_GUI new_parent)
                 (if (equal (Widget_left_child grandparent_widget) parent_widget)
                     (Widget_set_left_child grandparent_widget new_parent)
                     (if (equal (Widget_right_child grandparent_widget) parent_widget)
                         (Widget_set_right_child grandparent_widget new_parent)
                         (begin (println "gui_add_widget: could not reconnect the widget tree")
                                (convert null Widget*)))))
             1:i1)))))

(bind-func gui_add_widget
  (lambda (new_widget split_size split_orientation)
    (gui_add_widget:[i1,Widget*,Widget*,float,i32]* new_widget (gui_find_leaf_preorder) split_size split_orientation)))

;; flip l and r child widgets of internal node

(bind-func Widget_swap_children
  (lambda (widget)
    (if (Widget_leaf_p widget)
        (println "gui_flip_widgets: cannot flip leaf widgets")
        (let ((old_left (Widget_left_child widget)))
          ;; swap the child widgets
          (Widget_set_left_child widget (Widget_right_child widget))
          (Widget_set_right_child widget old_left)
          void))))

(bind-func Widget_swap_split_orientation
  (lambda (widget)
    (if (Widget_leaf_p widget)
        (println "gui_flip_widgets: cannot flip leaf widgets")
        (begin
          (Widget_set_type widget (^ (Widget_type widget) GUI_SPLIT_VERTICAL))
          void))))

(bind-func gui_validate
  (lambda ()
    ;; check that all nodes are either full, or leaves
    (null?
     (Widget_find_preorder
      (GUI_root EXTEMPORE_GUI)
      (lambda (w)
        ;; need an exclusive or...
        (not (or (and (null? (Widget_left_child w))
                      (null? (Widget_right_child w)))
                 (and (not (null? (Widget_left_child w)))
                      (not (null? (Widget_right_child w)))))))))))

(bind-func gui_reset
  (lambda ()
    ;; free all the Widget memory, reset GUI_root
    (Widget_walk_postorder
     (GUI_root EXTEMPORE_GUI)
     (lambda (w) (Widget_free w) w))
    (GUI_set_root EXTEMPORE_GUI null)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; mouse/keyboard input ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; these functions are heavily glfw-based, and they must be called
;; from inside a widget callback, since they use the current nanovg
;; transform to do hit-detection

(bind-func gui_mouse_x
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos (GUI_window EXTEMPORE_GUI) x_ptr y_ptr)
      (convert (pref x_ptr 0) float))))

(bind-func gui_mouse_y
  (lambda ()
    (let ((x_ptr:double* (salloc))
          (y_ptr:double* (salloc)))
      (glfwGetCursorPos (GUI_window EXTEMPORE_GUI) x_ptr y_ptr)
      (convert (pref y_ptr 0) float))))

(bind-func gui_inbounds_p
  (lambda (bounds:Rect*)
    (let ((x (gui_mouse_x))
          (y (gui_mouse_y))
          (xmin (tref bounds 0))
          (xmax (+ xmin (tref bounds 2)))
          (ymin (tref bounds 1))
          (ymax (+ ymin (tref bounds 3))))
      ;; a simple hit-test
      (and (< xmin x) (> xmax x)
           (< ymin y) (> ymax y)))))

(bind-func gui_click_p
  (lambda (bounds:Rect* button)
    (and (gui_inbounds_p bounds)
         (= (glfwGetMouseButton (GUI_window EXTEMPORE_GUI)
                                button)
            GLFW_PRESS))))

(bind-func gui_left_click_p
  (lambda (bounds:Rect*)
    (gui_click_p bounds GLFW_MOUSE_BUTTON_1)))

(bind-func gui_right_click_p
  (lambda (bounds:Rect*)
    (gui_click_p bounds GLFW_MOUSE_BUTTON_2)))

(bind-func gui_enter_p
  (let ((prev 0)
        (curr 0))
    (lambda (bounds:Rect*)
      (set! curr (gui_inbounds_p bounds))
      (if (and (not prev) curr)
          (begin (set! prev curr) 1)
          (begin (set! prev curr) 0)))))

(bind-func gui_leave_p
  (let ((prev 0)
        (curr 0))
    (lambda (bounds:Rect*)
      (set! curr (gui_inbounds_p bounds))
      (if (and prev (not curr))
          (begin (set! prev curr) 1)
          (begin (set! prev curr) 0)))))

(bind-func gui_keypress_p
  (lambda (key)
    (= (glfwGetKey (GUI_window EXTEMPORE_GUI) key)
       GLFW_PRESS)))

(bind-func gui_keyrelease_p
  (lambda (key)
    (= (glfwGetKey (GUI_window EXTEMPORE_GUI) key)
       GLFW_RELEASE)))

;;;;;;;;;;;;;;;;;;;;
;; GUI appearance ;;
;;;;;;;;;;;;;;;;;;;;

;; Color themes

;; Primary colors
(bind-val GUI_COLOR_YELLOW NVGcolor*)
(bind-val GUI_COLOR_ORANGE NVGcolor*)
(bind-val GUI_COLOR_RED NVGcolor*)
(bind-val GUI_COLOR_MAGENTA NVGcolor*)
(bind-val GUI_COLOR_VIOLET NVGcolor*)
(bind-val GUI_COLOR_BLUE NVGcolor*)
(bind-val GUI_COLOR_CYAN NVGcolor*)
(bind-val GUI_COLOR_GREEN NVGcolor*)
(bind-val GUI_COLOR_GRAY NVGcolor*)
;; Darker and lighter accented colors
(bind-val GUI_COLOR_YELLOW_D NVGcolor*)
(bind-val GUI_COLOR_YELLOW_L NVGcolor*)
(bind-val GUI_COLOR_ORANGE_D NVGcolor*)
(bind-val GUI_COLOR_ORANGE_L NVGcolor*)
(bind-val GUI_COLOR_RED_D NVGcolor*)
(bind-val GUI_COLOR_RED_L NVGcolor*)
(bind-val GUI_COLOR_MAGENTA_D NVGcolor*)
(bind-val GUI_COLOR_MAGENTA_L NVGcolor*)
(bind-val GUI_COLOR_VIOLET_D NVGcolor*)
(bind-val GUI_COLOR_VIOLET_L NVGcolor*)
(bind-val GUI_COLOR_BLUE_D NVGcolor*)
(bind-val GUI_COLOR_BLUE_L NVGcolor*)
(bind-val GUI_COLOR_CYAN_D NVGcolor*)
(bind-val GUI_COLOR_CYAN_L NVGcolor*)
(bind-val GUI_COLOR_GREEN_D NVGcolor*)
(bind-val GUI_COLOR_GREEN_L NVGcolor*)
(bind-val GUI_COLOR_GRAY_D NVGcolor*)
(bind-val GUI_COLOR_GRAY_L NVGcolor*)
;; Adaptive colors
(bind-val GUI_COLOR_FG NVGcolor*)
(bind-val GUI_COLOR_BG NVGcolor*)
(bind-val GUI_COLOR_HL_LINE NVGcolor*)
(bind-val GUI_COLOR_HL NVGcolor*)
(bind-val GUI_COLOR_EMPH NVGcolor*)
(bind-val GUI_COLOR_COMMENTS NVGcolor*)

(bind-func gui_set_monokai_color_theme
  "set GUI_COLOR_* variables to Monokai color theme

Monokai was originally from Textmate, but has since been ported to
several different editors."
  (lambda ()
    ;; Primary colors
    (set! GUI_COLOR_YELLOW           (NVGcolor_hex #xE6DB74FF))
    (set! GUI_COLOR_ORANGE           (NVGcolor_hex #xFD971FFF))
    (set! GUI_COLOR_RED              (NVGcolor_hex #xF92672FF))
    (set! GUI_COLOR_MAGENTA          (NVGcolor_hex #xFD5FF0FF))
    (set! GUI_COLOR_VIOLET           (NVGcolor_hex #xAE81FFFF))
    (set! GUI_COLOR_BLUE             (NVGcolor_hex #x66D9EFFF))
    (set! GUI_COLOR_CYAN             (NVGcolor_hex #xA1EFE4FF))
    (set! GUI_COLOR_GREEN            (NVGcolor_hex #xA6E22EFF))
    (set! GUI_COLOR_GRAY             (NVGcolor_hex #x474747FF))
    ;; Darker and lighter accented colors
    (set! GUI_COLOR_YELLOW_D         (NVGcolor_hex #x968B26FF))
    (set! GUI_COLOR_YELLOW_L         (NVGcolor_hex #xF3EA98FF))
    (set! GUI_COLOR_ORANGE_D         (NVGcolor_hex #xA45E0AFF))
    (set! GUI_COLOR_ORANGE_L         (NVGcolor_hex #xFEB257FF))
    (set! GUI_COLOR_RED_D            (NVGcolor_hex #xA20C41FF))
    (set! GUI_COLOR_RED_L            (NVGcolor_hex #xFC5C94FF))
    (set! GUI_COLOR_MAGENTA_D        (NVGcolor_hex #xA41F99FF))
    (set! GUI_COLOR_MAGENTA_L        (NVGcolor_hex #xFE87F4FF))
    (set! GUI_COLOR_VIOLET_D         (NVGcolor_hex #x562AA6FF))
    (set! GUI_COLOR_VIOLET_L         (NVGcolor_hex #xC2A1FFFF))
    (set! GUI_COLOR_BLUE_D           (NVGcolor_hex #x21889BFF))
    (set! GUI_COLOR_BLUE_L           (NVGcolor_hex #x8DE6F7FF))
    (set! GUI_COLOR_CYAN_D           (NVGcolor_hex #x349B8DFF))
    (set! GUI_COLOR_CYAN_L           (NVGcolor_hex #xBBF7EFFF))
    (set! GUI_COLOR_GREEN_D          (NVGcolor_hex #x67930FFF))
    (set! GUI_COLOR_GREEN_L          (NVGcolor_hex #xC1F161FF))
    (set! GUI_COLOR_GRAY_D           (NVGcolor_hex #x333333FF))
    (set! GUI_COLOR_GRAY_L           (NVGcolor_hex #x6b6b6bFF))
    ;; Adaptive colors
    (set! GUI_COLOR_FG               (NVGcolor_hex #xF8F8F2FF))
    (set! GUI_COLOR_BG               (NVGcolor_hex #x272822FF))
    (set! GUI_COLOR_HL_LINE          (NVGcolor_hex #x3E3D31FF))
    (set! GUI_COLOR_HL               (NVGcolor_hex #x49483EFF))
    (set! GUI_COLOR_EMPH             (NVGcolor_hex #xF8F8F0FF))
    (set! GUI_COLOR_COMMENTS         (NVGcolor_hex #x75715EFF))
    void))

(bind-func gui_set_monokai_opensans_theme
  (lambda (font_path)
    ;; colors
    (gui_set_monokai_color_theme)
    ;; fonts
    (let ((vg (GUI_context EXTEMPORE_GUI)))
      (if (nvg_load_opensans_fonts vg font_path)
          (nvgFontFace vg "Bold"))
      (println "Set GUI theme: Monokai-OpenSans"))
    void))

(bind-func gui_set_default_theme
  (lambda (font_path)
    ;; colors
    (gui_set_monokai_color_theme)
    ;; fonts
    (if (< (nvgCreateFont (GUI_context EXTEMPORE_GUI) "default" font_path) 0)
        (printf "Error: couldn't load font %s\n" font_path)
        (printf "Set GUI theme: default\n"))
    void))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; nanovg draw helpers ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func gui_draw_text_in_bounds
  (lambda (bounds:Rect* text:String* font_size)
    (let ((vg (GUI_context EXTEMPORE_GUI)))
      ;; find bounds
      (let ((h (tref bounds 3))
            (textbox_height font_size)
            (b_ptr:float* (salloc 4)))
        (nvgTextAlign vg (bor NVG_ALIGN_BOTTOM NVG_ALIGN_CENTER))
        (nvgFontSize vg font_size)
        (nvgTextBoxBounds vg
                          (tref bounds 0)
                          (tref bounds 1)
                          (tref bounds 2)
                          (cstring text) null
                          b_ptr)
        (set! textbox_height (- (pref b_ptr 3) (pref b_ptr 1)))
        ;; draw text
        (nvgTextBox vg
                    (tref bounds 0)
                    (+ (tref bounds 1) (/ (+ (tref bounds 3) textbox_height) 2.0))
                    (tref bounds 2)
                    (cstring text) null)))))

(bind-func gui_draw_rect
  (lambda (bounds:Rect*)
    (nvgRect (GUI_context EXTEMPORE_GUI) (tref bounds 0) (tref bounds 1) (tref bounds 2) (tref bounds 3))))

(bind-func gui_draw_circle
  (lambda (x y radius)
    (nvgCircle (GUI_context EXTEMPORE_GUI) x y radius)))

;;;;;;;;;;;;;
;; widgets ;;
;;;;;;;;;;;;;

;; these are the standard widgets, but feel free to implement your own
;; custom ones - it's basically just an xtlang closure callback

(bind-val GUI_BUTTON i64 (<< 2 1))
(bind-val GUI_BUTTON_CHECKBOX i64 (<< 3 1))
(bind-val GUI_BUTTON_RADIO i64 (<< 4 1))
(bind-val GUI_TEXT i64 (<< 5 1))
(bind-val GUI_SLIDER i64 (<< 6 1))
(bind-val GUI_SLIDER2D i64 (<< 7 1))
(bind-val GUI_IMAGE i64 (<< 8 1))
(bind-val GUI_FBO i64 (<< 9 1))
(bind-val GUI_BLANK i64 (<< 10 1))

;; button

(bind-func Widget_button_c
  (lambda (label:i8* cb:[void]*)
    (let ((lab (String label))
          (click_p:i1 0)
          (prev_click_p:i1 0))
      (lambda (widget:Widget* bounds:Rect*)
        (let ((vg (GUI_context EXTEMPORE_GUI)))
          ;; toggle state
          (set! click_p (gui_left_click_p bounds))
          (if (and click_p (not prev_click_p))
              ;; fire callback
              (cb))
          (set! prev_click_p click_p)
          ;; call the callback
          ;; draw background
          (nvgBeginPath vg)
          (cond (click_p
                 (nvgFillColor vg GUI_COLOR_EMPH))
                ((gui_inbounds_p bounds)
                 (nvgFillColor vg GUI_COLOR_HL))
                (else
                 (nvgFillColor vg GUI_COLOR_BG)))
          (gui_draw_rect bounds)
          (nvgFill vg)
          ;; draw text
          (nvgBeginPath vg)
          (if click_p
              (nvgFillColor vg GUI_COLOR_BG)
              (nvgFillColor vg GUI_COLOR_FG))
          (gui_draw_text_in_bounds bounds lab 30.)
          (nvgFill vg))))))

(bind-func Widget_button
  "create a button widget

@param label - a text label for the button
@param cb - button callback (called when button is clicked)

The widget will be assigned the next available id based on the current state of the GUI
"
  (lambda (label:i8* cb)
    (Widget_with_cb (+ (gui_find_next_id) 1) .5 GUI_BUTTON (Widget_button_c label cb))))

(bind-func Widget_button
  "create a button widget with a specified id

@param label - a text label for the button
@param cb - button callback (called when button is clicked)
@param id - an id handle for the widget
"
  (lambda (label:i8* cb id)
    (Widget_with_cb id .5 GUI_BUTTON (Widget_button_c label cb))))

;; checkbox

(bind-func Widget_checkbox_c
  (lambda (label:i8* cb:[void,i1]*)
    (let ((lab (String label))
          (state:i1 0)
          (click_p:i1 0)
          (prev_click_p:i1 0))
      (lambda (widget:Widget* bounds:Rect*)
        (let ((vg (GUI_context EXTEMPORE_GUI)))
          ;; toggle state
          (set! click_p (gui_left_click_p bounds))
          (if (and click_p (not prev_click_p))
              (begin
                (set! state (not state))
                ;; fire callback
                (cb state)))
          (set! prev_click_p click_p)
          ;; draw widget
          (nvgBeginPath vg)
          ;; checkboxes are edge-triggered on state change
          (if state
              (nvgFillColor vg GUI_COLOR_GREEN_L)
              (nvgFillColor vg GUI_COLOR_GREEN_D))
          (gui_draw_rect bounds)
          (nvgFill vg)
          (nvgFillColor vg GUI_COLOR_BG)
          (nvgBeginPath vg)
          (gui_draw_text_in_bounds bounds lab 30.)
          (nvgFill vg))))))

(bind-func Widget_checkbox
  "create a checkbox widget

@param label - a text label for the checkbox
@param cb - checkbox callback (called when checkbox is toggled)

The widget will be assigned the next available id based on the current state of the GUI
"
  (lambda (label:i8* cb)
    (Widget_with_cb (+ (gui_find_next_id) 1) .5 GUI_BUTTON_CHECKBOX (Widget_checkbox_c label cb))))

(bind-func Widget_checkbox
  "create a checkbox widget with a specified id

@param label - a text label for the checkbox
@param cb - checkbox callback (called when checkbox is toggled)
@param id - an id handle for the widget
"
  (lambda (label:i8* cb id)
    (Widget_with_cb id .5 GUI_BUTTON_CHECKBOX (Widget_checkbox_c label cb))))

;; radio

(bind-func Widget_radio_c
  (lambda (label:i8* cb:[void,i32]* nstates:i32)
    (let ((lab (String label))
          (state:i32 0)
          (old_state:i32 -1)
          (click_p:i1 0)
          (prev_click_p:i1 0))
      (lambda (widget:Widget* bounds:Rect*)
        (let ((vg (GUI_context EXTEMPORE_GUI))
              (parent (Widget_parent widget))
              (vertical_p (or (null? parent)
                              (Widget_split_vertical_p parent)))
              (pos (if vertical_p
                       (/ (- (gui_mouse_x) (tref bounds 0))
                          (tref bounds 2))
                       (/ (- (gui_mouse_y) (tref bounds 1))
                          (tref bounds 3))))
              (button_bounds:Rect* (salloc)))
          ;; toggle state
          (set! click_p (gui_left_click_p bounds))
          (if (and click_p (not prev_click_p))
              (begin
                (set! state (convert (* (convert nstates float) pos)))
                ;; fire callback if state has changed
                (if (<> state old_state)
                    (cb state))
                (set! old_state state)))
          (set! prev_click_p click_p)
          ;; draw widgets
          (doloop (i nstates)
            (if vertical_p
                (tfill! button_bounds
                        (+ (tref bounds 0)
                           (* (/ (tref bounds 2) (convert nstates)) (convert i)))
                        (tref bounds 1)
                        (/ (tref bounds 2) (convert nstates))
                        (tref bounds 3))
                (tfill! button_bounds
                        (tref bounds 0)
                        (+ (tref bounds 1)
                           (* (/ (tref bounds 3) (convert nstates)) (convert i)))
                        (tref bounds 2)
                        (/ (tref bounds 3) (convert nstates))))
            (nvgBeginPath vg)
            (nvgStrokeColor vg GUI_COLOR_BG)
            (if (= i state)
                (nvgFillColor vg GUI_COLOR_MAGENTA_L)
                (nvgFillColor vg GUI_COLOR_MAGENTA_D))
            (gui_draw_rect button_bounds)
            (nvgFill vg)
            (nvgStroke vg))
          ;; (nvgFillColor vg GUI_COLOR_BG)
          ;; (nvgBeginPath vg)
          ;; (gui_draw_text_in_bounds bounds lab 30.)
          ;; (nvgFill vg)
          void)))))

(bind-func Widget_radio
  "create a radio button widget

@param label - a text label for the radio button
@param cb - radio button callback (called when radio button is toggled)
@param nstates - number of states for the radio button

The widget will be assigned the next available id based on the current state of the GUI
"
  (lambda (label:i8* cb nstates)
    (Widget_with_cb (+ (gui_find_next_id) 1) .5 GUI_BUTTON_CHECKBOX (Widget_radio_c label cb nstates))))

(bind-func Widget_radio
  "create a radio button widget with a specified id

@param label - a text label for the radio button
@param cb - radio button callback (called when radio button is toggled)
@param nstates - number of states for the radio button
@param id - an id handle for the widget
"
  (lambda (label:i8* cb nstates id)
    (Widget_with_cb id .5 GUI_BUTTON_CHECKBOX (Widget_radio_c label cb nstates))))

;; slider

(bind-func Widget_slider_c
  (lambda (label:i8* cb:[void,float]*)
    (let ((lab (String label))
          (slider_pos 0.))
      (lambda (widget:Widget* bounds:Rect*)
        (let ((vg (GUI_context EXTEMPORE_GUI))
              (parent (Widget_parent widget))
              (click_p (gui_left_click_p bounds))
              (vertical_p (or (null? parent)
                              (Widget_split_vertical_p parent))))
          ;; toggle state
          (if click_p
              (begin
                (set! slider_pos
                      (if vertical_p
                          (/ (- (gui_mouse_x) (tref bounds 0))
                             (tref bounds 2))
                          (/ (- (gui_mouse_y) (tref bounds 1))
                             (tref bounds 3))))
                (cb slider_pos)))
          ;; draw background
          (nvgBeginPath vg)
          (nvgFillColor vg GUI_COLOR_BLUE_D)
          (gui_draw_rect bounds)
          (nvgFill vg)
          ;; draw "marker"
          (nvgBeginPath vg)
          (if click_p
              (nvgFillColor vg GUI_COLOR_BLUE_L)
              (nvgFillColor vg GUI_COLOR_BLUE))
          (let ((slider_rect:Rect* (salloc)))
            (if vertical_p
                (tfill! slider_rect
                        (+ (* (tref bounds 2) slider_pos) (tref bounds 0) -10.)
                        (tref bounds 1)
                        20.
                        (tref bounds 3))
                (tfill! slider_rect
                        (tref bounds 0)
                        (+ (* (tref bounds 3) slider_pos) (tref bounds 1) -10.)
                        (tref bounds 2)
                        20.))
            (gui_draw_rect slider_rect))
          (nvgFill vg)
          (nvgFillColor vg GUI_COLOR_BG)
          (nvgBeginPath vg)
          (gui_draw_text_in_bounds bounds lab 30.)
          (nvgFill vg))))))

(bind-func Widget_slider
  "create a slider widget

@param label - a text label for the slider
@param cb - slider callback (called when slider is moved)

The widget will be assigned the next available id based on the current state of the GUI
"
  (lambda (label:i8* cb)
    (Widget_with_cb (+ (gui_find_next_id) 1) .5 GUI_SLIDER (Widget_slider_c label cb))))

(bind-func Widget_slider
  "create a slider widget with a specified id

@param label - a text label for the slider
@param cb - slider callback (called when slider is moved)
@param id - an id handle for the widget
"
  (lambda (label:i8* cb id)
    (Widget_with_cb id .5 GUI_SLIDER (Widget_slider_c label cb))))

;; slider 2D

(bind-func Widget_slider2D_c
  (lambda (label:i8* cb:[void,float,float]*)
    (let ((lab (String label))
          (slider_xpos .5)
          (slider_ypos .5))
      (lambda (widget:Widget* bounds:Rect*)
        (let ((vg (GUI_context EXTEMPORE_GUI))
              (click_p (gui_left_click_p bounds)))
          ;; toggle state
          (if click_p
              (begin (set! slider_xpos
                           (/ (- (gui_mouse_x) (tref bounds 0))
                              (tref bounds 2)))
                     (set! slider_ypos
                           (/ (- (gui_mouse_y) (tref bounds 1))
                              (tref bounds 3)))
                     (cb slider_xpos slider_ypos)))
          ;; draw background
          (nvgBeginPath vg)
          (nvgFillColor vg GUI_COLOR_ORANGE_D)
          (gui_draw_rect bounds)
          (nvgFill vg)
          ;; draw "marker"
          (nvgBeginPath vg)
          (if click_p
              (nvgFillColor vg GUI_COLOR_ORANGE_L)
              (nvgFillColor vg GUI_COLOR_ORANGE))
          (gui_draw_circle (+ (* (tref bounds 2) slider_xpos)
                              (tref bounds 0))
                           (+ (* (tref bounds 3) slider_ypos)
                              (tref bounds 1))
                           10.)
          (nvgFill vg)
          (nvgFillColor vg GUI_COLOR_BG)
          (nvgBeginPath vg)
          (gui_draw_text_in_bounds bounds lab 30.)
          (nvgFill vg))))))

(bind-func Widget_slider2D
  "create a 2D slider widget

@param label - a text label for the slider
@param cb - slider callback (called when slider is moved)

The widget will be assigned the next available id based on the current state of the GUI
"
  (lambda (label:i8* cb)
    (Widget_with_cb (+ (gui_find_next_id) 1) .5 GUI_SLIDER2D (Widget_slider2D_c label cb))))

(bind-func Widget_slider2D
  "create a 2D slider widget with a specified id

@param label - a text label for the slider
@param cb - slider callback (called when slider is moved)
@param id - an id handle for the widget
"
  (lambda (label:i8* cb id)
    (Widget_with_cb id .5 GUI_SLIDER2D (Widget_slider2D_c label cb))))

;; running the GUI interaction loop

(bind-func gui_render_loop
  (let ((stop #f))
    (lambda (time:i64 delta_t:double)
      (if stop
        (begin
          (set! stop #f)
          void)
        (begin
          (gui_render)
          (let ((next_time (+ time (convert (* 44100. delta_t)))))
            (callback next_time gui_render_loop next_time delta_t)))))))

;; to start the render loop - call this after (gui_init)
;; (gui_render_loop (now) (/ 1. 30.))
;; to stop it:
;; (gui_render_loop.stop #t)

;; to close the gui window:
;; (gui_shutdown)

(bind-func gui_shutdown
  (lambda ()
    (gui_reset)
    (if (not (null? (GUI_context EXTEMPORE_GUI)))
      (nvgDeleteGL3 (GUI_context EXTEMPORE_GUI)))
    (tset! EXTEMPORE_GUI 1 null)
    (if (not (null? (GUI_window EXTEMPORE_GUI)))
      (glfwDestroyWindow (GUI_window EXTEMPORE_GUI)))
    (tset! EXTEMPORE_GUI 0 null)))

(impc:aot:insert-footer "xtmgui")
(define *xtmlib-gui-loaded* #t)
