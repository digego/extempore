;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; rhythm map + looper
;; 

(define *RMAP_HELPER_CALLBACK_OFFSET* 2048) 

;; this function is for mananing symbols inside a pattern _ for rest etc..
(define rmap_helper_lst_sym_transform
  (lambda (lst)
    (if (atom? lst) (set! lst (list lst)))
    (if (and (= (length lst) 1) (null? (car lst))) (set! lst `(_)))
    (apply append '()
      (map (lambda (elt next)
            (cond ((and (vector? elt) (symbol? next))
                    (list elt))
                  ((list? elt) 
                   (if (= (length elt) 1) 
                       elt 
                       (list elt)))
                  (else (list elt))))
           lst
           (append (cdr lst) '(0))))))

(define rmap_helper
  (lambda (beats offset func beat dur loopcnt looppos . args)
    (let* ((lst (rmap_helper_lst_sym_transform (if (list? (car args)) 
                                                   (car args)
                                                   (if (pair? (car args)) 
                                                       (car (car args)) 
                                                       '(_ _ _ _)))))
           (pos (modulo (- looppos offset) beats)) ;;(modulo (- beat offset) beats))
           (one_beat (/ beats (length lst)))
           (lst_positions (range 0 (+ pos beats) one_beat))
           (nextpos (+ pos dur))
           (idx 0)
           (f (lambda (old new)
                (set! idx (+ idx 1))
                (if (and (>= new pos) (< new nextpos))
                    (cons (cons new idx) old)
                    old)))
           (newlst (foldl f '() lst_positions)))
      (map (lambda (t)
              (let* ((tmpargs (map (lambda (l) 
                                     (if (list? l)
                                         (set! l (rmap_helper_lst_sym_transform l))
                                         (if (pair? l)
                                             (set! l ((eval (cdr l)) (rmap_helper_lst_sym_transform (car l))))
                                             (set! l (list l))))
                                     (if (< (length l) (cdr t))
                                         (list-ref l (modulo (- (cdr t) 1) (length l)))
                                         (list-ref l (- (cdr t) 1))))
                                   args))
                     (targs (map (lambda (l) 
                                    (cond ((vector? l) (map (lambda (x) (eval x)) (vector->list l)))
                                          ((and (symbol? l) (not (equal? l '_))) (eval l))
                                          (else l)))
                                 tmpargs)))
                (if (or (list? (car tmpargs)) (pair? (car tmpargs)))
                    (apply rmap_helper one_beat offset func (+ beat (- (car t) pos)) one_beat loopcnt (+ looppos (- (car t) pos)) targs)
                    (if (not (and (symbol? (car tmpargs)) (equal? (car tmpargs) '_)))
                        (apply callback 
                               (- (*metro* (+ beat (- (car t) pos))) *RMAP_HELPER_CALLBACK_OFFSET*) 
                               func (+ beat (- (car t) pos)) one_beat 
                               loopcnt targs)))))
           newlst))))

;; rhythm map
;; rmap expects f to take beat + dur + length(lsts) args.
(define-macro (rmap beats offset f loopcnt looppos . lsts)
  `(rmap_helper ,beats ,offset ,f beat dur ,loopcnt ,looppos ,@lsts))

;;
;; example usage
;;

;; (define test
;;   (lambda (beat dur)
;;     (rmap 4 0 (lambda (beat dur p r)
;;                 (play pad p 80 r))
;;               `(60 70 80)
;;               `(1 0.5 0.2))
;;     (callback (*metro* (+ beat (* .5 dur))) 'test (+ beat dur) dur)))
;;
;; (test (*metro* 'get-beat 4) 1/4)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 'in place' looping based on rmap
;;
(define-macro (rmap-loop-runner name tagtime run beatsexpr offsetexpr expr . lsts)
  (let* ((loopcnt 0)
        (f `(lambda ,(cons 'beat (cons 'dur (cons 'loop (map (lambda (x) 
                                              (string->symbol (string-append "@" (number->string x)))) 
                                            (range 1 (+ 1 (length lsts)))))))
                    ,expr))
        (beats (eval beatsexpr))
        (offset (eval offsetexpr))
        (running? (closure? name)))
    (if (equal? run 'modify) (println 'Modifying: name))
    (begin (eval `(define ,name 
                   (lambda (beat totaldur loopcnt dur) 
                      (define beats ,beatsexpr)
                      (define offset ,offsetexpr)
                      (define LC loopcnt)
                      (set! ,tagtime (now))
                      (rmap beats offset ,f loopcnt totaldur ,@lsts)
                      (if ,(if (equal? run 'stop) #t #f)
                          (begin (println 'Stopping_: ',name) 
                                 (eval '(define ,name #f) (interaction-environment))
                                 #f)
                          (callback (*metro* (+ beat (* .5 dur))) ',name (+ beat dur) 
                                    (if (= (+ totaldur dur) beats) 0 (+ totaldur dur))
                                    (if (= (+ totaldur dur) beats) (+ loopcnt 1) loopcnt)
                                    ,(if (> beats 1) 1/2 (/ beats 2))))))
                (interaction-environment))
            (if (equal? run 'start)
                (eval `(begin (println 'Starting_: ',name) 
                              (,name (*metro* 'get-beat 4) 0 0 (if (> ,beats 1) 1/2 (/ ,beats 2))))
                       (interaction-environment))))))

;; start or modify looper
(define-macro (:> tag . args)
  (let ((tagtime (string->symbol (string-append (symbol->string tag) "_tagtime"))))
    (if (not (defined? tagtime)) (eval `(define ,tagtime (now)) (interaction-environment)))
    (if (< (eval tagtime) (- (now) (* 2 *second*)))
        (eval `(define ,tag #f) (interaction-environment)))
    (if (and (defined? tag) (closure? (eval tag)))
        `(rmap-loop-runner ,tag ,tagtime modify ,@args)  
        `(rmap-loop-runner ,tag ,tagtime start ,@args))))

;; stop looper
(define-macro (:| tag . args) 
  (let ((tagtime (string->symbol (string-append (symbol->string tag) "_tagtime"))))       
    (if (defined? tag)
        (begin (callback (+ (now) *second*) eval `(define ,tag #f) (interaction-environment))
              `(rmap-loop-runner ,tag ,tagtime stop ,@args)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; additional helpers

(define-macro (orbit m . args)
  (cond ((= (length args) 1)
          `(if (= 0 (modulo loopcnt ,m)) ,(car args) '_))
        ((= (length args) 2)
          `(if (= 0 (modulo loopcnt ,m)) ,(car args) ,(cadr args)))
        (else 
          `(if (= 0 (modulo (+ ,(car args) loopcnt) ,m)) ,(cadr args) ,(caddr args)))))
