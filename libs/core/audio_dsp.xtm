;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: 

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; lib-loading config
(sys:load "libs/audio_dsp.xtm")
(sys:load-preload-check 'audio_dsp)
(define *xtmlib-audio_dsp-loaded* #f)

;; try a precompiled one first

(set! *sys:precomp:suppress-precomp* #t)
(sys:load "libs/math.xtm")
(sys:precomp:insert-sexp '(sys:load "libs/math.xtm"))
;; else compile from scratch
(sys:load "libs/core/math.xtm")
(set! *sys:precomp:suppress-precomp* #f)

(sys:precomp:insert-header "xtmaudio_dsp")

;; do you want to compile multichannel extensions
;; usually NOT
(define *build-multi-chan* #t)

(bind-val SPI SAMPLE 3.1415926535897932384626433832795028841971693993751058209749)
(bind-val STWOPI SAMPLE 6.2831853071795864769252867665590057683943387987502116419498)
(bind-val SE SAMPLE 2.7182818284590452353602874713526624977572470936999595749669)

;; bind some global audio values
(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE SAMPLE (integer->real *au:samplerate*))
           (bind-val SR SAMPLE (integer->real *au:samplerate*))))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 *au:channels*))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 *au:in-channels*))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 *au:block-size*))

(bind-alias DSP [SAMPLE,SAMPLE,i64,i64,SAMPLE*]*)
(bind-alias DSPMT [SAMPLE,SAMPLE*,i64,i64,SAMPLE*]*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" (ftod (convert SAMPLERATE)))))

(print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
(bind-func dsp:DSP
  (lambda (in time chan dat)
    0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; metronome
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; tempo,offset,mark,total-beats,cycle-beats,beat-env,samp-env
(bind-type Metronome <Rational,i64,i64,Rational,Rational,[Rational,Rational]*,[Rational,Rational]*>)

(bind-func MakeMetro_3
  (lambda (tempo offset:i64 beat:Rational)
    (let ((tempoR (/ 60 (Rat (dtoi64 (* 100. tempo)) 100)))
          (line (lambda (x1:Rational y1:Rational x2:Rational y2:Rational)
                  (let ((m (if (= (Rat 0 1) (- x2 x1))
                               (Rat 0 1)
                               (/ (- y2 y1) (- x2 x1))))
                        (c (- y1 (* m x1))))
                    (lambda (t:Rational)
                      (+ (* t m) c))))))
      (Metronome tempoR 0 offset beat (Rat 4 1)
                 (line (Rat offset 1) beat
                       (+ offset (* tempoR (convert SR i64)))
                       (+ beat 1/1))
                 (line beat (Rat offset 1)
                       (+ beat 1/1)
                       (+ offset (* tempoR (convert SR i64))))))))

(bind-func MakeMetro_1
  (lambda (tempo)
    (MakeMetro_3 tempo (now) (Rat 0 1))))

(bind-func MakeMetro_4
  (lambda (tempo offset beatn beatd)
    (MakeMetro_3 tempo offset (Rat beatn beatd))))

(bind-poly MakeMetro MakeMetro_3)
(bind-poly MakeMetro MakeMetro_1)
(bind-poly MakeMetro MakeMetro_4)

(bind-func metro_get_time
  (lambda (m:Metronome* beat:Rational)
    (+ (dtoi64 (* 1.0 ((tref m 6) beat))) (tref m 1))))

(bind-func metro_get_beat
  (lambda (m:Metronome* time:i64)
    ((tref m 5) (Rat time 1))))

(bind-func metro_get_quantized
  (lambda (m:Metronome* q:Rational)
    (let ((val (+ (tref m 3) ;; total beats
                  (/ (- (now) (tref m 2)) ;; mark
                     (* (convert SR i64) (tref m 0)))))
          (q2 (- q (% val q))))
      (+ val (- q (% val q))))))

(bind-func metro_get_tempo
  (lambda (m:Metronome*)
    (/ 60 (tref m 0))))

(bind-func metro_get_duration
  (lambda (m:Metronome* dur:Rational)
    (convert (* SR (* dur (tref m 0))) i64)))

(bind-func print_metronome:[void,Metronome*]*
  (lambda (m)
    (println "Metronome>> bpm:" (metro_get_tempo m) "beats:" (tref m 3))))

(bind-poly print print_metronome)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; some simple conversions 
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func amp2db  
  (lambda (x:SAMPLE)
    (* 20. (log10 x))))

(bind-func db2amp
  (lambda (x:SAMPLE)
    (pow 10. (/ x 20.))))


;; root mean squared (mono passthrough)
;; grab current rms value from val:
;;
;; updates db every FRAMES
;; passes mono signal straight through
;;
;; DB is (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_c
  (lambda ()
    (let ((d:SAMPLE* (alloc FRAMES))
          (t 0)
          (db:SAMPLE 0.0))
      (lambda (x:SAMPLE)
        (pset! d (% t FRAMES) (* x x))
        (set! t (+ t 1))
        (if (= 0 (% t FRAMES))
            (set! db (+ 3.0 (amp2db (sqrt (mean d FRAMES))))))
        x))))

;; rms
;;
;; left and right are db
;; (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_st_c
  (lambda ()
    (let ((lgth (* 1 FRAMES))
          (dl:SAMPLE* (alloc lgth))
          (dr:SAMPLE* (alloc lgth))
          (t 0)
          (left:SAMPLE 0.0)
          (right:SAMPLE 0.0))
      (lambda (chan:i64 x:SAMPLE)
        (if (= chan 0)
            (begin (pset! dl (% t lgth) (* x x))
                   (set! t (+ t 1))
                   ;;(printf "left %f\n" (ftod left))
                   (if (= 0 (% t lgth))
                       (begin
                         (set! left (+ 3.0 (amp2db (sqrt (mean dl lgth)))))
                         (set! right (+ 3.0 (amp2db (sqrt (mean dr lgth)))))))
                   void)
            (begin (pset! dr (% t lgth) (* x x))
                   void))
        x))))

;; amount of curve
;;
;; width is duration of the curve
;;
;; the 'power' value of the curve
;; can be negative!
;;
;; 1.0 or 0.0 = flat (returns 1.0)
;; 1.01 = close to linear
;; 2.0 = normal value
;; 6.0 = steeper curve etc..
;;
;; time 0.0 -> width
(bind-func gain:[SAMPLE,i64,i64,SAMPLE]*
  (lambda (time width power)
    (let ((amp 1.0)
          (p:double (convert power))
          (t (/ (i64tod time) (i64tod width))))
      (if (< p 0.0)
          (begin (set! p (fabs p))
                 (set! t (- 1.0 t))))
      (let ((out (* amp (/ (- (pow p t) 1.0) (- p 1.0)))))
        (convert
         (if (> out amp) amp
             (if (< out 0.0) 0.0
                 out)))))))


;; given current channel
;; and pan value [0.0-1.0]
;; returns value betwee n [0.0-1.0]
;; uses CHANNELS
(bind-func panner
  (lambda (chan:i64 pan)
    (let ((cn1:SAMPLE (convert (- CHANNELS 1))))
      (- 1.0 (/ (fabs (- (* pan cn1) (convert chan))) cn1)))))


;; a repeating hann signal of width
;;
;; where a cycle is
;; time 0.0 -> width
;; 
;; repeat is:
;; 1.0 - repeat immediately
;; 2.0 - repeat after two cycles
;; 4.0 - repeat after four cycles etc..
;;
(bind-func hann
  (lambda (time:i64 width:i64 repeat:i64)
    (if (> (% time (* width repeat)) width) 0.0
        (* 0.5
           (- 1.0
              (cos (* STWOPI (/ (convert time)
                                (convert width)))))))))

;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:i64 apex:i64)
    (let ((h:SAMPLE (convert (* time apex))))
      (* h (exp (- 1.0 h))))))



;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html
(bind-func dsp_randn
  (let ((phase:i64 0))
    (lambda ()
      (let ((u1:SAMPLE (random))
	    (u2:SAMPLE (random))
	    (v1 (- (* 2.0 u1) 1.0))
	    (v2 (- (* 2.0 u2) 1.0))
	    (s (+ (* v1 v1) (* v2 v2))))
	(if (= phase 0)
	    (if (or (> s 1.0) (= s 0.0) (= s 1.0))
		(dsp_randn)
		(* v1 (sqrt (/ (* -2.0 (log s)) s))))
	    (begin (set! phase (- 1 phase))
		   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; x values must fall within the range -PI ... PI
(bind-func _sin
  (let ((p 0.225) ; :_abuf* (alloc))
	(b (/ 4.0 SPI))
	(c (/ -4.0 (* SPI SPI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
	(+ (* p (- (* y (fabs y)) y)) y)))))

;; (bind-func osc_c
;;   (lambda (phase)
;;     (lambda (amp freq)
;;       (let ((inc (* TWOPI (/ freq SAMPLERATE))))
;; 	(set! phase (+ phase inc))
;; 	(* amp (sin phase))))))


(bind-func osc_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* STWOPI (/ freq SAMPLERATE))))
	(set! phase (+ phase inc))
	(if (> phase SPI) (set! phase (- phase STWOPI)))
	(* amp (_sin phase))))))


(if *build-multi-chan*
    (bind-func osc_mc_c
      (lambda (phase)
	(let ((val 0.0)
	      (osc (osc_c phase)))
	  (lambda (chan:i64 amp freq)
	    (if (= chan 0) (set! val (osc amp freq)))
	    val)))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  (lambda (phase)   
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
	(* amp (tanh (* n (osc 1.0 freq))))))))


;; square oscillator multichannel
(if *build-multi-chan*
    (bind-func square_mc_c
      (lambda (phase)   
	(let ((sqr (square_c phase))
	      (mem 0.0))
	  (lambda (chan:i64 amp freq n)	
	    (if (= chan 0) (set! mem (sqr amp freq n)))
	    mem)))))

;; a 'leaky' integrator
(bind-func integrator_c
  (let ((old 0.0)
        (leak 0.99))
    (lambda (x)
      (set! old (+ (* leak old) x))
      old)))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  (lambda (phase)   
    (let ((osc (osc_c phase))	  
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
	(set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

;; saw oscillator
(if *build-multi-chan*
    (bind-func triangle_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (tri (triangle_c phase)))
	  (lambda (chan:i64 amp freq n)
	    (if (= chan 0) (set! mem (tri amp freq n)))
	    mem)))))

;; rect wave oscillator - useful for pulse width modulation
(bind-func rect_c
  (lambda (phase)
    (lambda (amp:SAMPLE freq duty)
      (let ((inc (/ freq SAMPLERATE)))
	(set! phase (+ phase inc))
	(if (> phase 1.0) (set! phase (- phase 1.0)))
	(if (< phase duty) amp (* -1.0 amp))))))

(if *build-multi-chan*
    (bind-func rect_mc_c
      (lambda (phase)
        (let ((val 0.0)
              (rect (rect_c phase)))
          (lambda (chan:i64 amp freq duty)
            (if (= chan 0) (set! val (rect amp freq duty)))
            val)))))

;; saw oscillator
(bind-func saw_c
  (lambda (phase)
    (let ((dp 1.0)
	  (x:SAMPLE 0.0)
          (limitchk:SAMPLE 0.000001)
	  (leak 0.995)
	  (saw 0.0))
      (lambda (amp freq)
	(let* ((qmax (* 0.5 (/ SAMPLERATE freq)))
	       (dc (/ -0.498 qmax)))
	  (set! phase (+ phase dp))
	  (if (< phase 0.0) 
	      (begin (set! phase (- 0.0 phase))
		     (set! dp (- 0.0 dp)))
	      (if (> phase qmax)
		  (begin (set! phase (+ qmax (- qmax phase)))
			 (set! dp (- 0.0 dp)))))
	  (set! x (* SPI phase))
	  (if (< x limitchk) (set! x limitchk))
	  (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
	  (* amp saw))))))


;; saw oscillator
(if *build-multi-chan*
    (bind-func saw_mc_c
      (lambda (phase)
	(let ((mem 0.0)
	      (saw (saw_c phase)))
	  (lambda (chan:i64 amp freq)
	    (if (= chan 0) (set! mem (saw amp freq)))
	    mem)))))

;; white noise generator
(bind-func white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; pulse train
(bind-func pulse_c
  (lambda ()
    (let ((time -1.0)
          (period:SAMPLE 0.0))
      (lambda (amp:SAMPLE freq width)
	(set! period (/ SAMPLERATE freq))
        (set! time (+ time 1.0))
        (if (< (modulo time period) width)
            amp
            0.0)))))

(if *build-multi-chan*
    (bind-func pulse_mc_c
      (lambda ()
	(let ((pulse (pulse_c))
	      (mem 0.0))
	  (lambda (chan:i64 amp freq width)
	    (if (= chan 0) (set! mem (pulse amp freq width)))
	    mem)))))

;; linear fade closure
(bind-func fade_c
  (lambda ()
    (let ((t 0.0)
          (inc (/ 1.0 SR)))
      (lambda (initial:SAMPLE final dur)
        (set! t (+ t inc))
        (if (> t dur)
            final
            (+ initial (* (/ t dur) (- final initial))))))))

(if *build-multi-chan*
    (bind-func fade_mc_c
      (lambda ()
	(let ((val 0.0)
	      (fader (fade_c )))
	  (lambda (chan:i64 initial final dur)
	    (if (= chan 0) (set! val (fader initial final dur)))
	    val)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_old_c
  (lambda (max_delay)
    (let ((line:SAMPLE* (zalloc max_delay))
	  (time 0)
	  (delay max_delay)
	  (in 1.0)
	  (out 0.5))
      (lambda (x:SAMPLE)
	(let* ((n (modulo time delay))
	       (delayed (pref line n))
	       (y (+ (* in x) (* out delayed))))
	  (pset! line n y)
	  (set! time (+ time 1))
	  y)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c 
  (lambda (max_delay:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
	  (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE wet feedback)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
    (bind-func delay_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
	  (lambda (chan:i64 x wet feedback)
	    ((pref dlines chan) x wet feedback))))))

(if *build-multi-chan*
    (bind-func delay_st_c
      (lambda (d1 d2)
	(let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc 2))
	      (i:i64 0))
	  (pset! dlines 0 (delay_c d1))
	  (pset! dlines 1 (delay_c d2))
	  (lambda (chan:i64 x wet feedback)
	    ((pref dlines chan) x wet feedback))))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
;;
;; offset is for metro 'get-mark offset
(bind-func delay_t_c 
  (lambda (max_delay offset:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
	  ;; (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE time:i64 wet:SAMPLE feedback:SAMPLE)
        (set! n (modulo (convert (- time offset)) delay))
        (set! y (pref line n))
        ;;(set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
    (bind-func delay_t_mc_c
      (lambda (channels:i64 max_delay:i64 offset:i64)
	(let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (delay_t_c max_delay offset)))
	  (lambda (chan:i64 x time:i64 wet:SAMPLE feedback)
	    ((pref dlines chan) x time wet feedback))))))

(if *build-multi-chan*
    (bind-func delay_t_st_c
      (lambda (d1 d2 offset)
	(let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc 2))
	      (i:i64 0))
	  (pset! dlines 0 (delay_t_c d1 offset))
	  (pset! dlines 1 (delay_t_c d2 offset))
	  (lambda (chan:i64 x time wet feedback)
	    ((pref dlines chan) x time wet feedback))))))




;; iir comb with interpolation
;; delay for COMB needs to stay
;; as a fractional argument (i.e. float)
(bind-func comb_c
  (lambda (max_delay:i64)    
    (let ((maxdelay max_delay)
          (line:SAMPLE* (zalloc maxdelay))
	  (in_head 0)
	  (out_head 0)
	  (delay_:SAMPLE (convert max_delay))
	  (alpha 0.0)
	  (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (x:SAMPLE delay:SAMPLE wet:SAMPLE feedback:SAMPLE)
	(if (<> delay delay_)
	    (begin (set! delay_ delay)		 
		   (set! alpha (- delay (floor delay)))
		   (set! om_alpha (- 1.0 alpha))
		   (set! out_head (- (+ maxdelay in_head)
				     (convert delay)))))
	(set! ih (modulo in_head maxdelay))
	(set! oh (modulo out_head maxdelay))
	(set! delayed1 (pref line oh))
	(set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
	(set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
	;;(set! y (+ (* in x) (* out delayed)))
        (pset! line ih (* feedback (+ x delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ x (* delayed wet))))))


(if *build-multi-chan*
    (bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
	(let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
	  (lambda (chan:i64 x delay wet feedback)
	    (let ((f (pref dlines chan)))
	      (f x delay wet feedback)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
    (let ((comb (comb_c (convert (+ delay mod_range))))
	  (mod (osc_c mod_phase)))
      (lambda (x:SAMPLE wet feedback)
	(comb x (+ delay (mod mod_range mod_rate)) wet feedback)))))


(if *build-multi-chan*
    (bind-func flanger_mc_c
      (lambda (channels:i64 delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
	(let ((comb (comb_mc_c channels (convert (+ delay mod_range))))
	      (mod (osc_mc_c mod_phase))
	      (i:i64 0))
	  (lambda (chan:i64 x wet feedback)
	    (comb chan x (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay:SAMPLE 700.)
	  (range:SAMPLE 200.)
	  (rate:SAMPLE 0.1)
	  (comb1 (comb_c (convert (+ delay range))))
	  (comb2 (comb_c (convert (+ delay range))))
	  (comb3 (comb_c (convert (+ delay range))))
	  (mrng1 range)
	  (mrng2 (* (random) range))
	  (mrng3 (* (random) range))
	  (mrte1 rate)
	  (mrte2 (* rate 1.372))
	  (mrte3 (* rate 0.792))
	  (dly1 delay)
	  (dly2 (* (random) delay))
	  (dly3 (* (random) delay))
	  (mod1 (osc_c phase))
	  (mod2 (osc_c phase))
	  (mod3 (osc_c phase)))
      (lambda (x:SAMPLE wet fb)
	(+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
	   (comb2 x (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
	   (comb3 x (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
    (bind-func chorus_mc_c
      (lambda (channels:i64 phase)
	(let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! dlines i (chorus_c phase)))
	  (lambda (chan:i64 x wet fb)
	    (let ((f (pref dlines chan)))
	      (f x wet fb)))))))


;; tap delay
(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:SAMPLE* (zalloc max_delay))
          (taps:i64* (zalloc num_of_taps))
          (delay max_delay)
          (time 0))
      (lambda (x:SAMPLE)
        (let ((y 0.0)
              (i 0)
              (n (modulo time delay))
              (gain (/ 1.0 (convert num_of_taps))))
          (pset! line n x)
          (dotimes (i num_of_taps)
            (set! y (+ y (* gain (pref line (% (+ (pref taps i) n) delay))))))
          (set! time (+ time 1))
          y)))))

(if *build-multi-chan*
    (bind-func tap_delay_mc_c
      (lambda (nchan:i64 max_delay num_of_taps)
        (let ((tap_delay_buf:[SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan)
            (pset! tap_delay_buf i (tap_delay_c max_delay num_of_taps)))
          (lambda (chan x)
            ((pref tap_delay_buf chan) x))))))

;; allpass
(bind-func allpass_old_c
  (lambda (delay)
    (let ((inline:SAMPLE* (zalloc delay))
	  (outline:SAMPLE* (zalloc delay))
	  (time 0)
	  (g 0.9))
      (lambda (x)
	(let* ((n (% time delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 g x)
		     dx
		     (* g dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))

;; allpass
(bind-func allpass_c
  (lambda (delay)
    (let ((_delay delay)
          (inline:SAMPLE* (zalloc _delay))
	  (outline:SAMPLE* (zalloc _delay))
	  (time 0))
      (lambda (x fb)
	(let* ((n (% time _delay))
	       (dy (pref outline n))
	       (dx (pref inline n))
	       (y (+ (* -1.0 fb x)
		     dx
		     (* fb dy))))
	  (pset! inline n x)
	  (pset! outline n y)
	  (set! time (+ time 1))
	  y)))))


(if *build-multi-chan*
    (bind-func allpass_mc_c
      (lambda (channels:i64 delay)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (allpass_c delay)))
	  (lambda (chan:i64 x wet)
	    (let ((f (pref lines chan)))
	      (f x wet)))))))


;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))

;; a dodgy reverb mk2
(bind-func reverb_old_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_old_c (convert (* ms (* .192 size)))))
	  (dly2 (delay_old_c (convert (* ms (* .373 size)))))
	  (dly3 (delay_old_c (convert (* ms (* .671 size)))))
	  (dly4 (delay_old_c (convert (* ms (* .712 size)))))
	  (ap1 (allpass_old_c (convert (* ms size))))
	  (ap3 (allpass_old_c (convert (* ms (* .929 size)))))
	  (ap2 (allpass_old_c (convert (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in:SAMPLE wet)
	(let ((wetin (* in wet)))
	  (+ (* in (- 1.0 wet))
	     (ap1 (ap2 (ap3 (+ (dly1 wetin)
			       (dly2 wetin)
			       (dly3 wetin)
			       (dly4 wetin)))))))))))


;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (dly1 (delay_c (convert (* ms (* .192 size)))))
	  (dly2 (delay_c (convert (* ms (* .373 size)))))
	  (dly3 (delay_c (convert (* ms (* .671 size)))))
	  (dly4 (delay_c (convert (* ms (* .712 size)))))
	  (ap1 (allpass_c (convert (* ms size))))
	  (ap3 (allpass_c (convert (* ms (* .929 size)))))
	  (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(if *build-multi-chan*
    (bind-func reverb_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb_c size)))
	  (lambda (chan:i64 x wet fb)
	    (let ((f (pref lines chan)))
	      (f x wet fb)))))))


;; a dodgy reverb mk2
(bind-func reverb2_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
	  (ap1 (allpass_c (convert (* ms size))))
	  (ap3 (allpass_c (convert (* ms (* .929 size)))))
	  (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(if *build-multi-chan*
    (bind-func reverb2_mc_c
      (lambda (channels:i64 size)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (reverb2_c size)))
	  (lambda (chan:i64 x wet)
	    (let ((f (pref lines chan)))
	      (f x wet)))))))



;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits:SAMPLE)
	(* amp (/ (floor (* in (pow 2. bits))) 
		  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in:SAMPLE h:SAMPLE)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))


(if *build-multi-chan*
    (bind-func hold_mc_c
      (lambda (channels:i64)
	(let ((holds:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! holds i (hold3_c)))
	  (lambda (chan:i64 x h)
	    (let ((f (pref holds chan)))
	      (f x h)))))))


;; a dodgy bitcrusher
(bind-func crush
  (lambda (in:SAMPLE bits:SAMPLE)
    (/ (floor (* in (pow 2. bits))) 
       (pow 2. bits))))


;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in:SAMPLE)
	(clamp lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores anything in on channel 2)
;; pan value [0.0-1.0]
(bind-func pan2
  (let ((out:SAMPLE 0.0))
    (lambda (x:SAMPLE chan:i64 pan)
      (if (= chan 0)
          (begin (set! out x) (* (- 1.0 pan) out))
          (* pan out)))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(if *build-multi-chan*
    (bind-func pan_mc
      (lambda (channels)
        (let ((v:SAMPLE 0.0)
              (out:SAMPLE 0.0))
          (lambda (x:SAMPLE chan:i64 pan)
            (if (= chan 0) (set! out x))
            (set! v (fabs (- (* (- channels 1.0) pan) (convert chan))))
            (if (> v 1.0) 0.0
                (* (- 1.0 v) out)))))))


;; simple stereo weights
(bind-func mix2
  (lambda (x:SAMPLE chan:i64 left right)
    (cond ((= chan 0) (* x left))
          ((= chan 1) (* x right))
          (else 0.0))))

;; simple quad weights
(bind-func mix4
  (lambda (x:SAMPLE chan c1 c2 c3 c4)
    (cond ((= chan 0) (* x c1))
	  ((= chan 1) (* x c2))
	  ((= chan 2) (* x c3))
	  ((= chan 3) (* x c4))
	  (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (lambda (cdat:SAMPLE* chan:i64 in:SAMPLE)
      (if (< chan channels)
          (* in (pref cdat chan))
          0.0))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from 
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func lpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (- 1.0 coso) 2.0))
	      (set! b1 (- 1.0 coso))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func lpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (lpf_c)))
	  (lambda (chan:i64 x freq res)
	    (let ((f (pref lines chan)))
	      (f x freq res)))))))


;; biquad high-pass filter
(bind-func hpf_c
  (lambda ()
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
	   (oldres 0.0)
	   (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
	;; if frequency changes
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> res oldres))
	    (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (/ sino (* 2.0 res))))
	      (set! oldfreq freq)
	      (set! oldres res)
	      (set! b0 (/ (+ 1.0 coso) 2.0))
	      (set! b1 (* -1.0 (+ 1.0 coso)))
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func hpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (hpf_c)))
	  (lambda (chan:i64 x freq res)
	    (let ((f (pref lines chan)))
	      (f x freq res)))))))


;; biquad band-pass filter
(bind-func bpf_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
           (two:SAMPLE 2.0)
	   (oldfreq:SAMPLE 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* 1.0 STWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 two) two)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 alpha)
	      (set! b1 0.0)
	      (set! b2 (* -1.0 b0))
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 (* -2.0 coso))
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))


(if *build-multi-chan*
    (bind-func bpf_mc_c
      (lambda (channels:i64)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (bpf_c)))
	  (lambda (chan:i64 x freq bandwidth)
	    (let ((f (pref lines chan)))
	      (f x freq bandwidth)))))))


;; biquad notch filter
(bind-func notch_c
  (lambda () 
    (let* ((y1 0.0)
	   (y2 0.0)
	   (x1 0.0)
	   (x2 0.0)
	   (b0 0.0)
	   (b1 0.0)
	   (b2 0.0)
	   (a0 0.0)
	   (a1 0.0)
	   (a2 0.0)
           (two:SAMPLE 2.0)
	   (oldfreq 0.0)
	   (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
	;; if frequency or bandwidth change
	;; recalculate coefficients
	(if (or (<> freq oldfreq)
		(<> bandwidth oldbw))
	    (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
		   (sino (sin omega))
		   (coso (cos omega))
		   (alpha (* sino (sinh (* (/ (log2 two) two)
					   bandwidth
					   (/ omega sino))))))
	      (set! oldfreq freq)
	      (set! oldbw bandwidth)
	      (set! b0 1.0)
	      (set! b1 (* -2.0 coso)) 
	      (set! b2 b0)
	      (set! a0 (+ 1.0 alpha))
	      (set! a1 b1)
	      (set! a2 (- 1.0 alpha))))
	(let ((y (- (+ (* (/ b0 a0) x)
		       (* (/ b1 a0) x1)
		       (* (/ b2 a0) x2))
		    (* (/ a1 a0) y1)
		    (* (/ a2 a0) y2))))
	  (set! y2 y1)
	  (set! y1 y)
	  (set! x2 x1)
	  (set! x1 x)
	  y)))))

(if *build-multi-chan*
    (bind-func notch_mc_c
      (lambda (channels:i64)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (notch_c)))
	  (lambda (chan:i64 x freq bandwidth)
	    (let ((f (pref lines chan)))
	      (f x freq bandwidth)))))))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:SAMPLE* (alloc n))
          (x_n:SAMPLE* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (convert i) SPI))
                  (pow (sin (/ (* (convert i) SPI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (% (+ i x_ptr (- n 1)) n))))))
          (% (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func hilb_env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x:SAMPLE)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))


(bind-func env_follow_c
  (lambda (ms:SAMPLE)
    (let ((y1 0.0)
          (coeff (/ 1000. (* ms SR))))      
      (lambda (x:SAMPLE)
        (set! y1 (+ x (* coeff (- y1 x))))
        y1))))


(bind-func atkrel_env_follow_c
  (lambda (atk:SAMPLE rel:SAMPLE)
    (let ((y1 0.0)
          (atkcoeff (/ 1000. (* atk SR)))
          (relcoeff (/ 1000. (* rel SR))))          
      (lambda (x)
        (set! y1 (+ x (* (if (> x y1) atkcoeff relcoeff) (- y1 x))))
        y1))))


;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4:SAMPLE 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
	  y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in:SAMPLE cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf_c
  (lambda (type)
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
	  (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
	(let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ SPI 2.0)))) 1.0))
	      (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
	      (p (* 0.5 (+ k 1.0)))
	      (scale (exp (* (- 1.0 p) 1.386249)))
	      (r (* res scale)))
	  (set! x (- in (* r y4)))
	  (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
	  (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
	  (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
	  (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

	  (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
	  ;; y4 is output
	  (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
	  ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping          
	  (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
	  (t1 0.0) (t2 0.0))
      (lambda (in:SAMPLE cutoff res)
	(let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
	      (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
	  (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
                       (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


(if *build-multi-chan*
    (bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
	(let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
	      (i:i64 0))
	  (dotimes (i channels) (pset! lines i (vcf_c type)))
	  (lambda (chan:i64 x freq res)
	    (let ((f (pref lines chan)))
	      (f x freq res)))))))

;; State Variable Filter adapted from
;; http://www.musicdsp.org/archive.php?classid=3#142 (it is possible
;; to get all the hp, lp, bp and notch output values in one function,
;; however they are currently provided in separate functions)

(if (not (llvm:get-globalvar "SVF_LOWPASS"))
    (bind-val SVF_LOWPASS i64 1))
(if (not (llvm:get-globalvar "SVF_HIGHPASS"))
    (bind-val SVF_HIGHPASS i64 2))
(if (not (llvm:get-globalvar "SVF_BANDPASS"))
    (bind-val SVF_BANDPASS i64 3))
(if (not (llvm:get-globalvar "SVF_NOTCH"))
    (bind-val SVF_NOTCH i64 4))
(if (not (llvm:get-globalvar "SVF_PEAK"))
    (bind-val SVF_PEAK i64 5))

(bind-func svf_c
  "Returns a (state variable) filter closure"
  (lambda (type)
    ;; old values
    (let ((zero:SAMPLE 0.0)
          (cutoff_ 0.0)
          (resonance_:SAMPLE 0.0)
          (drive 0.0)
          (freq 0.0)
          (damp 0.0)
          (notch 0.0)
          (low 0.0)
          (high 0.0)
          (band 0.0)
          (peak 0.0)
          (out 0.0))
      (lambda (in cutoff resonance)
        ;; recalculate some values if cutoff or resonance have changed
        (if (or (<> cutoff cutoff_)
                (<> resonance resonance_))
            (begin
              (set! cutoff_ cutoff)
              (set! resonance_ resonance)
              (set! freq (* 2.0 (sin (* SPI (min 0.25 (/ cutoff (* SAMPLERATE 2.0)))))))
              (set! damp (min (* 2.0 (- 1.0 (pow resonance 0.25)))
                               (min 2.0 (- (/ 2.0 freq) (* freq 0.5)))))))
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (* 0.5 (if (= type SVF_LOWPASS)
                             low
                             (if (= type SVF_HIGHPASS)
                                 high
                                 (if (= type SVF_BANDPASS)
                                     band
                                     (if (= type SVF_NOTCH)
                                         notch
                                         (if (= type SVF_PEAK)
                                             peak
                                             zero)))))))
        ;; now do it all again (because it's oversampled for
        ;; stability)
        (set! notch (- in (* damp band)))
        (set! low (+ low (* freq band)))
        (set! high (- notch low))
        (set! band (- (+ (* freq high) band)
                      (* drive band band band)))
        ;; this is a bit filthy - needs a macro
        (set! out (+ out (* 0.5 (if (= type SVF_LOWPASS)
                                    low
                                    (if (= type SVF_HIGHPASS)
                                        high
                                        (if (= type SVF_BANDPASS)
                                            band
                                            (if (= type SVF_NOTCH)
                                                notch
                                                (if (= type SVF_PEAK)
                                                    peak
                                                    zero))))))))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x:SAMPLE)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x:SAMPLE level:SAMPLE character:SAMPLE)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x:SAMPLE freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

(bind-func hann_c
  "window of width samples - repeating every repeat samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64)
        (set! cnt (+ cnt 1))
        (* 0.5
           (- 1.0
              (cos (/ (* STWOPI (convert (% cnt width)))
                      (- (convert width) 1.0)))))))))

;; hann
(if *build-multi-chan*
    (bind-func hann_mc_c
      (lambda ()   
	(let ((h (hann_c))
	      (mem 0.0))
	  (lambda (chan:i64 width:i64)	
	    (if (= chan 0) (set! mem (h width)))
	    mem)))))


(bind-func hann_t_c
  "window of width samples - repeating every repeat samples"
  (lambda (offset)
    (lambda (time:i64 width:i64)      
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* STWOPI (convert (% (- time offset) width)))
                    (- (convert width) 1.0))))))))

;; hann with time
(if *build-multi-chan*
    (bind-func hann_t_mc_c
      (lambda (offset)   
	(let ((h (hann_t_c offset))
	      (mem 0.0))
	  (lambda (chan:i64 time:i64 width:i64)	
	    (if (= chan 0) (set! mem (h time width)))
	    mem)))))


(bind-func hann_e_c
  "window of 'width' samples, repeating every 'repeat' samples
   with an offset of 'offset' samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64 offset:i64 repeat:i64)
        (if (> cnt repeat) (set! cnt -1))        
        (set! cnt (+ cnt 1))
        (if (and (or (> cnt offset) (= offset 0))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* STWOPI (convert (% (- cnt offset) width)))
                          (convert (- width 1))))))
            0.0)))))
 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan inc)
          (if (= chan 0)
              (set! time (+ time inc)))
          (+ (* m time) c))))))

(bind-func line_c
  (lambda (x1:SAMPLE y1:SAMPLE x2:SAMPLE y2)
    (let* ((zero:SAMPLE 0.0)
           (m (if (= (- x2 x1) 0.0) 
		  zero
		  (/ (- y2 y1) (- x2 x1))))
	   (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:SAMPLE* num_of_points:i64)
    (let ((lines:[SAMPLE,SAMPLE]** (zalloc num_of_points))
	  (k 0))
      (dotimes (k num_of_points)
	(let* ((idx (* k 2))
	       (x1 (pref points (+ idx 0)))
	       (y1 (pref points (+ idx 1)))
	       (x2 (pref points (+ idx 2)))
	       (y2 (pref points (+ idx 3))))
	  (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:SAMPLE* num_of_points)
    (let ((klines:[SAMPLE,SAMPLE]** (envelope_segments points num_of_points))
	  (line_length num_of_points))
      (lambda (time)
	(let ((res -1.0)
	      (k:i64 0))
	  (dotimes (k num_of_points)
	    (let ((line (pref klines k))
		  (time_point (pref points (* k 2))))
	      (if (or (= time time_point)
		      (< time_point time))
		  (set! res (line time)))))
	  res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp sus_amp)
    (let* ((points 6)
	   (data:SAMPLE* (zalloc (* points 2))))
      (pset! data 0 (convert start_time))
      (pset! data 1 0.0)
      (pset! data 2 (convert (+ start_time atk_dur))) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (convert (+ start_time atk_dur dky_dur)))
      (pset! data 5 sus_amp)
      (pset! data 6 (convert (+ start_time atk_dur dky_dur sus_dur)))
      (pset! data 7 sus_amp)
      (pset! data 8 (convert (+ start_time atk_dur dky_dur sus_dur rel_dur)))
      (pset! data 9 0.0)
      (pset! data 10 (convert (+ start_time atk_dur dky_dur sus_dur rel_dur 1))) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
	(lambda (time:i64)
	  (f (convert time)))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (let ((val:SAMPLE (if (> (+ atk_dur dky_dur) 1) 0.0 peak_amp))
	  (t1 atk_dur)
	  (t2 (+ atk_dur dky_dur))
	  (t3 (+ atk_dur dky_dur sus_dur))
	  (t4 (+ atk_dur dky_dur sus_dur rel_dur))
	  (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
	  (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
	  (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
	(if (= chan 0)
	    (cond ((> time t4) (set! val 0.0))
		  ((> time t3) (set! val (+ val inc3)))
		  ((> time t2) val) ;; sustain (don't do anything with val)
		  ((> time t1) (set! val (+ val inc2)))
		  ((> time 0) (set! val (+ val inc1)))
		  (else (set! val 0.0))))
	val))))

(bind-func hermite_interp
  (lambda (fractional y1:SAMPLE x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
	  (v (- x0 x1))
	  (w (+ c v))
	  (a (+ w v (* (- x2 x0) 0.5)))
	  (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;;  midi/freq utilities

(bind-func midi2frq    
  (lambda (pitch:SAMPLE)            
    (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0)))))

(bind-func frq2midi
  (lambda (freq:SAMPLE)            
    (+ (* 12.0 (log2 (/ freq 440.0))) 69.0)))

(define *xtmlib-audio_dsp-loaded* #t)

(sys:precomp:insert-footer "xtmaudio_dsp")
