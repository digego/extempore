;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs: 

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; lib-loading config
(sys:load "libs/audio_dsp.xtm" 'quiet)
(sys:load-preload-check 'audio_dsp)
(define *xtmlib-audio_dsp-loaded* #f)

;; try a precompiled one first
(sys:precomp:suppress-precomp-do
 (sys:load "libs/core/math.xtm"))
(sys:precomp:insert-sexp '(sys:load "libs/core/math.xtm"))

(sys:precomp:insert-header "xtmaudio_dsp")

;; do you want to compile multichannel extensions
;; usually NOT
(define *build-multi-chan* #t)

(bind-val SPI SAMPLE 3.1415926535897932384626433832795028841971693993751058209749)
(bind-val STWOPI SAMPLE 6.2831853071795864769252867665590057683943387987502116419498)
(bind-val SE SAMPLE 2.7182818284590452353602874713526624977572470936999595749669)

(if (not (llvm:get-globalvar "SAMPLERATE"))
    (begin (bind-val SAMPLERATE SAMPLE 44100.0)
           (bind-val SRs SAMPLE 44100.0)
           (bind-val SRf float 44100.0)
           (bind-val SRd double 44100.0)
           (bind-val SR i64 44100)))
(if (not (llvm:get-globalvar "CHANNELS"))
    (bind-val CHANNELS i64 2))
(if (not (llvm:get-globalvar "IN_CHANNELS"))
    (bind-val IN_CHANNELS i64 0))
(if (not (llvm:get-globalvar "FRAMES"))
    (bind-val FRAMES i64 128))
                  
                  
(bind-func init_audio_state
  (lambda (srate:i64 channels:i64 frames:i64)
    (set! SAMPLERATE (convert srate SAMPLE))
    (set! SRs (convert srate SAMPLE))
    (set! SRf (convert srate float))
    (set! SRd (convert srate double))
    (set! SR srate)    
    (set! CHANNELS channels)
    (set! FRAMES frames)
    void))

(init_audio_state *au:samplerate*
                  *au:channels*
                  *au:in-channels*
                  *au:block-size*)

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" (ftod (convert SAMPLERATE)))))

(print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
;; (bind-func dsp:DSP
;;   (lambda (in time chan dat)
;;     0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; metronome
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; tempo,offset,mark,total-beats,cycle-beats,beat-env,samp-env
(bind-type Metronome <Rational,i64,i64,Rational,Rational,[Rational,Rational]*,[Rational,Rational]*>)

(bind-func MakeMetro_3
  (lambda (tempo offset:i64 beat:Rational)
    (let ((tempoR (/ 60 (Rat (dtoi64 (* 100. tempo)) 100)))
          (line (lambda (x1:Rational y1:Rational x2:Rational y2:Rational)
                  (let ((m (if (= (Rat 0 1) (- x2 x1))
                               (Rat 0 1)
                               (/ (- y2 y1) (- x2 x1))))
                        (c (- y1 (* m x1))))
                    (lambda (t:Rational)
                      (+ (* t m) c))))))
      (Metronome tempoR 0 offset beat (Rat 4 1)
                 (line (Rat offset 1) beat
                       (+ offset (* tempoR SR))
                       (+ beat 1/1))
                 (line beat (Rat offset 1)
                       (+ beat 1/1)
                       (+ offset (* tempoR SR)))))))

(bind-func MakeMetro_1
  (lambda (tempo)
    (MakeMetro_3 tempo (now) (Rat 0 1))))

(bind-func MakeMetro_4
  (lambda (tempo offset beatn beatd)
    (MakeMetro_3 tempo offset (Rat beatn beatd))))

(bind-poly MakeMetro MakeMetro_3)
(bind-poly MakeMetro MakeMetro_1)
(bind-poly MakeMetro MakeMetro_4)

(bind-func metro_get_time
  (lambda (m:Metronome* beat:Rational)
    (+ (dtoi64 (* 1.0 ((tref m 6) beat))) (tref m 1))))

(bind-func metro_get_beat
  (lambda (m:Metronome* time:i64)
    ((tref m 5) (Rat time 1))))

(bind-func metro_get_quantized
  (lambda (m:Metronome* q:Rational)
    (let ((val (+ (tref m 3) ;; total beats
                  (/ (- (now) (tref m 2)) ;; mark
                     (* SR (tref m 0)))))
          (q2 (- q (% val q))))
      (+ val (- q (% val q))))))

(bind-func metro_get_tempo
  (lambda (m:Metronome*)
    (/ 60 (tref m 0))))

(bind-func metro_get_duration
  (lambda (m:Metronome* dur:Rational)
    (convert (* SRf (* dur (tref m 0))) i64)))

(bind-func print_metronome:[void,Metronome*]*
  (lambda (m)
    (println "Metronome>> bpm:" (metro_get_tempo m) "beats:" (tref m 3))))

(bind-poly print print_metronome)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; some simple conversions 
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func amp2db  
  (lambda (x:SAMPLE)
    (* 20. (log10 x))))

(bind-func db2amp
  (lambda (x:SAMPLE)
    (pow 10. (/ x 20.))))


;; root mean squared (mono passthrough)
;; grab current rms value from val:
;;
;; updates db every FRAMES
;; passes mono signal straight through
;;
;; DB is (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_c
  (lambda ()
    (let ((d:SAMPLE* (alloc FRAMES))
          (t 0)
          (db:SAMPLE 0.0))
      (lambda (x:SAMPLE)
        (pset! d (% t FRAMES) (* x x))
        (set! t (+ t 1))
        (if (= 0 (% t FRAMES))
            (set! db (+ 3.0 (amp2db (sqrt (mean d FRAMES))))))
        x))))

;; rms
;;
;; left and right are db
;; (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_st_c
  (lambda ()
    (let ((lgth (* 1 FRAMES))
          (dl:SAMPLE* (alloc lgth))
          (dr:SAMPLE* (alloc lgth))
          (t 0)
          (left:SAMPLE 0.0)
          (right:SAMPLE 0.0))
      (lambda (chan:i64 x:SAMPLE)
        (if (= chan 0)
            (begin (pset! dl (% t lgth) (* x x))
                   (set! t (+ t 1))
                   ;;(printf "left %f\n" (ftod left))
                   (if (= 0 (% t lgth))
                       (begin
                         (set! left (+ 3.0 (amp2db (sqrt (mean dl lgth)))))
                         (set! right (+ 3.0 (amp2db (sqrt (mean dr lgth)))))))
                   void)
            (begin (pset! dr (% t lgth) (* x x))
                   void))
        x))))

;; amount of curve
;;
;; width is duration of the curve
;;
;; the 'power' value of the curve
;; can be negative!
;;
;; 1.0 or 0.0 = flat (returns 1.0)
;; 1.01 = close to linear
;; 2.0 = normal value
;; 6.0 = steeper curve etc..
;;
;; time 0.0 -> width
(bind-func gain:[SAMPLE,i64,i64,SAMPLE]*
  (lambda (time width power)
    (let ((amp 1.0)
          (p:double (convert power))
          (t (/ (i64tod time) (i64tod width))))
      (if (< p 0.0)
          (begin (set! p (fabs p))
                 (set! t (- 1.0 t))))
      (let ((out (* amp (/ (- (pow p t) 1.0) (- p 1.0)))))
        (convert
         (if (> out amp) amp
             (if (< out 0.0) 0.0
                 out)))))))


;; given current channel
;; and pan value [0.0-1.0]
;; returns value betwee n [0.0-1.0]
;; uses CHANNELS
(bind-func panner
  (lambda (chan:i64 pan)
    (let ((cn1:SAMPLE (convert (- CHANNELS 1))))
      (- 1.0 (/ (fabs (- (* pan cn1) (convert chan))) cn1)))))


;; a repeating hann signal of width
;;
;; where a cycle is
;; time 0.0 -> width
;; 
;; repeat is:
;; 1.0 - repeat immediately
;; 2.0 - repeat after two cycles
;; 4.0 - repeat after four cycles etc..
;;
(bind-func hann
  (lambda (time:i64 width:i64 repeat:i64)
    (if (> (% time (* width repeat)) width) 0.0
        (* 0.5
           (- 1.0
              (cos (* STWOPI (/ (convert time)
                                (convert width)))))))))

;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:i64 apex:i64)
    (let ((h:SAMPLE (convert (* time apex))))
      (* h (exp (- 1.0 h))))))



;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html
(bind-func dsp_randn
  (let ((phase:i64 0))
    (lambda ()
      (let ((u1:SAMPLE (random))
            (u2:SAMPLE (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (dsp_randn)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; x values must fall within the range -PI ... PI
(bind-func _sin
  (let ((p 0.225) ; :_abuf* (alloc))
        (b (/ 4.0 SPI))
        (c (/ -4.0 (* SPI SPI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
        (+ (* p (- (* y (fabs y)) y)) y)))))

;; (bind-func osc_c
;;   (lambda (phase)
;;     (lambda (amp freq)
;;       (let ((inc (* TWOPI (/ freq SAMPLERATE))))
;; 	(set! phase (+ phase inc))
;; 	(* amp (sin phase))))))


(bind-func osc_c
  (lambda (phase)
    (lambda (amp freq)
      (let ((inc (* STWOPI (/ freq SAMPLERATE))))
        (set! phase (+ phase inc))
        (if (> phase SPI) (set! phase (- phase STWOPI)))
        (* amp (_sin phase))))))


(if *build-multi-chan*
(bind-func osc_mc_c
      (lambda (phase)
        (let ((val 0.0)
              (osc (osc_c phase)))
          (lambda (chan:i64 amp freq)
            (if (= chan 0) (set! val (osc amp freq)))
            val)))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_c
  (lambda (phase)   
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
        (* amp (tanh (* n (osc 1.0 freq))))))))


;; square oscillator multichannel
(if *build-multi-chan*
(bind-func square_mc_c
      (lambda (phase)   
        (let ((sqr (square_c phase))
              (mem 0.0))
          (lambda (chan:i64 amp freq n)	
            (if (= chan 0) (set! mem (sqr amp freq n)))
            mem)))))

;; a 'leaky' integrator
(bind-func integrator_c
  (let ((old 0.0)
        (leak 0.99))
    (lambda (x)
      (set! old (+ (* leak old) x))
      old)))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_c
  (lambda (phase)   
    (let ((osc (osc_c phase))	  
          (old 0.0)
          (new 0.0)
          (leak 0.9))
      (lambda (amp freq n)
        (set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

;; saw oscillator
(if *build-multi-chan*
(bind-func triangle_mc_c
      (lambda (phase)
        (let ((mem 0.0)
              (tri (triangle_c phase)))
          (lambda (chan:i64 amp freq n)
            (if (= chan 0) (set! mem (tri amp freq n)))
            mem)))))

;; rect wave oscillator - useful for pulse width modulation
(bind-func rect_c
  (lambda (phase)
    (lambda (amp:SAMPLE freq duty)
      (let ((inc (/ freq SAMPLERATE)))
        (set! phase (+ phase inc))
        (if (> phase 1.0) (set! phase (- phase 1.0)))
        (if (< phase duty) amp (* -1.0 amp))))))

(if *build-multi-chan*
(bind-func rect_mc_c
      (lambda (phase)
        (let ((val 0.0)
              (rect (rect_c phase)))
          (lambda (chan:i64 amp freq duty)
            (if (= chan 0) (set! val (rect amp freq duty)))
            val)))))

;; saw oscillator
(bind-func saw_c
  (lambda (phase)
    (let ((dp 1.0)
          (x:SAMPLE 0.0)
          (limitchk:SAMPLE 0.000001)
          (leak 0.995)
          (saw 0.0))
      (lambda (amp freq)
        (let* ((qmax (/ SAMPLERATE freq))
               (dc (/ -0.498 qmax)))
          (set! phase (+ phase dp))
          (if (< phase 0.0) 
              (begin (set! phase (- 0.0 phase))
                     (set! dp (- 0.0 dp)))
              (if (> phase qmax)
                  (begin (set! phase (+ qmax (- qmax phase)))
                         (set! dp (- 0.0 dp)))))
          (set! x (* SPI phase))
          (if (< x limitchk) (set! x limitchk))
          (set! saw (* leak (+ saw (+ dc (/ (sin x) x)))))
          (* amp saw))))))


;; saw oscillator
(if *build-multi-chan*
(bind-func saw_mc_c
      (lambda (phase)
        (let ((mem 0.0)
              (saw (saw_c phase)))
          (lambda (chan:i64 amp freq)
            (if (= chan 0) (set! mem (saw amp freq)))
            mem)))))

;; white noise generator
(bind-func white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; pulse train
(bind-func pulse_c
  (lambda ()
    (let ((time -1.0)
          (period:SAMPLE 0.0))
      (lambda (amp:SAMPLE freq width)
        (set! period (/ SAMPLERATE freq))
        (set! time (+ time 1.0))
        (if (< (modulo time period) width)
            amp
            0.0)))))

(if *build-multi-chan*
(bind-func pulse_mc_c
      (lambda ()
        (let ((pulse (pulse_c))
              (mem 0.0))
          (lambda (chan:i64 amp freq width)
            (if (= chan 0) (set! mem (pulse amp freq width)))
            mem)))))

;; linear fade closure
(bind-func fade_c
  (lambda ()
    (let ((t 0.0)
          (inc (/ 1.0 SRf)))
      (lambda (initial:SAMPLE final dur)
        (set! t (+ t inc))
        (if (> t dur)
            final
            (+ initial (* (/ t dur) (- final initial))))))))

(if *build-multi-chan*
(bind-func fade_mc_c
      (lambda ()
        (let ((val 0.0)
              (fader (fade_c )))
          (lambda (chan:i64 initial final dur)
            (if (= chan 0) (set! val (fader initial final dur)))
            val)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_old_c
  (lambda (max_delay)
    (let ((line:SAMPLE* (zalloc max_delay))
          (time 0)
          (delay max_delay)
          (in 1.0)
          (out 0.5))
      (lambda (x:SAMPLE)
        (let* ((n (modulo time delay))
               (delayed (pref line n))
               (y (+ (* in x) (* out delayed))))
          (pset! line n y)
          (set! time (+ time 1))
          y)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c 
  (lambda (max_delay:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
          (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE wet feedback)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
(bind-func delay_mc_c
      (lambda (channels:i64 max_delay)
        (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
          (lambda (chan:i64 x wet feedback)
            ((pref dlines chan) x wet feedback))))))

(if *build-multi-chan*
(bind-func delay_st_c
      (lambda (d1 d2)
        (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc 2))
              (i:i64 0))
          (pset! dlines 0 (delay_c d1))
          (pset! dlines 1 (delay_c d2))
          (lambda (chan:i64 x wet feedback)
            ((pref dlines chan) x wet feedback))))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
;;
;; offset is for metro 'get-mark offset
(bind-func delay_t_c 
  (lambda (max_delay offset:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
          ;; (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE time:i64 wet:SAMPLE feedback:SAMPLE)
        (set! n (modulo (convert (- time offset)) delay))
        (set! y (pref line n))
        ;;(set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(if *build-multi-chan*
(bind-func delay_t_mc_c
      (lambda (channels:i64 max_delay:i64 offset:i64)
        (let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! dlines i (delay_t_c max_delay offset)))
          (lambda (chan:i64 x time:i64 wet:SAMPLE feedback)
            ((pref dlines chan) x time wet feedback))))))

(if *build-multi-chan*
(bind-func delay_t_st_c
      (lambda (d1 d2 offset)
        (let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc 2))
              (i:i64 0))
          (pset! dlines 0 (delay_t_c d1 offset))
          (pset! dlines 1 (delay_t_c d2 offset))
          (lambda (chan:i64 x time wet feedback)
            ((pref dlines chan) x time wet feedback))))))




;; iir comb with interpolation
;; delay for COMB needs to stay
;; as a fractional argument (i.e. float)
(bind-func comb_c
  (lambda (max_delay:i64)    
    (let ((maxdelay max_delay)
          (line:SAMPLE* (zalloc maxdelay))
          (in_head 0)
          (out_head 0)
          (delay_:SAMPLE (convert max_delay))
          (alpha 0.0)
          (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (x:SAMPLE delay:SAMPLE wet:SAMPLE feedback:SAMPLE)
        (if (<> delay delay_)
            (begin (set! delay_ delay)		 
                   (set! alpha (- delay (floor delay)))
                   (set! om_alpha (- 1.0 alpha))
                   (set! out_head (- (+ maxdelay in_head)
                                     (convert delay)))))
        (set! ih (modulo in_head maxdelay))
        (set! oh (modulo out_head maxdelay))
        (set! delayed1 (pref line oh))
        (set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
        (set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
        ;;(set! y (+ (* in x) (* out delayed)))
        (pset! line ih (* feedback (+ x delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ x (* delayed wet))))))


(if *build-multi-chan*
(bind-func comb_mc_c
      (lambda (channels:i64 max_delay)
        (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
          (lambda (chan:i64 x delay wet feedback)
            (let ((f (pref dlines chan)))
              (f x delay wet feedback)))))))


;; flanger
(bind-func flanger_c
  (lambda (delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
    (let ((comb (comb_c (convert (+ delay mod_range))))
          (mod (osc_c mod_phase)))
      (lambda (x:SAMPLE wet feedback)
        (comb x (+ delay (mod mod_range mod_rate)) wet feedback)))))


(if *build-multi-chan*
(bind-func flanger_mc_c
      (lambda (channels:i64 delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
        (let ((comb (comb_mc_c channels (convert (+ delay mod_range))))
              (mod (osc_mc_c mod_phase))
              (i:i64 0))
          (lambda (chan:i64 x wet feedback)
            (comb chan x (+ delay (mod chan mod_range mod_rate)) wet feedback))))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay:SAMPLE 700.)
          (range:SAMPLE 200.)
          (rate:SAMPLE 0.1)
          (comb1 (comb_c (convert (+ delay range))))
          (comb2 (comb_c (convert (+ delay range))))
          (comb3 (comb_c (convert (+ delay range))))
          (mrng1 range)
          (mrng2 (* (random) range))
          (mrng3 (* (random) range))
          (mrte1 rate)
          (mrte2 (* rate 1.372))
          (mrte3 (* rate 0.792))
          (dly1 delay)
          (dly2 (* (random) delay))
          (dly3 (* (random) delay))
          (mod1 (osc_c phase))
          (mod2 (osc_c phase))
          (mod3 (osc_c phase)))
      (lambda (x:SAMPLE wet fb)
        (+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
           (comb2 x (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
           (comb3 x (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(if *build-multi-chan*
(bind-func chorus_mc_c
      (lambda (channels:i64 phase)
        (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! dlines i (chorus_c phase)))
          (lambda (chan:i64 x wet fb)
            (let ((f (pref dlines chan)))
              (f x wet fb)))))))


;; tap delay
(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:SAMPLE* (zalloc max_delay))
          (taps:i64* (zalloc num_of_taps))
          (delay max_delay)
          (time 0))
      (lambda (x:SAMPLE)
        (let ((y 0.0)
              (i 0)
              (n (modulo time delay))
              (gain (/ 1.0 (convert num_of_taps))))
          (pset! line n x)
          (dotimes (i num_of_taps)
            (set! y (+ y (* gain (pref line (% (+ (pref taps i) n) delay))))))
          (set! time (+ time 1))
          y)))))

(if *build-multi-chan*
(bind-func tap_delay_mc_c
      (lambda (nchan:i64 max_delay num_of_taps)
        (let ((tap_delay_buf:[SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan)
            (pset! tap_delay_buf i (tap_delay_c max_delay num_of_taps)))
          (lambda (chan x)
            ((pref tap_delay_buf chan) x))))))

;; allpass
(bind-func allpass_old_c
  (lambda (delay)
    (let ((inline:SAMPLE* (zalloc delay))
          (outline:SAMPLE* (zalloc delay))
          (time 0)
          (g 0.9))
      (lambda (x)
        (let* ((n (% time delay))
               (dy (pref outline n))
               (dx (pref inline n))
               (y (+ (* -1.0 g x)
                     dx
                     (* g dy))))
          (pset! inline n x)
          (pset! outline n y)
          (set! time (+ time 1))
          y)))))

;; allpass
(bind-func allpass_c
  (lambda (delay)
    (let ((_delay delay)
          (inline:SAMPLE* (zalloc _delay))
          (outline:SAMPLE* (zalloc _delay))
          (time 0))
      (lambda (x fb)
        (let* ((n (% time _delay))
               (dy (pref outline n))
               (dx (pref inline n))
               (y (+ (* -1.0 fb x)
                     dx
                     (* fb dy))))
          (pset! inline n x)
          (pset! outline n y)
          (set! time (+ time 1))
          y)))))


(if *build-multi-chan*
(bind-func allpass_mc_c
      (lambda (channels:i64 delay)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (allpass_c delay)))
          (lambda (chan:i64 x wet)
            (let ((f (pref lines chan)))
              (f x wet)))))))


;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))

;; a dodgy reverb mk2
(bind-func reverb_old_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (dly1 (delay_old_c (convert (* ms (* .192 size)))))
          (dly2 (delay_old_c (convert (* ms (* .373 size)))))
          (dly3 (delay_old_c (convert (* ms (* .671 size)))))
          (dly4 (delay_old_c (convert (* ms (* .712 size)))))
          (ap1 (allpass_old_c (convert (* ms size))))
          (ap3 (allpass_old_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_old_c (convert (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in:SAMPLE wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (+ (dly1 wetin)
                               (dly2 wetin)
                               (dly3 wetin)
                               (dly4 wetin)))))))))))


;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (dly1 (delay_c (convert (* ms (* .192 size)))))
          (dly2 (delay_c (convert (* ms (* .373 size)))))
          (dly3 (delay_c (convert (* ms (* .671 size)))))
          (dly4 (delay_c (convert (* ms (* .712 size)))))
          (ap1 (allpass_c (convert (* ms size))))
          (ap3 (allpass_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(if *build-multi-chan*
(bind-func reverb_mc_c
      (lambda (channels:i64 size)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (reverb_c size)))
          (lambda (chan:i64 x wet fb)
            (let ((f (pref lines chan)))
              (f x wet fb)))))))


;; a dodgy reverb mk2
(bind-func reverb2_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (ap1 (allpass_c (convert (* ms size))))
          (ap3 (allpass_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(if *build-multi-chan*
(bind-func reverb2_mc_c
      (lambda (channels:i64 size)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (reverb2_c size)))
          (lambda (chan:i64 x wet)
            (let ((f (pref lines chan)))
              (f x wet)))))))



;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits:SAMPLE)
        (* amp (/ (floor (* in (pow 2. bits))) 
                  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in:SAMPLE h:SAMPLE)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))


(if *build-multi-chan*
(bind-func hold_mc_c
      (lambda (channels:i64)
        (let ((holds:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! holds i (hold3_c)))
          (lambda (chan:i64 x h)
            (let ((f (pref holds chan)))
              (f x h)))))))


;; a dodgy bitcrusher
(bind-func crush
  (lambda (in:SAMPLE bits:SAMPLE)
    (/ (floor (* in (pow 2. bits))) 
       (pow 2. bits))))


;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in:SAMPLE)
        (clamp lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores anything in on channel 2)
;; pan value [0.0-1.0]
(bind-func pan2
  (let ((out:SAMPLE 0.0))
    (lambda (x:SAMPLE chan:i64 pan)
      (if (= chan 0)
          (begin (set! out x) (* (- 1.0 pan) out))
          (* pan out)))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(if *build-multi-chan*
(bind-func pan_mc
      (lambda (channels)
        (let ((v:SAMPLE 0.0)
              (out:SAMPLE 0.0))
          (lambda (x:SAMPLE chan:i64 pan)
            (if (= chan 0) (set! out x))
            (set! v (fabs (- (* (- channels 1.0) pan) (convert chan))))
            (if (> v 1.0) 0.0
                (* (- 1.0 v) out)))))))


;; simple stereo weights
(bind-func mix2
  (lambda (x:SAMPLE chan:i64 left right)
    (cond ((= chan 0) (* x left))
          ((= chan 1) (* x right))
          (else 0.0))))

;; simple quad weights
(bind-func mix4
  (lambda (x:SAMPLE chan c1 c2 c3 c4)
    (cond ((= chan 0) (* x c1))
          ((= chan 1) (* x c2))
          ((= chan 2) (* x c3))
          ((= chan 3) (* x c4))
          (else 0.0))))

;; a four channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (lambda (cdat:SAMPLE* chan:i64 in:SAMPLE)
      (if (< chan channels)
          (* in (pref cdat chan))
          0.0))))


;; http://www.cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf
;; the 'using v1 to compute v2' version

(bind-func svf_c
  "a state variable filter (SVF)

takes input pointer |6,SAMPLE|* and fills it:

|in,low,band,high,notch,peak|
"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res outarray:|6,SAMPLE|*)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (aset! outarray 0 in) ;; input
        (aset! outarray 1 v2) ;; low
        (aset! outarray 2 v1) ;; band
        (aset! outarray 3 (- in (- (* k v1) v2))) ;; high
        (aset! outarray 4 (- in (* k v1))) ;; notch
        (aset! outarray 5 (- in (- (* k v1) (* 2.0 v2)))) ;; peak
        outarray))))

(if *build-multi-chan*
(bind-func svf_mc_c
      (lambda (nchan:i64)
        (let ((svf_buf:[|6,float|*,float,float,float,|6,float|*]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! svf_buf i (svf_c)))
          (lambda (chan in cutoff res outarray)
            ((pref svf_buf chan) in cutoff res outarray))))))

(bind-func lpf_c
  "lowpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g:SAMPLE 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(if *build-multi-chan*
(bind-func lpf_mc_c
      (lambda (nchan:i64)
        (let ((lpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! lpf_buf i (lpf_c)))
          (lambda (chan in cutoff res)
            ((pref lpf_buf chan) in cutoff res))))))

(bind-func lpf2_c
  "a state variable lowpass filter. slightly more flops than lpf_c,
but v1 and v2 can be computed in parallel"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff res)
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0:float res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k )))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(if *build-multi-chan*
(bind-func lpf2_mc_c
      (lambda (nchan:i64)
        (let ((lpf2_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! lpf2_buf i (lpf2_c)))
          (lambda (chan in cutoff res)
            ((pref lpf2_buf chan) in cutoff res))))))

(bind-func bpf_c
  "bandpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v1))))

(if *build-multi-chan*
(bind-func bpf_mc_c
      (lambda (nchan:i64)
        (let ((bpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! bpf_buf i (bpf_c)))
          (lambda (chan in cutoff res)
            ((pref bpf_buf chan) in cutoff res))))))

(bind-func hpf_c
  "highpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (- (* k v1) v2))))))

(if *build-multi-chan*
(bind-func hpf_mc_c
      (lambda (nchan:i64)
        (let ((hpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! hpf_buf i (hpf_c)))
          (lambda (chan in cutoff res)
            ((pref hpf_buf chan) in cutoff res))))))

(bind-func notch_c
  "notch filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (* k v1))))))

(if *build-multi-chan*
(bind-func notch_mc_c
      (lambda (nchan:i64)
        (let ((notch_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! notch_buf i (notch_c)))
          (lambda (chan in cutoff res)
            ((pref notch_buf chan) in cutoff res))))))

(bind-func peak_c
  "peak filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (- (* k v1) (* 2.0 v2)))))))

(if *build-multi-chan*
(bind-func peak_mc_c
      (lambda (nchan:i64)
        (let ((peak_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! peak_buf i (peak_c)))
          (lambda (chan in cutoff res)
            ((pref peak_buf chan) in cutoff res))))))

(bind-func lshelf_c
  "low shelf filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 1.0) (m1 1.0) (m2 1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff gain Q)
        ;; one option: do the check (= res oldres) trick here
	      (set! A (pow 10.0 (/ gain 40.0)))
        (set! g (/ (tan (* SPI (/ cutoff SRf)))
                   (sqrt A)))
        (set! k (/ 1.0 Q))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! m1 (* k (- A 1.0)))
        (set! m2 (- (* A A) 1.0))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ in (* m1 v1) (* m2 v2))))))

(if *build-multi-chan*
(bind-func lshelf_mc_c
      (lambda (nchan:i64)
        (let ((lshelf_buf:[float,float,float,float,float]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! lshelf_buf i (lshelf_c)))
          (lambda (chan in cutoff gain Q)
            ((pref lshelf_buf chan) in cutoff gain Q))))))


(bind-func hshelf_c
  "low shelf filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 0.0) (m1 1.0) (m2 1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff gain Q)
        ;; one option: do the check (= res oldres) trick here
	      (set! A (pow 10.0 (/ gain 40.0)))
        (set! g (/ (tan (* SPI (/ cutoff SRf)))
                   (sqrt A)))
        (set! k (/ 1.0 Q))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! m0 (* A A))
        (set! m1 (* k (- 1.0 A) A))
        (set! m2 (- 1.0 (* A A)))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ (* m0 in) (* m1 v1) (* m2 v2))))))

(if *build-multi-chan*
(bind-func hshelf_mc_c
      (lambda (nchan:i64)
        (let ((hshelf_buf:[float,float,float,float,float]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! hshelf_buf i (hshelf_c)))
          (lambda (chan in cutoff gain Q)
            ((pref hshelf_buf chan) in cutoff gain Q))))))

;; Andy Simper's Sallen Key LPF
;; http://cytomic.com/files/dsp/SkfLinearTrapOptimised2.pdf

(bind-func skf_c
  "lowpass filter: returns filtering closure using a Sallen Key lpf"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a0 0.0) (a1 0.0) (a2 0.0) (a3 0.0) (a4 0.0) (a5 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff SRf))))
        (set! k (* 2.0 res))
        (set! a0 (/ 1.0 (- (* (+ 1.0 g)
                              (+ 1.0 g))
                           (* g k))))
        (set! a1 (* k a0))
        (set! a2 (* (+ 1.0 g) a0))
        (set! a3 (* g a2))
        (set! a4 (/ 1.0 (+ 1.0 g)))
        (set! a5 (* g a4))
        (set! v1 (+ (* a1 ic2eq)
                    (* a2 ic1eq)
                    (* a3 in)))
        (set! v2 (+ (* a4 ic2eq)
                    (* a5 v1)))
        (set! ic1eq (- (* 2.0 (- v1 (* k v2))) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(if *build-multi-chan*
(bind-func skf_mc_c
      (lambda (nchan:i64)
        (let ((skf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
              (i:i64 0))
          (dotimes (i nchan) (pset! skf_buf i (skf_c)))
          (lambda (chan in cutoff res)
            ((pref skf_buf chan) in cutoff res))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from 
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func lpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (- 1.0 coso) 2.0))
              (set! b1 (- 1.0 coso))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(if *build-multi-chan*
(bind-func lpfbq_mc_c
      (lambda (channels:i64)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (lpfbq_c)))
          (lambda (chan:i64 x freq res)
            (let ((f (pref lines chan)))
              (f x freq res)))))))


;; biquad high-pass filter
(bind-func hpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (+ 1.0 coso) 2.0))
              (set! b1 (* -1.0 (+ 1.0 coso)))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(if *build-multi-chan*
(bind-func hpfbq_mc_c
      (lambda (channels:i64)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (hpfbq_c)))
          (lambda (chan:i64 x freq res)
            (let ((f (pref lines chan)))
              (f x freq res)))))))


;; biquad band-pass filter
(bind-func bpfbq_c
  (lambda () 
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq:SAMPLE 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* 1.0 STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 alpha)
              (set! b1 0.0)
              (set! b2 (* -1.0 b0))
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))


(if *build-multi-chan*
(bind-func bpfbq_mc_c
      (lambda (channels:i64)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (bpfbq_c)))
          (lambda (chan:i64 x freq bandwidth)
            (let ((f (pref lines chan)))
              (f x freq bandwidth)))))))


;; biquad notch filter
(bind-func notchbq_c
  (lambda () 
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 1.0)
              (set! b1 (* -2.0 coso)) 
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 b1)
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(if *build-multi-chan*
(bind-func notchbq_mc_c
      (lambda (channels:i64)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (notchbq_c)))
          (lambda (chan:i64 x freq bandwidth)
            (let ((f (pref lines chan)))
              (f x freq bandwidth)))))))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:SAMPLE* (alloc n))
          (x_n:SAMPLE* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (convert i) SPI))
                  (pow (sin (/ (* (convert i) SPI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (% (+ i x_ptr (- n 1)) n))))))
          (% (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func hilb_env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x:SAMPLE)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))


(bind-func env_follow_c
  (lambda (ms:SAMPLE)
    (let ((y1 0.0)
          (coeff (/ 1000. (* ms SRf))))      
      (lambda (x:SAMPLE)
        (set! y1 (+ x (* coeff (- y1 x))))
        y1))))


(bind-func atkrel_env_follow_c
  (lambda (atk:SAMPLE rel:SAMPLE)
    (let ((y1 0.0)
          (atkcoeff (/ 1000. (* atk SRf)))
          (relcoeff (/ 1000. (* rel SRf))))          
      (lambda (x)
        (set! y1 (+ x (* (if (> x y1) atkcoeff relcoeff) (- y1 x))))
        y1))))


;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4:SAMPLE 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
          y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf_c
  (lambda (type)
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ SPI 2.0)))) 1.0))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
          ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping          
          (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))          
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


(if *build-multi-chan*
(bind-func vcf_mc_c
      (lambda (type:i64 channels:i64)
        (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
              (i:i64 0))
          (dotimes (i channels) (pset! lines i (vcf_c type)))
          (lambda (chan:i64 x freq res)
            (let ((f (pref lines chan)))
              (f x freq res)))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x:SAMPLE)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x:SAMPLE level:SAMPLE character:SAMPLE)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x:SAMPLE freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

(bind-func hann_c
  "window of width samples - repeating every repeat samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64)
        (set! cnt (+ cnt 1))
        (* 0.5
           (- 1.0
              (cos (/ (* STWOPI (convert (% cnt width)))
                      (- (convert width) 1.0)))))))))

;; hann
(if *build-multi-chan*
(bind-func hann_mc_c
      (lambda ()   
        (let ((h (hann_c))
              (mem 0.0))
          (lambda (chan:i64 width:i64)	
            (if (= chan 0) (set! mem (h width)))
            mem)))))


(bind-func hann_t_c
  "window of width samples - repeating every repeat samples"
  (lambda (offset)
    (lambda (time:i64 width:i64)      
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* STWOPI (convert (% (- time offset) width)))
                    (- (convert width) 1.0))))))))

;; hann with time
(if *build-multi-chan*
(bind-func hann_t_mc_c
      (lambda (offset)   
        (let ((h (hann_t_c offset))
              (mem 0.0))
          (lambda (chan:i64 time:i64 width:i64)	
            (if (= chan 0) (set! mem (h time width)))
            mem)))))


(bind-func hann_e_c
  "window of 'width' samples, repeating every 'repeat' samples
   with an offset of 'offset' samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64 offset:i64 repeat:i64)
        (if (> cnt repeat) (set! cnt -1))        
        (set! cnt (+ cnt 1))
        (if (and (or (> cnt offset) (= offset 0))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* STWOPI (convert (% (- cnt offset) width)))
                          (convert (- width 1))))))
            0.0)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (inc)
          (set! time (+ time inc))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan inc)
          (if (= chan 0)
              (set! time (+ time inc)))
          (+ (* m time) c))))))

(bind-func line_c
  (lambda (x1:SAMPLE y1:SAMPLE x2:SAMPLE y2)
    (let* ((zero:SAMPLE 0.0)
           (m (if (= (- x2 x1) 0.0) 
                  zero
                  (/ (- y2 y1) (- x2 x1))))
           (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:SAMPLE* num_of_points:i64)
    (let ((lines:[SAMPLE,SAMPLE]** (zalloc num_of_points))
          (k 0))
      (dotimes (k num_of_points)
        (let* ((idx (* k 2))
               (x1 (pref points (+ idx 0)))
               (y1 (pref points (+ idx 1)))
               (x2 (pref points (+ idx 2)))
               (y2 (pref points (+ idx 3))))
          (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:SAMPLE* num_of_points)
    (let ((klines:[SAMPLE,SAMPLE]** (envelope_segments points num_of_points))
          (line_length num_of_points))
      (lambda (time)
        (let ((res -1.0)
              (k:i64 0))
          (dotimes (k num_of_points)
            (let ((line (pref klines k))
                  (time_point (pref points (* k 2))))
              (if (or (= time time_point)
                      (< time_point time))
                  (set! res (line time)))))
          res)))))

;; make a convenience wrapper for asr
(bind-func adsr_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp sus_amp)
    (let* ((points 6)
           (data:SAMPLE* (zalloc (* points 2))))
      (pset! data 0 (convert start_time))
      (pset! data 1 0.0)
      (pset! data 2 (convert (+ start_time atk_dur))) ;; point data
      (pset! data 3 peak_amp)
      (pset! data 4 (convert (+ start_time atk_dur dky_dur)))
      (pset! data 5 sus_amp)
      (pset! data 6 (convert (+ start_time atk_dur dky_dur sus_dur)))
      (pset! data 7 sus_amp)
      (pset! data 8 (convert (+ start_time atk_dur dky_dur sus_dur rel_dur)))
      (pset! data 9 0.0)
      (pset! data 10 (convert (+ start_time atk_dur dky_dur sus_dur rel_dur 1))) ;; this to flatten out at 0.0
      (pset! data 11 0.0)
      (let ((f (envelope_c data points)))
        (lambda (time:i64)
          (f (convert time)))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (let ((val:SAMPLE (if (> (+ atk_dur dky_dur) 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur dky_dur start_time))
          (t3 (+ atk_dur dky_dur sus_dur start_time))
          (t4 (+ atk_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t4) (set! val 0.0))
                  ((> time t3) (set! val (+ val inc3)))
                  ((> time t2) val) ;; sustain (don't do anything with val)
                  ((> time t1) (set! val (+ val inc2)))
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


;; has both hold and sustain
;; an accumulative ahdsr (random access not allowed! time must be linear).
(bind-func ahdsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 hold_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (let ((val:SAMPLE (if (> atk_dur 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur hold_dur start_time))          
          (t3 (+ atk_dur hold_dur dky_dur start_time))
          (t4 (+ atk_dur hold_dur dky_dur sus_dur start_time))
          (t5 (+ atk_dur hold_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t5) (set! val 0.0))
                  ((> time t4) (set! val (+ val inc3)))
                  ((> time t3) val) ;; sustain (don't do anything with val)
                  ((> time t2) (set! val (+ val inc2)))
                  ((> time t1) val) ;; hold don't do anything with val
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


(bind-func hermite_interp
  (lambda (fractional y1:SAMPLE x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
          (v (- x0 x1))
          (w (+ c v))
          (a (+ w v (* (- x2 x0) 0.5)))
          (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))

;;  midi/freq utilities

(bind-func midi2frq    
  (lambda (pitch:SAMPLE)
    (if (<= pitch 0.0) 0.0
        (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0))))))

(bind-func frq2midi
  (lambda (freq:SAMPLE)
    (if (<= freq 0.0) 0.0
        (+ (* 12.0 (log2 (/ freq 440.0))) 69.0))))

(define *xtmlib-audio_dsp-loaded* #t)

(sys:precomp:insert-footer "xtmaudio_dsp")
