;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; lib-loading config
(if *impc:compiler:with-cache* (sys:load "libs/aot-cache/audio_dsp.xtm" 'quiet))
(sys:load-preload-check 'audio_dsp)
(define *xtmlib-audio_dsp-loaded* #t)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/rational.xtm")
 (sys:load "libs/core/audiobuffer.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/core/rational.xtm" 'quiet)
 (sys:load "libs/core/audiobuffer.xtm" 'quiet))

(impc:aot:insert-header "xtmaudio_dsp")
(impc:aot:import-ll "xtmaudio_dsp")

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" (ftod (convert SAMPLERATE)))))

(xtmX print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
;; (bind-func dsp:DSP
;;   (lambda (in time chan dat)
;;     0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  midi/freq utilities
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func static midi2frq
  (lambda (pitch:SAMPLE)
    (if (<= pitch 0.0) 0.0
        (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0))))))

(bind-func static frq2midi
  (lambda (freq:SAMPLE)
    (if (<= freq 0.0) 0.0
        (+ (* 12.0 (log2 (/ freq 440.0))) 69.0))))

(bind-func static bpm2hz
  "pretty simple, but the name helps for code clarity"
  (lambda (bpm:SAMPLE)
    (/ 60.0 bpm)))

(bind-func static hz2bpm
  "pretty simple, but the name helps for code clarity"
  (lambda (hz:SAMPLE)
    (* 60.0 hz)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; some simple conversions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func static amp2db
  (lambda (x:SAMPLE)
    (* 20. (log10 x))))

(bind-func static db2amp
  (lambda (x:SAMPLE)
    (pow 10. (/ x 20.))))


;; so we don't need to import math.xtm
;; simple (non vectorised) sum
(bind-func static calc_vsum
  (lambda (buf:SAMPLE* len:i64)
    (let ((sum 0.0) (i 0))
      (dotimes (i len)
        (set! sum (+ sum (pref buf i))))
      sum)))

(bind-func static calc_vmean
  (lambda (buf:SAMPLE* len:i64)
    (/ (calc_vsum buf len) (convert len SAMPLE))))


;; root mean squared (mono passthrough)
;; grab current rms value from val:
;;
;; updates db every FRAMES
;; passes mono signal straight through
;;
;; DB is (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func static rms_c
  (lambda ()
    (let ((d:SAMPLE* (alloc FRAMES))
          (t 0)
          (db:SAMPLE 0.0))
      (lambda (x:SAMPLE)
        (pset! d (% t FRAMES) (* x x))
        (set! t (+ t 1))
        (if (= 0 (% t FRAMES))
            (set! db (+ 3.0 (amp2db (sqrt (calc_vmean d FRAMES))))))
        x))))

;; rms
;;
;; left and right are db
;; (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func static rms_st_c
  (lambda ()
    (let ((lgth (* 1 FRAMES))
          (dl:SAMPLE* (alloc lgth))
          (dr:SAMPLE* (alloc lgth))
          (t 0)
          (left:SAMPLE 0.0)
          (right:SAMPLE 0.0))
      (lambda (chan:i64 x:SAMPLE)
        (if (= chan 0)
            (begin (pset! dl (% t lgth) (* x x))
                   (set! t (+ t 1))
                   ;;(printf "left %f\n" (ftod left))
                   (if (= 0 (% t lgth))
                       (begin
                         (set! left (+ 3.0 (amp2db (sqrt (calc_vmean dl lgth)))))
                         (set! right (+ 3.0 (amp2db (sqrt (calc_vmean dr lgth)))))))
                   void)
            (begin (pset! dr (% t lgth) (* x x))
                   void))
        x))))

;; amount of curve
;;
;; width is duration of the curve
;;
;; the 'power' value of the curve
;; can be negative!
;;
;; 1.0 or 0.0 = flat (returns 1.0)
;; 1.01 = close to linear
;; 2.0 = normal value
;; 6.0 = steeper curve etc..
;;
;; time 0.0 -> width
(bind-func static gainf:[SAMPLE,i64,i64,SAMPLE]*
  (lambda (time width power)
    (let ((amp 1.0)
          (p:double (convert power))
          (t (/ (i64tod time) (i64tod width))))
      (if (< p 0.0)
          (begin (set! p (fabs p))
                 (set! t (- 1.0 t))))
      (let ((out (* amp (/ (- (pow p t) 1.0) (- p 1.0)))))
        (convert
         (if (> out amp) amp
             (if (< out 0.0) 0.0
                 out)))))))


;; given current channel
;; and pan value [0.0-1.0]
;; returns value betwee n [0.0-1.0]
;; uses CHANNELS
(bind-func static panner
  (lambda (chan:i64 pan)
    (let ((cn1:SAMPLE (convert (- CHANNELS 1))))
      (- 1.0 (/ (fabs (- (* pan cn1) (convert chan))) cn1)))))


;; a repeating hann signal of width
;;
;; where a cycle is
;; time 0.0 -> width
;;
;; repeat is:
;; 1.0 - repeat immediately
;; 2.0 - repeat after two cycles
;; 4.0 - repeat after four cycles etc..
;;
(bind-func hann
  (lambda (time:i64 width:i64 repeat:i64)
    (if (or (< width 1)
            (> (% time (* width repeat)) width))
        0.0
        (* 0.5
           (- 1.0
              (cos (* STWOPI (/ (convert time)
                                (convert width)))))))))

(bind-func hann
  (lambda (time:i64 width:i64)
    (hann:[float,i64,i64,i64]* time width 10000000000)))


;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func static impulse
  (lambda (time:i64 apex:i64)
    (let ((h:SAMPLE (convert (/ time apex))))
      (* h (exp (- 1.0 h))))))



;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html
(bind-func dsp_randn
  (let ((phase:i64 0))
    (lambda ()
      (let ((u1:SAMPLE (random))
            (u2:SAMPLE (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (dsp_randn)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; high precision
(bind-func parabolicSineHP
  (let ((B (/ 4.0 SPI))
        (C (/ -4.0 (* SPI SPI)))
        (P 0.225)
        (y 0.0))
    (lambda (x)
      (set! y (+ (* B x) (* C x (fabs x))))
      (+ (* P (- (* y (fabs y)) y)) y))))

;; low precision
(bind-func parabolicSineLP
  (let ((B (/ 4.0 SPI))
        (C (/ -4.0 (* SPI SPI)))
        (P 0.225))
    (lambda (x)
      (+ (* B x) (* C x) (fabs x)))))


(bind-func static fasttan
  (lambda (x)
    (/ (sin x) (sin (+ x 1.5707963267948966:f)))))

(bind-func static fasttanh
  (lambda (x)
    (/ x (+ (fabs (* 2.0 x)) (/ 3.0 (+ 2.0 (* 2.0 x 2.0 x)))))))


;; x values must fall within the range -PI ... PI
(bind-func fastsin
  (let ((p 0.225) ; :_abuf* (alloc))
        (b (/ 4.0 SPI))
        (c (/ -4.0 (* SPI SPI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
        (+ (* p (- (* y (fabs y)) y)) y)))))

;; a 'leaky' integrator
(bind-func integrator_c
  (let ((old 0.0)
        (leak 0.99))
    (lambda (x)
      (set! old (+ (* leak old) x))
      old)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; OSCILLATORS
;;

;;
;; simple oscillators
;;
;; these are useful for modulation etc.
;; use bandlimited variants for signal production
;;

;;;;;;;;; sinusoidal

;; phased between 0.0-1.0
(bind-func static osc_c
  (lambda (phase)
    (set! phase (- (* phase STWOPI) SPI))
    (let ((t (/ STWOPI SAMPLERATE)))
      (lambda (amp freq)
        (set! phase (+ phase (* t (clamp freq (- 0.0 SRs) SRs))))
        (if (> phase SPI) (set! phase (- phase STWOPI)))
        (* amp (parabolicSineHP phase))))))

(bind-func static osc_mc_c
  (lambda (phase)
    (let ((val 0.0)
          (osc (osc_c phase)))
      (lambda (chan amp freq)
        (if (= chan 0) (set! val (osc amp freq)))
        val))))


;;;;;;;;;; sawtooth

;; simple sawtooth
;;
;; mod is phase between 0.0-1.0 (i.e. not 2pi)
;; ramp is rising by default (invert for falling)
(bind-func saw_c
  (lambda (mod inverted:i1)
    (let ((inc:float 0.0) (absinc 0.0:f) (out 0.0)
          (rising (if inverted #t #f))
          (inv (if inverted -1.0 1.0)))
      (lambda (amp:float frq:float)
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        (set! out (* inv (- (* mod 2.0) 1.0))) ;; bipolar
        (set! mod (+ mod inc)) ;; update mod
        (* amp out)))))

(bind-func saw_c
  (lambda (mod)
    (saw_c:[[float,float,float]*,float,i1]* mod #f)))

(bind-func saw_mc_c
  (lambda (mod inverted)
    (let ((osc (saw_c mod inverted))
          (out 0.0))
      (lambda (chan amp frq)
        (if (= chan 0)
            (set! out (osc amp frq)))
        out))))

(bind-func saw_mc_c
  (lambda (mod)
    (saw_mc_c:[[float,i64,float,float]*,float,i1]* mod #f)))


;; simple pulsewave

;; mod is phase between 0.0-1.0
;; pw for pulse width 0.0-1.0 = 0.5 is square
(bind-func static pulse_c
  (lambda (mod:float)
    (let ((out 0.0) (inc 0.0))
      (lambda (amp:float frq:float pw:float)
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        (set! out (if (> mod pw) -1.0 1.0))
        (set! mod (+ mod inc))
        (* amp out)))))

(bind-func static pulse_mc_c
  (lambda (mod)
    (let ((osc (pulse_c mod))
          (out 0.0))
      (lambda (chan amp frq pw)
        (if (= chan 0)
            (set! out (osc amp frq pw)))
        out))))

;; simple triangle
;;
;; mod is phase 0.0-1.0
;;
(bind-func static tri_c
  (lambda (mod:float)
    (let ((out 0.0) (inc 0.0))
      (lambda (amp:float frq:float)
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        (set! out (- (* 2.0 (fabs (- (* 2.0 mod) 1.0))) 1.0))
        (set! mod (+ mod inc))
        (* amp out)))))

(bind-func static tri_mc_c
  (lambda (mod)
    (let ((osc (tri_c mod))
          (out 0.0))
      (lambda (chan amp frq)
        (if (= chan 0)
            (set! out (osc amp frq)))
        out))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; band limited oscillators
;;


;; polynomial bandlimited step functions
(bind-func static poly_blep
  (lambda (pos:float inc height rising_edge:i1)
    (let ((out 0.0) (t 0.0))
      (if (> pos (- 1.0 inc))
          (begin ;; leftside of discontinuity
            (set! t (/ (- pos 1.0) inc))
            (set! out (* height (+ (* t t) (* 2.0 t) 1.0))))
          (if (< pos inc)
              (begin ;; rightside of discontinunity
                (set! t (/ pos inc))
                (set! out (* height (- (* 2.0 t) (* t t) 1.0))))))
      (if (not rising_edge) ;; if falling
          (set! out (* out -1.0)))
      out)))

;; (sys:load "libs/core/bleptables.xtm")

(bind-val BLEPTable |4096,double|* (halloc (* 4096 8)))
(bind-val fBLEPTable |4096,float|* (halloc (* 4096 4)))
(bind-val BLEPTable_8_BLKHAR |4096,double|* (halloc (* 4096 8)))
(bind-val fBLEPTable_8_BLKHAR |4096,float|* (halloc (* 4096 4)))

(bind-func static load_blep_tables_from_blob
  (lambda (fname:i8*)
    (let ((fptr (fopen fname "rb")))
      (if (null? fptr)
          (begin (println "Failed to open bleptables.dump") void)
          (begin
            (fread (convert BLEPTable) (* 4096 8) 1 fptr)
            (fread (convert fBLEPTable) (* 4096 4) 1 fptr)
            (fread (convert BLEPTable_8_BLKHAR) (* 4096 8) 1 fptr)
            (fread (convert fBLEPTable_8_BLKHAR) (* 4096 4) 1 fptr)
            (fclose fptr)
            void)))))

(impc:aot:do-or-emit
  ($ (load_blep_tables_from_blob "libs/core/bleptables.dump")))

(bind-func static LinTerp
  (lambda (x1:SAMPLE x2 y1 y2 x)
    (let ((dx 0.0))
      (if (= (- x2 x1) 0.0)
          y1
          (begin
            (set! dx (/ (- x x1) (- x2 x1)))
            (+ (* dx y2) (* y1 (- 1.0 dx))))))))


;; --- N Sample BLEP (uPointsPerSide = N)
(bind-func static blep_n
  (lambda (table:SAMPLE* tablelen:SAMPLE mod:SAMPLE inc:SAMPLE height:SAMPLE rising:i1 num_points:SAMPLE interp:i1)
    (let ((blep 0.0) (t 0.0) (table_centre (- (/ tablelen 2.0) 1.0))
          (doright #t) (frac 0.0)
          (i:i64 1) (idx 0.0))
      ;; left side
      (while (<= i (convert num_points))
        (if (> mod (- 1.0 (* (convert i) inc)))
            (begin
              ;; calc distance
              (set! t (/ (- mod 1.0) (* num_points inc)))
              ;; get index
              (set! idx (* (+ 1.0 t) table_centre))
              ;; truncate
              (if (not interp)
                  (begin
                    (set! blep (pref table (convert idx i64)))
                    void)
                  (begin
                    (set! frac (- idx (convert (convert idx i64))))
                    (set! blep (LinTerp 0.0 1.0
                                        (pref table (convert idx i64))
                                        (pref table (convert (+ idx 1.0) i64))
                                        frac))
                    void))

              (if (not rising)
                  (set! blep (* blep -1.0)))
              (set! blep (* blep height))
              (set! doright #f)
              (set! i (convert num_points))))
        (set! i (+ i 1)))
      ;; reset for right side or done?
      (if doright
          (set! i 1)
          (set! i (+ 1 (convert num_points))))
      ;; right side
      (while (<= i (convert num_points))
        (if (< mod (* (convert i) inc))
            (begin
              ;; calc distance
              (set! t (/ mod (* num_points inc)))
              ;; get index
              (set! idx (+ (* t table_centre) (+ table_centre 1.0)))
              ;; truncate
              (if (not interp)
                  (begin
                    (set! blep (pref table (convert idx i64)))
                    void)
                  (begin
                    (set! frac (- idx (convert (convert idx i64))))
                    (if (>= (convert (+ (convert idx i64) 1) SAMPLE)
                            tablelen)
                        (set! blep (LinTerp 0.0 1.0
                                            (pref table (convert idx i64))
                                            (pref table 0)
                                            frac))
                        (set! blep (LinTerp 0.0 1.0
                                            (pref table (convert idx i64))
                                            (pref table (+ 1 (convert idx i64)))
                                            frac)))
                    void))
              (if (not rising)
                  (set! blep (* blep -1.0)))
              (set! blep (* blep height))
              (set! i (convert num_points))))
        (set! i (+ i 1)))
      ;; it is possible for blep to be 0.0
      blep)))


;; bandlimited sawtooth (blep variant of saw_c)
;;
;; mod is phase between 0.0-1.0 (i.e. not 2pi)
;; ramp is rising by default (invert for falling)
;; (bind-func blsaw_c
;;   (lambda (mod inverted:i1)
;;     (let ((inc 0.0) (absinc 0.0:f) (out 0.0) (blep 0.0) (t 0.0)
;;           (rising (if inverted #t #f))
;;           (inv (if inverted -1.0 1.0)))
;;       (lambda (amp:float frq:float)
;;         (set! inc (/ frq SRs))
;;         ;; positive frequencies
;;         (if (and (> inc 0.0) (>= mod 1.0))
;;             (set! mod (- mod 1.0)))
;;         ;; negative frequencies
;;         (if (and (< inc 0.0) (<= mod 0.0))
;;             (set! mod (+ mod 1.0)))
;;         ;; inline polyblep
;;         (set! absinc (fabs inc))
;;         (set! blep 0.0)
;;         (if (> mod (- 1.0 absinc))
;;             (begin (set! t (/ (- mod 1.0) absinc))
;;                    (set! blep (+ (* t t) (* 2.0 t) 1.0)))
;;             (if (< mod absinc)
;;                 (begin (set! t (/ mod absinc))
;;                        (set! blep (- (* 2.0 t) (* t t) 1.0)))))
;;         (if (not rising) (set! blep (* blep -1.0)))
;;         (set! out (* inv (- (* mod 2.0) 1.0))) ;; bipolar
;;         (set! mod (+ mod inc)) ;; update mod
;;         (* amp (+ out blep))))))

;; bandlimited sawtooth (blep variant of saw_c)
;;
;; mod is phase between 0.0-1.0 (i.e. not 2pi)
;; ramp is rising by default (invert for falling)
;; highcpu=#t - better wave at higher cpu cost
(bind-func blsaw_c
  (lambda (mod inverted:i1 highcpu:i1)
    (let ((inc 0.0) (absinc 0.0:f) (out 0.0) (blep 0.0) (t 0.0)
          (rising (if inverted #t #f))
          (inv (if inverted -1.0 1.0)))
      (lambda (amp:float frq:float)
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        (set! blep
              (if highcpu
                  (blep_n (cast fBLEPTable_8_BLKHAR SAMPLE*) 4096.0 mod (fabs inc) 1.0 rising 4.0 #f)
                  (poly_blep mod (fabs inc) 1.0 rising)))
        (set! out (* inv (- (* mod 2.0) 1.0))) ;; bipolar
        (set! mod (+ mod inc)) ;; update mod
        (* amp (+ out blep))))))

(bind-func blsaw_c
  (lambda (mod inverted)
    (blsaw_c:[[float,float,float]*,float,i1,i1]* mod inverted #f)))

(bind-func blsaw_c
  (lambda (mod)
    (blsaw_c:[[float,float,float]*,float,i1,i1]* mod #f #f)))

(bind-func blsaw_mc_c
  (lambda (mod inverted highcpu)
    (let ((osc (blsaw_c mod inverted highcpu))
          (out 0.0))
      (lambda (chan amp frq)
        (if (= chan 0)
            (set! out (osc amp frq)))
        out))))

(bind-func blsaw_mc_c
  (lambda (mod inverted)
    (blsaw_mc_c:[[float,i64,float,float]*,float,i1,i1]* mod inverted #f)))

(bind-func blsaw_mc_c
  (lambda (mod)
    (blsaw_mc_c:[[float,i64,float,float]*,float,i1,i1]* mod #f #f)))

;;;;;;;;;;;; pulse waves


;; bandlimited pulse wave
;; use sum of saws method
;; (bind-func blpulse_c
;;   (lambda (mod:float)
;;     (let ((out 0.0) (inc 0.0) (mod2:float 0.0)
;;           (blep 0.0:f) (absinc 0.0) (t 0.0)
;;           (saw1 0.0) (saw2 0.0) (dcorr 0.0))
;;       (lambda (amp:float frq:float pw:float)
;;         (set! pw (clamp (fabs pw) 0.05 0.95))
;;         (set! inc (/ frq SRs))
;;         ;; positive frequencies
;;         (if (and (> inc 0.0) (>= mod 1.0))
;;             (set! mod (- mod 1.0)))
;;         ;; negative frequencies
;;         (if (and (< inc 0.0) (<= mod 0.0))
;;             (set! mod (+ mod 1.0)))
;;         ;; saw 1
;;         ;; inline polyblep
;;         (set! absinc (fabs inc))
;;         (set! blep 0.0)
;;         (if (> mod (- 1.0 absinc))
;;             (begin (set! t (/ (- mod 1.0) absinc))
;;                    (set! blep (+ (* t t) (* 2.0 t) 1.0)))
;;             (if (< mod absinc)
;;                 (begin (set! t (/ mod absinc))
;;                        (set! blep (- (* 2.0 t) (* t t) 1.0)))))
;;         (set! saw1 (+ blep (- (* mod 2.0) 1.0)))
;;         ;; saw 2
;;         ;; first calc offset for saw2 based on pw
;;         (if (> inc 0.0)
;;             (set! mod2 (+ mod pw))
;;             (set! mod2 (- mod pw)))
;;         ;; positive frequencies
;;         (if (and (> inc 0.0) (>= mod2 1.0))
;;             (set! mod2 (- mod2 1.0)))
;;         ;; negative frequencies
;;         (if (and (< inc 0.0) (<= mod2 0.0))
;;             (set! mod2 (+ mod2 1.0)))
;;         ;; saw 2
;;         ;; inline polyblep
;;         (set! absinc (fabs inc))
;;         (set! blep 0.0)
;;         (if (> mod2 (- 1.0 absinc))
;;             (begin (set! t (/ (- mod2 1.0) absinc))
;;                    (set! blep (+ (* t t) (* 2.0 t) 1.0)))
;;             (if (< mod2 absinc)
;;                 (begin (set! t (/ mod2 absinc))
;;                        (set! blep (- (* 2.0 t) (* t t) 1.0)))))
;;         (set! saw2 (+ blep (- (* mod2 2.0) 1.0)))
;;         ;; subtract 180 out of phase
;;         (set! out (- (* 0.5 saw1) (* 0.5 saw2)))
;;         ;; dc correction
;;         (set! dcorr (/ 1.0 pw))
;;         (if (< pw 0.5)
;;             (set! dcorr (/ 1.0 (- 1.0 pw))))
;;         (set! out (* out dcorr))
;;         (set! mod (+ mod inc)) ;; update mod
;;         (* amp out)))))


;; bandlimited pulse wave
;; use sum of saws method
(bind-func blpulse2_c
  (lambda (mod:float)
    (let ((out 0.0) (inc 0.0) (mod2:float 0.0)
          (blep 0.0:f) (absinc 0.0) (t 0.0)
          (saw1 0.0) (saw2 0.0) (dcorr 0.0))
      (lambda (amp:float frq:float pw:float)
        (set! pw (clamp (fabs pw) 0.05 0.95))
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        ;; saw 1
        ;; inline polyblep
        (set! blep (poly_blep mod (fabs inc) 1.0 #f))
        (set! saw1 (+ blep (- (* mod 2.0) 1.0)))
        ;; saw 2
        ;; first calc offset for saw2 based on pw
        (if (> inc 0.0)
            (set! mod2 (+ mod pw))
            (set! mod2 (- mod pw)))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod2 1.0))
            (set! mod2 (- mod2 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod2 0.0))
            (set! mod2 (+ mod2 1.0)))
        ;; saw 2
        ;; inline polyblep
        (set! blep (poly_blep mod2 (fabs inc) 1.0 #f))
        (set! saw2 (+ blep (- (* mod2 2.0) 1.0)))
        ;; subtract 180 out of phase
        (set! out (- (* 0.5 saw1) (* 0.5 saw2)))
        ;; dc correction
        (set! dcorr (/ 1.0 pw))
        (if (< pw 0.5)
            (set! dcorr (/ 1.0 (- 1.0 pw))))
        (set! out (* out dcorr))
        (set! mod (+ mod inc)) ;; update mod
        (* amp out)))))


;; bandlimited pulse wave
;; use sum of saws method
;; highcpu #t (default is lowcpu #f)
(bind-func blpulse_c
  (lambda (mod:float highcpu:i1)
    (let ((out 0.0) (inc 0.0) (mod2:float 0.0)
          (blep 0.0:f) (absinc 0.0) (t 0.0)
          (saw1 0.0) (saw2 0.0) (dcorr 0.0))
      (lambda (amp:float frq:float pw:float)
        (set! pw (clamp (fabs pw) 0.05 0.95))
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (set! mod (- mod 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (set! mod (+ mod 1.0)))
        ;; saw 1
        (set! blep (if highcpu
                       (blep_n (cast fBLEPTable_8_BLKHAR SAMPLE*) 4096.0 mod (fabs inc) 1.0 #f 4.0 #f)
                       (poly_blep mod (fabs inc) 1.0 #f)))
        (set! saw1 (+ blep (- (* mod 2.0) 1.0)))
        ;; saw 2
        ;; first calc offset for saw2 based on pw
        (if (> inc 0.0)
            (set! mod2 (+ mod pw))
            (set! mod2 (- mod pw)))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod2 1.0))
            (set! mod2 (- mod2 1.0)))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod2 0.0))
            (set! mod2 (+ mod2 1.0)))
        ;; now calc saw 2
        (set! blep (if highcpu
                       (blep_n (cast fBLEPTable_8_BLKHAR SAMPLE*) 4096.0 mod2 (fabs inc) 1.0 #f 4.0 #f)
                       (poly_blep mod2 (fabs inc) 1.0 #f)))
        (set! saw2 (+ blep (- (* mod2 2.0) 1.0)))
        ;; subtract 180 out of phase
        (set! out (- (* 0.5 saw1) (* 0.5 saw2)))
        ;; dc correction
        (set! dcorr (/ 1.0 pw))
        (if (< pw 0.5)
            (set! dcorr (/ 1.0 (- 1.0 pw))))
        (set! out (* out dcorr))
        (set! mod (+ mod inc)) ;; update mod
        (* amp out)))))

;; mod is phase (0.0-1.0)
(bind-func blpulse_c
  (lambda (mod)
    (blpulse_c:[[float,float,float,float]*,float,i1]* mod #f)))


;;;;;;;;;;;;; triangle waves

;; mod is phase (0.0-1.0)

(bind-func static bltri_c
  (lambda (mod:float)
    (let ((sawout:float 0.0) (sqrout 0.0) (inc 0.0)
          (out:float 0.0)
          (sqrmod 1.0)
          (diffout 0.0) (zreg:float 0.0) (c 0.0))
      (lambda (amp:float frq:float)
        (set! inc (/ frq SRs))
        ;; positive frequencies
        (if (and (> inc 0.0) (>= mod 1.0))
            (begin (set! mod (- mod 1.0))
                   (set! sqrmod (* sqrmod -1.0))))
        ;; negative frequencies
        (if (and (< inc 0.0) (<= mod 0.0))
            (begin (set! mod (+ mod 1.0))
                   (set! sqrmod (* sqrmod -1.0))))
        ;; start with saw
        (set! sawout (- (* mod 2.0) 1.0)) ;; bipolar sawtooth
        (set! sawout (* sawout sawout)) ;; sqr'd sawtooth
        (set! sawout (- 1.0 sawout)) ;; inverted sqr'd sawtooth
        ;; modulate with sqr (50 % pulse width)
        (set! out (* sawout sqrmod))
        ;; differentiate
        (set! diffout (- out zreg))
        (set! zreg out)
        (set! c (/ SRs (* 4.0 2.0 frq (- 1.0 inc))))
        (set! mod (+ mod inc)) ;; update mod
        (set! mod (+ mod inc)) ;; update mod
        (* diffout c amp)))))


;; ;;;;;;;;;;;;;;;;; sine waves

;; same as osc_c
(bind-func static sin_c
  (lambda (phase)
    (let ((t (/ STWOPI SAMPLERATE)))
      (lambda (amp freq)
        (set! phase (+ phase (* t (clamp freq (- 0.0 SRs) SRs))))
        (if (> phase SPI) (set! phase (- phase STWOPI)))
        (* amp (parabolicSineHP phase))))))


;;;;;;;;;;;;;;;;;;;;; noise


;; white noise generator
(bind-func static white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))


;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func static pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  filters
;;

;; tivial one pole LPF
;; cutoff controlled via g (0.0-1.0)
(bind-func static lpf_1p_c
  (lambda ()
    (let ((y-1 0.0))
      (lambda (x:SAMPLE g)
        (set! y-1
              (+ (* x (- 1.0 g))
                 (* y-1 g)))
        y-1))))

;; VAOnePole from will pirkle

(bind-val LPF1 enum 0)
(bind-val LPF2 enum 1)
(bind-val LPF4 enum 2)
(bind-val HPF1 enum 3)
(bind-val HPF2 enum 4)
(bind-val HPF4 enum 5)
(bind-val BPF1 enum 6)
(bind-val BPF2 enum 7)
(bind-val BPF4 enum 8)

(bind-func static va_onepole
  (lambda (type) ;; either LPF1 or HPF1
    (if (and (<> type HPF1) (<> type LPF1)) (println "BAD TYPE FOR FILTER: should be LPF1 or HPF1"))
    (let ((m_dAlpha:SAMPLE* (alloc 1))    ;; feed forward coeff
          (m_dBeta:SAMPLE* (alloc 1))     ;; for korg and moog
          (m_dGamma 1.0)    ;; pre gain
          (m_dDelta 0.0)    ;; FB in
          (m_dEpsilon 0.0)  ;; FB out
          (m_da0 1.0)       ;; input gain
          (m_dZ1 0.0)       ;; z-1 register
          (vn 0.0)          ;; fn
          (xn:SAMPLE 0.0)
          (feedbackOutput:SAMPLE* (alloc 1)) ;; (lambda () (* (pref m_dBeta 0) (+ m_dZ1 (* m_dFeedback m_dDelta)))))
          (lpf 0.0)
          (hpf 0.0))
      (lambda (x:SAMPLE fb)
        ;; (set! m_dFeedback fb)
        (pset! feedbackOutput 0 (* (pref m_dBeta 0) (+ m_dZ1 (* fb m_dDelta))))
        ;; for diode filter support
        (set! xn (+ (* x m_dGamma) fb (* m_dEpsilon (pref feedbackOutput 0))))
        (set! vn (* (- (* m_da0 xn) m_dZ1) (pref m_dAlpha 0)))
        (set! lpf (+ vn m_dZ1))
        (set! m_dZ1 (+ vn lpf))
        (set! hpf (- xn lpf))
        (if (= type HPF1) hpf lpf)))))

;; type is LPF4, LPF2, BPF4, BPF2, HPF4, HPF2
;; rate is the minimum number of samples to allow between frq/res updates
(bind-func static moog_ladder
  (lambda (type)
    (let ((m_dK 0.0)
          (m_dAlpha_0 1.0)
          (m_dAlpha 0.0)
          (m_dGamma 0.0)
          (dSigma 0.0) (dU 0.0)
          (m_dA 0.0) (m_dB 0.0) (m_dC 0.0) (m_dD 0.0) (m_dE 1.0)
          (dlpf1 0.0) (dlpf2 0.0) (dlpf3 0.0) (dlpf4 0.0)
          (lpf1 (va_onepole LPF1))
          (lpf2 (va_onepole LPF1))
          (lpf3 (va_onepole LPF1))
          (lpf4 (va_onepole LPF1))
          (lpf1output:SAMPLE* (lpf1.feedbackOutput))
          (lpf2output:SAMPLE* (lpf2.feedbackOutput))
          (lpf3output:SAMPLE* (lpf3.feedbackOutput))
          (lpf4output:SAMPLE* (lpf4.feedbackOutput))
          (lpf1alpha:SAMPLE* (lpf1.m_dAlpha))
          (lpf2alpha:SAMPLE* (lpf2.m_dAlpha))
          (lpf3alpha:SAMPLE* (lpf3.m_dAlpha))
          (lpf4alpha:SAMPLE* (lpf4.m_dAlpha))
          (lpf1beta:SAMPLE* (lpf1.m_dBeta))
          (lpf2beta:SAMPLE* (lpf2.m_dBeta))
          (lpf3beta:SAMPLE* (lpf3.m_dBeta))
          (lpf4beta:SAMPLE* (lpf4.m_dBeta))
          (feedback:SAMPLE 0.01)
          (saturation:SAMPLE 1.0)
          (T (/ 1.0 SRs))
          (g:SAMPLE 0.0)
          (G:SAMPLE 0.0)
          (t2 (/ 2.0 T))
          (halfT (/ T 2.0))
          (oldfrq 0.0)
          (oldQ 0.0))
      (cond ((= type LPF4) (set! m_dA 0.0) (set! m_dB 0.0) (set! m_dC 0.0) (set! m_dD 0.0) (set! m_dE 1.0))
            ((= type LPF2) (set! m_dA 0.0) (set! m_dB 0.0) (set! m_dC 1.0) (set! m_dD 0.0) (set! m_dE 0.0))
            ((= type BPF4) (set! m_dA 0.0) (set! m_dB 0.0) (set! m_dC 4.0) (set! m_dD -8.0) (set! m_dE 4.0))
            ((= type BPF2) (set! m_dA 0.0) (set! m_dB 2.0) (set! m_dC -2.0) (set! m_dD 0.0) (set! m_dE 0.0))
            ((= type HPF4) (set! m_dA 1.0) (set! m_dB -4.0) (set! m_dC 6.0) (set! m_dD -4.0) (set! m_dE 1.0))
            ((= type HPF2) (set! m_dA 1.0) (set! m_dB -4.0) (set! m_dC 6.0) (set! m_dD -4.0) (set! m_dE 1.0))
            (else ;; default to LPF4
             (set! m_dA 0.0) (set! m_dB 0.0) (set! m_dC 0.0) (set! m_dD 0.0) (set! m_dE 1.0)))
      (lambda (in:SAMPLE frq:SAMPLE Q:SAMPLE)
        ;; update Q
        (if (or (<> oldQ Q) (<> oldfrq frq))
            (begin (if (< frq 0.0) (set! frq (fabs frq)))
                   (if (< Q 0.0) (set! Q (fabs Q)))
                   (set! oldQ Q)
                   (set! oldfrq frq)
                   (set! m_dK (* 4.0 Q))
                   (set! oldfrq frq)
                   (set! m_dAlpha (* t2 (tan (* STWOPI frq halfT))))
                   (set! g (* halfT m_dAlpha))
                   (set! G (/ g (+ 1.0 g)))
                   (pset! lpf1alpha 0 G)
                   (pset! lpf2alpha 0 G)
                   (pset! lpf3alpha 0 G)
                   (pset! lpf4alpha 0 G)
                   (pset! lpf1beta 0 (* G G (/ G (+ 1.0 g))))
                   (pset! lpf2beta 0 (* G (/ G (+ 1.0 g))))
                   (pset! lpf3beta 0 (/ G (+ 1.0 g)))
                   (pset! lpf4beta 0 (/ 1.0 (+ 1.0 g)))
                   (set! m_dGamma (* G G G G))
                   (set! m_dAlpha_0 (/ 1.0 (+ 1.0 (* m_dK m_dGamma))))))
        (set! dSigma (+ (pref lpf1output 0) (pref lpf2output 0) (pref lpf3output 0) (pref lpf4output 0)))
        (set! in (* in (+ 1.0 m_dK)))
        (set! dU (* (- in (* m_dK dSigma)) m_dAlpha_0))
        (set! dU (tanh (* saturation dU)))
        ;; cascade filters
        (set! dlpf1 (lpf1 dU feedback))
        (set! dlpf2 (lpf2 dlpf1 feedback))
        (set! dlpf3 (lpf3 dlpf2 feedback))
        (set! dlpf4 (lpf4 dlpf3 feedback))
        ;; filter type
        (+ (* m_dA dU) (* m_dB dlpf1) (* m_dC dlpf2) (* m_dD dlpf3) (* m_dE dlpf4))))))



;; http://www.cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf
;; the 'using v1 to compute v2' version


;; the @param tags in the docstring are actually for the returned
;; closure (hence being below the @return tag in the docstring)
(bind-func static svf_c
  "a state variable filter (SVF)

@return - a closure which takes 4 arguments:
@param in - input pointer |6,SAMPLE|* (|low,band,high,notch,peak,allpass|)
@param cutoff - filter cutoff (Hz)
@param res - filter resonance
@param outarray - place to store the output
"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res outarray:|6,SAMPLE|*)
        ;; one option: do the check (= res oldres) trick here
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (aset! outarray 0 v2) ;; low
        (aset! outarray 1 v1) ;; band
        (aset! outarray 2 (- (- in (* k v1)) v2)) ;; high
        (aset! outarray 3 (- in (* k v1))) ;; notch
        (aset! outarray 4 (- (- in (* k v1)) (* 2.0 v2))) ;; peak
        (aset! outarray 5 (- in (* 2.0 k v1))) ;; all pass
        outarray))))

(bind-func static svf_mc_c
  (lambda (nchan:i64)
    (let ((svf_buf:[|6,float|*,float,float,float,|6,float|*]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! svf_buf i (svf_c)))
      (lambda (chan in cutoff res outarray)
        ((pref svf_buf chan) in cutoff res outarray)))))

(bind-func static lpf_c
  "lowpass filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g:SAMPLE 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func static lpf_mc_c
  (lambda (nchan:i64)
    (let ((lpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! lpf_buf i (lpf_c)))
      (lambda (chan in cutoff res)
        ((pref lpf_buf chan) in cutoff res)))))

(bind-func static lpf2_c
  "a state variable lowpass filter. slightly more flops than lpf_c,
but v1 and v2 can be computed in parallel"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
      (lambda (in cutoff res)
        (set! g (tan (* SPI (/ cutoff SRs))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k )))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func static lpf2_mc_c
  (lambda (nchan:i64)
    (let ((lpf2_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan)
        (pset! lpf2_buf i (lpf2_c)))
      (lambda (chan in cutoff res)
        ((pref lpf2_buf chan) in cutoff res)))))

(bind-func static bpf_c
  "bandpass filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v1))))

(bind-func static bpf_mc_c
  (lambda (nchan:i64)
    (let ((bpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! bpf_buf i (bpf_c)))
      (lambda (chan in cutoff res)
        ((pref bpf_buf chan) in cutoff res)))))

(bind-func static hpf_c
  "highpass filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- (- in (* k v1)) v2)))))

(bind-func static hpf_mc_c
  (lambda (nchan:i64)
    (let ((hpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! hpf_buf i (hpf_c)))
      (lambda (chan in cutoff res)
        ((pref hpf_buf chan) in cutoff res)))))


(bind-func static apf_c
  "allpass filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g:SAMPLE 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (* 2.0 k v1))))))



(bind-func static notch_c
  "notch filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (* k v1))))))

(bind-func static notch_mc_c
  (lambda (nchan:i64)
    (let ((notch_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! notch_buf i (notch_c)))
      (lambda (chan in cutoff res)
        ((pref notch_buf chan) in cutoff res)))))

(bind-func static peak_c
  "peak filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (ocutoff -1.0) (ores -1.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        (if (or (<> cutoff ocutoff)
                (<> res ores))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< res 0.0) (set! res (fabs res)))
              (set! ocutoff cutoff)
              (set! ores res)
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (- 2.0 (* 2.0 res)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- (- in (* k v1)) (* 2.0 v2))))))

(bind-func static peak_mc_c
  (lambda (nchan:i64)
    (let ((peak_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! peak_buf i (peak_c)))
      (lambda (chan in cutoff res)
        ((pref peak_buf chan) in cutoff res)))))

;; Q is usually around 0.5
;; gain is either a boost up to +5.0db or a reduction down to -24.0db
(bind-func static bell_c
  "bell filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 1.0) (m1 1.0) (m2 1.0)
          (ogain -100000.0) (ocutoff -1.0) (oQ -1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
      (lambda (in cutoff gain Q)
        ;; one option: do the check (= res oldres) trick here
        (if (or (<> gain ogain)
                (<> cutoff ocutoff)
                (<> Q oQ))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< Q 0.0) (set! Q (fabs Q)))
              (set! ogain gain)
              (set! ocutoff cutoff)
              (set! oQ Q)
              (set! A (pow 10.0 (/ gain 40.0)))
              (set! g (tan (* SPI (/ cutoff SRs))))
              (set! k (/ 1.0 (* (+ Q 0.0000001) A)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))
              (set! a3 (* g a2))
              (set! m0 1.0)
              (set! m1 (* k (- (* A A) 1.0)))
              (set! m2 0.0)))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ in (* m1 v1))))))

(bind-func static bell_mc_c
  (lambda (nchan:i64)
    (let ((bell_buf:[float,float,float,float,float]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! bell_buf i (bell_c)))
      (lambda (chan in cutoff gain Q)
        ((pref bell_buf chan) in cutoff gain Q)))))


;; Q is usually around 0.5
;; gain is either a boost up to +5.0db or a reduction down to -24.0db
(bind-func static lshelf_c
  "low shelf filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 1.0) (m1 1.0) (m2 1.0)
          (ogain -1000000.0) (ocutoff -1.0) (oQ -1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
      (lambda (in cutoff gain Q)
        (if (or (<> gain ogain)
                (<> cutoff ocutoff)
                (<> Q oQ))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< Q 0.0) (set! Q (fabs Q)))
              (set! ogain gain)
              (set! ocutoff cutoff)
              (set! oQ Q)
              ;; one option: do the check (= res oldres) trick here
              (set! A (pow 10.0 (/ gain 40.0)))
              (set! g (/ (tan (* SPI (/ cutoff SRs)))
                         (sqrt A)))
              (set! k (/ 1.0 (+ Q 0.0000001)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))
              (set! a3 (* g a2))
              (set! m0 1.0)
              (set! m1 (* k (- A 1.0)))
              (set! m2 (- (* A A) 1.0))))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ in (* m1 v1) (* m2 v2))))))

(bind-func static lshelf_mc_c
  (lambda (nchan:i64)
    (let ((lshelf_buf:[float,float,float,float,float]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! lshelf_buf i (lshelf_c)))
      (lambda (chan in cutoff gain Q)
        ((pref lshelf_buf chan) in cutoff gain Q)))))


(bind-func static hshelf_c
  "high shelf filter: returns filtering closure which implements a state variable filter"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 0.0) (m1 1.0) (m2 1.0)
          (ogain -100000000.0) (ocutoff -1.0) (oQ -1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
      (lambda (in cutoff gain Q)
        (if (or (<> gain ogain)
                (<> cutoff ocutoff)
                (<> Q oQ))
            (begin
              ;; negative frq & res
              (if (< cutoff 0.0) (set! cutoff (fabs cutoff)))
              (if (< Q 0.0) (set! Q (fabs Q)))
              (set! ogain gain)
              (set! ocutoff cutoff)
              (set! oQ Q)
              (set! A (pow 10.0 (/ gain 40.0)))
              (set! g (/ (tan (* SPI (/ cutoff SRs)))
                         (sqrt A)))
              (set! k (/ 1.0 (+ Q 0.0000001)))
              (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
              (set! a2 (* g a1))
              (set! a3 (* g a2))
              (set! m0 (* A A))
              (set! m1 (* k (- 1.0 A) A))
              (set! m2 (- 1.0 (* A A)))))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ (* m0 in) (* m1 v1) (* m2 v2))))))

(bind-func static hshelf_mc_c
  (lambda (nchan:i64)
    (let ((hshelf_buf:[float,float,float,float,float]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! hshelf_buf i (hshelf_c)))
      (lambda (chan in cutoff gain Q)
        ((pref hshelf_buf chan) in cutoff gain Q)))))


(bind-func static parametricEQ
  (lambda ()
    (let ((hmid (bell_c))
          (lmid (bell_c))
          (lshelf (lshelf_c))
          (hshelf (hshelf_c))
          (hshelfF:SAMPLE 12000.0)
          (lshelfF:SAMPLE 50.0)
          (hshelfG:SAMPLE 0.0)
          (lshelfG:SAMPLE 0.0)
          (hshelfQ:SAMPLE 0.5)
          (lshelfQ:SAMPLE 0.5)
          (lmidF:SAMPLE 350.0)
          (hmidF:SAMPLE 5000.0)
          (lmidG:SAMPLE 0.0)
          (hmidG:SAMPLE 0.0)
          (lmidQ:SAMPLE 0.5)
          (hmidQ:SAMPLE 0.5))
      (lambda (in chan:i64)
        (if (= chan 0)
            (hshelf (hmid (lmid (lshelf in lshelfF lshelfG lshelfQ)
                                lmidF lmidG lmidQ)
                          hmidF hmidG hmidQ)
                    hshelfF hshelfG hshelfQ)
            0.0)))))


(bind-func static busEQ
  (lambda ()
    (let ((hmid_L (bell_c))
          (lmid_L (bell_c))
          (lshelf_L (lshelf_c))
          (hshelf_L (hshelf_c))
          (hmid_R (bell_c))
          (lmid_R (bell_c))
          (lshelf_R (lshelf_c))
          (hshelf_R (hshelf_c))
          (hshelfF:SAMPLE 12000.0)
          (lshelfF:SAMPLE 50.0)
          (hshelfG:SAMPLE 0.0)
          (lshelfG:SAMPLE 0.0)
          (hshelfQ:SAMPLE 0.5)
          (lshelfQ:SAMPLE 0.5)
          (lmidF:SAMPLE 350.0)
          (hmidF:SAMPLE 5000.0)
          (lmidG:SAMPLE 0.0)
          (hmidG:SAMPLE 0.0)
          (lmidQ:SAMPLE 0.5)
          (hmidQ:SAMPLE 0.5))
      (lambda (in chan:i64)
        (if (= chan 0)
            (hshelf_L (hmid_L (lmid_L (lshelf_L in lshelfF lshelfG lshelfQ)
                                      lmidF lmidG lmidQ)
                              hmidF hmidG hmidQ)
                      hshelfF hshelfG hshelfQ)
            (if (= chan 1)
                (hshelf_R (hmid_R (lmid_R (lshelf_R in lshelfF lshelfG lshelfQ)
                                          lmidF lmidG lmidQ)
                                  hmidF hmidG hmidQ)
                          hshelfF hshelfG hshelfQ)
                0.0))))))

;; low mid (the works with both parametricEQ and busEQ)
(bind-func set_peq_lmid
  (lambda (peq:i8* cutoff:float gain:float Q:float)
    (cset! (cast peq [void]*) lmidG gain float)
    (cset! (cast peq [void]*) lmidF cutoff float)
    (cset! (cast peq [void]*) lmidQ Q float)))

;; high mid (the works with both parametricEQ and busEQ)
(bind-func set_peq_hmid
  (lambda (peq:i8* cutoff:float gain:float Q:float)
    (cset! (cast peq [void]*) hmidG gain float)
    (cset! (cast peq [void]*) hmidF cutoff float)
    (cset! (cast peq [void]*) hmidQ Q float)))

;; high shelf (the works with both parametricEQ and busEQ)
(bind-func set_peq_hshelf
  (lambda (peq:i8* cutoff:float gain:float Q:float)
    (cset! (cast peq [void]*) hshelfG gain float)
    (cset! (cast peq [void]*) hshelfF cutoff float)
    (cset! (cast peq [void]*) hshelfQ Q float)))

;; low shelf (the works with both parametricEQ and busEQ)
(bind-func set_peq_lshelf
  (lambda (peq:i8* cutoff:float gain:float Q:float)
    (cset! (cast peq [void]*) lshelfG gain float)
    (cset! (cast peq [void]*) lshelfF cutoff float)
    (cset! (cast peq [void]*) lshelfQ Q float)))


;; Andy Simper's Sallen Key LPF
;; http://cytomic.com/files/dsp/SkfLinearTrapOptimised2.pdf

(bind-func static skf_c
  "lowpass filter: returns filtering closure using a Sallen Key lpf"
  (lambda ()
    (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a0 0.0) (a1 0.0) (a2 0.0) (a3 0.0) (a4 0.0) (a5 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
      (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
        (set! g (tan (* SPI (/ cutoff SRs))))
        (set! k (* 2.0 res))
        (set! a0 (/ 1.0 (- (* (+ 1.0 g)
                              (+ 1.0 g))
                           (* g k))))
        (set! a1 (* k a0))
        (set! a2 (* (+ 1.0 g) a0))
        (set! a3 (* g a2))
        (set! a4 (/ 1.0 (+ 1.0 g)))
        (set! a5 (* g a4))
        (set! v1 (+ (* a1 ic2eq)
                    (* a2 ic1eq)
                    (* a3 in)))
        (set! v2 (+ (* a4 ic2eq)
                    (* a5 v1)))
        (set! ic1eq (- (* 2.0 (- v1 (* k v2))) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func static skf_mc_c
  (lambda (nchan:i64)
    (let ((skf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! skf_buf i (skf_c)))
      (lambda (chan in cutoff res)
        ((pref skf_buf chan) in cutoff res)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; ;; pulse train
;; (bind-func pulse_c
;;   (lambda ()
;;     (let ((time -1.0)
;;           (period:SAMPLE 0.0))
;;       (lambda (amp:SAMPLE freq width)
;;         (set! period (/ SAMPLERATE freq))
;;         (set! time (+ time 1.0))
;;         (if (< (modulo time period) width)
;;             amp
;;             0.0)))))

;; (bind-func pulse_mc_c
;;   (lambda ()
;;     (let ((pulse (pulse_c))
;;           (mem 0.0))
;;       (lambda (chan:i64 amp freq width)
;;         (if (= chan 0) (set! mem (pulse amp freq width)))
;;         mem))))

;; linear fade closure
(bind-func static fade_c
  (lambda ()
    (let ((t 0.0)
          (incr (/ 1.0 (convert SAMPLE_RATE SAMPLE))))
      (lambda (initial:SAMPLE final dur)
        (set! t (+ t incr))
        (if (> t dur)
            final
            (+ initial (* (/ t dur) (- final initial))))))))

(bind-func static fade_mc_c
  (lambda ()
    (let ((val 0.0)
          (fader (fade_c )))
      (lambda (chan:i64 initial final dur)
        (if (= chan 0) (set! val (fader initial final dur)))
        val))))


;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func static delay_c
  (lambda (delay:i64)
    (let ((line:SAMPLE* (zalloc delay))
          (time 0)
          (i 0)
          (n 0)
          (y 0.0))
      (dotimes (i delay) (pset! line i 0.0))
      (lambda (x:SAMPLE wet feedback)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(bind-func static delay_mc_c
  (lambda (channels:i64 max_delay)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
      (lambda (chan:i64 x wet feedback)
        ((pref dlines chan) x wet feedback)))))

(bind-func static delay_st_c
  (lambda (d1 d2)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc 2))
          (i:i64 0))
      (pset! dlines 0 (delay_c d1))
      (pset! dlines 1 (delay_c d2))
      (lambda (chan:i64 x wet feedback)
        ((pref dlines chan) x wet feedback)))))

;; a delay all pass filter
(bind-func static delay_apf_c
  (lambda (delay:i64)
    (let ((line:SAMPLE* (zalloc delay))
          (time 0)
          (n 0)
          (tmp 0.0)
          (y 0.0))
      (lambda (x:SAMPLE afp_gain)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (set! tmp (+ x (* afp_gain y)))
        (pset! line n tmp)
        (+ (* -1.0 afp_gain tmp) y)))))

;; iir comb with interpolation
;; delay for COMB needs to stay
;; as a fractional argument (i.e. float)
(bind-func static comb_c
  (lambda (maxdelay:i64)
    (let ((line:SAMPLE* (zalloc maxdelay))
          (in_head 0)
          (out_head 0)
          (out_head_alpha 0)
          (olddelay:SAMPLE (convert maxdelay))
          (alpha 0.0)
          (i:i64 0)
          (idelay:i64 0)
          (delayed:SAMPLE 0.0)
          (delayedY:SAMPLE 0.0)
          (delayedY1:SAMPLE 0.0)
          (delayedLin:SAMPLE 0.0)) ;; linear interp
      (dotimes (i maxdelay) (pset! line i 0.0))
      (lambda (x:SAMPLE delay:SAMPLE in:SAMPLE mix:SAMPLE fb:SAMPLE)
        (if (<> delay olddelay)
            (begin (set! olddelay delay)
                   (set! alpha (- delay (floor delay)))
                   (set! idelay (convert (floor delay)))
                   (set! out_head (- (+ maxdelay in_head) idelay))
                   (set! out_head_alpha (- (+ maxdelay in_head) (+ 1 idelay)))))
        (if (> out_head maxdelay) (set! out_head (- out_head maxdelay)))
        (if (> out_head_alpha maxdelay) (set! out_head_alpha (- out_head_alpha maxdelay)))
        (if (> in_head maxdelay) (set! in_head (- in_head maxdelay)))
        (set! delayedY1 (pref line out_head))
        (set! delayedY (pref line out_head_alpha))
        (set! delayedLin (* (- delayedY delayedY1) alpha))
        (set! delayed (+ delayedY1 delayedLin))
        (pset! line in_head (+ (* in x) (* fb delayed)))
        (set! in_head (+ in_head 1))
        (set! out_head (+ out_head 1))
        (set! out_head_alpha (+ out_head_alpha 1))
        (+ (* x (- 1.0 mix)) (* delayed mix))))))

(bind-func static comb_mc_c
  (lambda (channels:i64 max_delay)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
      (lambda (chan:i64 x delay in mix fb)
        ((pref dlines chan) x delay in mix fb)))))

;; same as comb_c but includes APF
(bind-func static comb_apf_c
  (lambda (maxdelay:i64)
    (let ((line:SAMPLE* (zalloc maxdelay))
          (in_head 0)
          (out_head 0)
          (out_head_alpha 0)
          (olddelay:SAMPLE (convert maxdelay))
          (alpha 0.0)
          (tmp:SAMPLE 0.0)
          (i:i64 0)
          (idelay:i64 0)
          (delayed:SAMPLE 0.0)
          (delayedY:SAMPLE 0.0)
          (delayedY1:SAMPLE 0.0)
          (delayedLin:SAMPLE 0.0)) ;; linear interp
      (dotimes (i maxdelay) (pset! line i 0.0))
      (lambda (x:SAMPLE delay:SAMPLE apf_gain:SAMPLE)
        (if (<> delay olddelay)
            (begin (set! olddelay delay)
                   (set! alpha (- delay (floor delay)))
                   (set! idelay (convert (floor delay)))
                   (set! out_head (- (+ maxdelay in_head) idelay))
                   (set! out_head_alpha (- (+ maxdelay in_head) (+ 1 idelay)))))
        (if (> out_head maxdelay) (set! out_head (- out_head maxdelay)))
        (if (> out_head_alpha maxdelay) (set! out_head_alpha (- out_head_alpha maxdelay)))
        (if (> in_head maxdelay) (set! in_head (- in_head maxdelay)))
        (set! delayedY1 (pref line out_head))
        (set! delayedY (pref line out_head_alpha))
        (set! delayedLin (* (- delayedY delayedY1) alpha))
        (set! delayed (+ delayedY1 delayedLin))
        (set! tmp (+ x (* apf_gain delayed)))
        (pset! line in_head tmp)
        (set! in_head (+ in_head 1))
        (set! out_head_alpha (+ out_head_alpha 1))
        (set! out_head (+ out_head 1))
        (+ (* -1.0:f apf_gain tmp) delayed)))))



;; flanger
;; delay in milliseconds
;; range in milliseconds
;; rate in hertz
(bind-func static flanger_c
  (lambda ()
    (let ((ms (* .001 SRf))
          (halfsrf (* 0.5 SRf))
          (comb (comb_c (convert SRf)))
          (mod (osc_c 0.0)))
      (lambda (x:SAMPLE in out delay range rate feedback)
        (comb x
              (+ (* ms delay)
                 (clamp (* ms range (+ 0.5 (mod 0.5 rate)))
                        0.0 halfsrf))
              in out feedback)))))

;; stereo flanger (quadrature)
(bind-func static flanger_st_c
  (lambda ()
    (let ((ms (* .001 SRf))
          (halfsrf (* 0.5 SRf))
          (combl (comb_c (convert SRf)))
          (combr (comb_c (convert SRf)))
          (modl (osc_c 0.0))
          (modr (osc_c 0.25)))
      (lambda (chan:i64 x:SAMPLE in out low high rate feedback)
        (if (= chan 0)
            (combl x
                   (+ (* ms low)
                      (clamp (* ms high (+ 0.5 (modl 0.5 rate)))
                             0.0 halfsrf))
                  in out feedback)
            (if (= chan 1)
                (combr x
                       (+ (* ms low)
                          (clamp (* ms high (+ 0.5 (modr 0.5 rate)))
                                 0.0 halfsrf))
                       in out feedback)
                0.0))))))

;; chorus
(bind-func static chorus_c
  (lambda (phase:SAMPLE)
    (let ((delay:SAMPLE 700.)
          (range:SAMPLE 200.)
          (rate:SAMPLE 0.1)
          (comb1 (comb_c (convert (+ delay (* 2.5 range)))))
          (comb2 (comb_c (convert (+ delay (* 2.5 range)))))
          (comb3 (comb_c (convert (+ delay (* 2.5 range)))))
          (mrng1 range)
          (mrng2 (* (random) range))
          (mrng3 (* (random) range))
          (mrte1 rate)
          (mrte2 (* rate 1.372))
          (mrte3 (* rate 0.792))
          (dly1 delay)
          (dly2 (+ 200.0 (* (random) delay)))
          (dly3 (+ 200.0 (* (random) delay)))
          (mod1 (osc_c 0.0))
          (mod2 (osc_c (* 0.5 (random))))
          (mod3 (osc_c (* 1.0 (random)))))
      (lambda (x:SAMPLE in out fb)
        (+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) out fb) in out fb)
           (comb2 x (+ dly2 (mod2 mrng2 mrte2) out fb) in out fb)
           (comb3 x (+ dly3 (mod3 mrng3 mrte3) out fb) in out fb))))))

(bind-func static chorus_mc_c
  (lambda (channels:i64 phase)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (chorus_c phase)))
      (lambda (chan:i64 x in out fb)
        (let ((f (pref dlines chan)))
          (f x in out fb))))))

;; tap delay
(bind-func static tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:SAMPLE* (zalloc max_delay))
          (taps:i64* (zalloc num_of_taps))
          (delay max_delay)
          (time 0))
      (lambda (x:SAMPLE)
        (let ((y 0.0)
              (i 0)
              (n (modulo time delay))
              (gain (/ 1.0 (convert num_of_taps))))
          (pset! line n x)
          (dotimes (i num_of_taps)
            (set! y (+ y (* gain (pref line (% (+ (pref taps i) n) delay))))))
          (set! time (+ time 1))
          y)))))

(bind-func static tap_delay_mc_c
  (lambda (nchan:i64 max_delay num_of_taps)
    (let ((tap_delay_buf:[SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan)
        (pset! tap_delay_buf i (tap_delay_c max_delay num_of_taps)))
      (lambda (chan x)
        ((pref tap_delay_buf chan) x)))))



;; helpfer function for newverb_c
;; where rt60 is in milliseconds from 0.0 - 5000.0
;; and delay is the comb filter delay in samples
(bind-func comb_fb_from_rtsixty
  (let ((fexponent 0.0)
        (rt 0.0))
    (lambda (rt60 delay)
      (set! fexponent (* -3.0 delay (/ 1.0 SRs)))
      (set! rt (* rt60 .001))
      (pow 10.0 (/ fexponent rt)))))

;; where size is a roomsize from 0.0-1.0
;; predelay is in ms - 40ms is a good start but can go as high as 2 seconds
;; absorb is the amount of highfrq damping 0.0-1.0
;; mix is 0.0 dry to 1.0 wet
;; works as stereo or mono (mono input only)
(bind-func static reverb_c
  (lambda ()
    (let ((MILLIS (* .001 SRs))
          (dly1 (comb_c (* SR 4))) (dly1_delay (* 40.0 MILLIS)) (dly1_fb 0.0)
          (lpf1 (lpf_1p_c)) (lpf1_g 0.45)
          (apf1 (comb_apf_c (/ SR 4))) (apf1_delay (* 13.28 MILLIS)) (apf1_gain 0.7)
          (apf2 (comb_apf_c (/ SR 4))) (apf2_delay (* 28.13 MILLIS)) (apf2_gain -0.7)
          (comb1 (comb_c (/ SR 4))) (comb1_delay (* 31.71 MILLIS)) (comb1_fb 0.0)
          (comb2 (comb_c (/ SR 4))) (comb2_delay (* 37.11 MILLIS)) (comb2_fb 0.0)
          (comb3 (comb_c (/ SR 4))) (comb3_delay (* 40.23 MILLIS)) (comb3_fb 0.0)
          (comb4 (comb_c (/ SR 4))) (comb4_delay (* 44.14 MILLIS)) (comb4_fb 0.0)
          (comb5 (comb_c (/ SR 4))) (comb5_delay (* 30.47 MILLIS)) (comb5_fb 0.0)
          (comb6 (comb_c (/ SR 4))) (comb6_delay (* 33.98 MILLIS)) (comb6_fb 0.0)
          (comb7 (comb_c (/ SR 4))) (comb7_delay (* 41.41 MILLIS)) (comb7_fb 0.0)
          (comb8 (comb_c (/ SR 4))) (comb8_delay (* 42.58 MILLIS)) (comb8_fb 0.0)
          (lpf2 (lpf_1p_c)) (lpf2_g 0.5)
          (lpf3 (lpf_1p_c)) (lpf3_g 0.5)
          (apf3 (comb_apf_c (* SR 1))) (apf3_delay (* 9.38 MILLIS)) (apf3_gain -0.6)
          (apf4 (comb_apf_c (* SR 1))) (apf4_delay (* 11.0 MILLIS)) (apf4_gain 0.6)
          (oldsize:SAMPLE 0.0)
          (lout:SAMPLE 0.0)
          (rout:SAMPLE 0.0)
          (input 0.0)
          (out:SAMPLE 0.0))
      (lambda (chan:i64 x size predelay:SAMPLE absorb:SAMPLE mix)
        (if (= chan 0)
            (begin
              (if (<> size oldsize)
                  (begin (set! oldsize size)
                         (set! size (* size 5000.0))
                         (set! comb1_fb (comb_fb_from_rtsixty size comb1_delay))
                         (set! comb2_fb (comb_fb_from_rtsixty size comb2_delay))
                         (set! comb3_fb (comb_fb_from_rtsixty size comb3_delay))
                         (set! comb4_fb (comb_fb_from_rtsixty size comb4_delay))
                         (set! comb5_fb (comb_fb_from_rtsixty size comb5_delay))
                         (set! comb6_fb (comb_fb_from_rtsixty size comb6_delay))
                         (set! comb7_fb (comb_fb_from_rtsixty size comb7_delay))
                         (set! comb8_fb (comb_fb_from_rtsixty size comb8_delay))))
              (set! input x)
              ;; predelay
              (set! dly1_delay (* predelay MILLIS))
              (set! out (dly1 input dly1_delay 0.5 0.5 0.0)) ;dly1_fb))
              ;; input diffusion
              (set! out (lpf1 out absorb))
              (set! out (apf1 out apf1_delay apf1_gain))
              (set! out (apf2 out apf2_delay apf2_gain))))
        ;; left channel
        (if (= chan 0)
            (begin
              (set! lout (+ (* 0.15 (comb1 out comb1_delay 1.0 1.0 comb1_fb))
                            (* -0.15 (comb2 out comb2_delay 1.0 1.0 comb2_fb))
                            (* 0.15 (comb3 out comb3_delay 1.0 1.0 comb3_fb))
                            (* -0.15 (comb4 out comb4_delay 1.0 1.0 comb4_fb))))
              (set! lout (lpf2 lout lpf2_g))
              (set! lout (apf3 lout apf3_delay apf3_gain))))
        ;; right channel
        (if (= chan 1)
            (begin
              (set! rout (+ (* 0.15 (comb5 out comb5_delay 1.0 1.0 comb5_fb))
                            (* -0.15 (comb6 out comb6_delay 1.0 1.0 comb6_fb))
                            (* 0.15 (comb7 out comb7_delay 1.0 1.0  comb7_fb))
                            (* -0.15 (comb8 out comb8_delay 1.0 1.0 comb8_fb))))
              (set! rout (lpf3 rout lpf3_g))
              (set! rout (apf4 rout apf4_delay apf4_gain))))
        (if (= chan 0)
            (* (+ 1.0 mix) (+ (* input (- 1.0 mix)) (* lout mix)))
            (if (= chan 1)
                (* (+ 1.0 mix) (+ (* input (- 1.0 mix)) (* rout mix)))
                0.0))))))


;; this is a stereo cludge
(bind-func static reverb_st_c
  (lambda ()
    (let ((MILLIS (* .001 SRs))
          (dly1_l (comb_c (* SR 4))) (dly1_delay (* 40.0 MILLIS)) (dly1_fb 0.0)
          (dly1_r (comb_c (* SR 4)))
          (lpf1_l (lpf_1p_c)) (lpf1_g 0.45)
          (lpf1_r (lpf_1p_c))
          (apf1_l (comb_apf_c (/ SR 4))) (apf1_delay (* 13.28 MILLIS)) (apf1_gain 0.7)
          (apf1_r (comb_apf_c (/ SR 4)))
          (apf2_l (comb_apf_c (/ SR 4))) (apf2_delay (* 28.13 MILLIS)) (apf2_gain -0.7)
          (apf2_r (comb_apf_c (/ SR 4)))
          (comb1 (comb_c (/ SR 4))) (comb1_delay (* 31.71 MILLIS)) (comb1_fb 0.0)
          (comb2 (comb_c (/ SR 4))) (comb2_delay (* 37.11 MILLIS)) (comb2_fb 0.0)
          (comb3 (comb_c (/ SR 4))) (comb3_delay (* 40.23 MILLIS)) (comb3_fb 0.0)
          (comb4 (comb_c (/ SR 4))) (comb4_delay (* 44.14 MILLIS)) (comb4_fb 0.0)
          (comb5 (comb_c (/ SR 4))) (comb5_delay (* 30.47 MILLIS)) (comb5_fb 0.0)
          (comb6 (comb_c (/ SR 4))) (comb6_delay (* 33.98 MILLIS)) (comb6_fb 0.0)
          (comb7 (comb_c (/ SR 4))) (comb7_delay (* 41.41 MILLIS)) (comb7_fb 0.0)
          (comb8 (comb_c (/ SR 4))) (comb8_delay (* 42.58 MILLIS)) (comb8_fb 0.0)
          (lpf2 (lpf_1p_c)) (lpf2_g 0.5)
          (lpf3 (lpf_1p_c)) (lpf3_g 0.5)
          (apf3 (comb_apf_c (* SR 1))) (apf3_delay (* 9.38 MILLIS)) (apf3_gain -0.6)
          (apf4 (comb_apf_c (* SR 1))) (apf4_delay (* 11.0 MILLIS)) (apf4_gain 0.6)
          (oldsize:SAMPLE 0.0)
          (lout:SAMPLE 0.0)
          (rout:SAMPLE 0.0)
          (input 0.0)
          (out:SAMPLE 0.0))
      (lambda (chan:i64 x size predelay:SAMPLE absorb:SAMPLE mix)
        (if (= chan 0)
            (begin
              (if (<> size oldsize)
                  (begin (set! oldsize size)
                         (set! size (* size 5000.0))
                         (set! comb1_fb (comb_fb_from_rtsixty size comb1_delay))
                         (set! comb2_fb (comb_fb_from_rtsixty size comb2_delay))
                         (set! comb3_fb (comb_fb_from_rtsixty size comb3_delay))
                         (set! comb4_fb (comb_fb_from_rtsixty size comb4_delay))
                         (set! comb5_fb (comb_fb_from_rtsixty size comb5_delay))
                         (set! comb6_fb (comb_fb_from_rtsixty size comb6_delay))
                         (set! comb7_fb (comb_fb_from_rtsixty size comb7_delay))
                         (set! comb8_fb (comb_fb_from_rtsixty size comb8_delay))))
              (set! input x)
              ;; predelay
              (set! dly1_delay (* predelay MILLIS))
              (set! out (dly1_l input dly1_delay 0.5 0.5 0.0)) ;dly1_fb))
              ;; input diffusion
              (set! out (lpf1_l out absorb))
              (set! out (apf1_l out apf1_delay apf1_gain))
              (set! out (apf2_l out apf2_delay apf2_gain))))
        (if (= chan 1)
            (begin
              (set! input x)
              (set! out (dly1_r input dly1_delay 0.5 0.5 0.0)) ;dly1_fb))
              ;; input diffusion
              (set! out (lpf1_r out absorb))
              (set! out (apf1_r out apf1_delay apf1_gain))
              (set! out (apf2_r out apf2_delay apf2_gain))))
        ;; left channel
        (if (= chan 0)
            (begin
              (set! lout (+ (* 0.15 (comb1 out comb1_delay 1.0 1.0 comb1_fb))
                            (* -0.15 (comb2 out comb2_delay 1.0 1.0 comb2_fb))
                            (* 0.15 (comb3 out comb3_delay 1.0 1.0 comb3_fb))
                            (* -0.15 (comb4 out comb4_delay 1.0 1.0 comb4_fb))))
              (set! lout (lpf2 lout lpf2_g))
              (set! lout (apf3 lout apf3_delay apf3_gain))))
        ;; right channel
        (if (= chan 1)
            (begin
              (set! rout (+ (* 0.15 (comb5 out comb5_delay 1.0 1.0 comb5_fb))
                            (* -0.15 (comb6 out comb6_delay 1.0 1.0 comb6_fb))
                            (* 0.15 (comb7 out comb7_delay 1.0 1.0  comb7_fb))
                            (* -0.15 (comb8 out comb8_delay 1.0 1.0 comb8_fb))))
              (set! rout (lpf3 rout lpf3_g))
              (set! rout (apf4 rout apf4_delay apf4_gain))))
        (if (= chan 0)
            (* (+ 1.0 mix) (+ (* input (- 1.0 mix)) (* lout mix)))
            (if (= chan 1)
                (* (+ 1.0 mix) (+ (* input (- 1.0 mix)) (* rout mix)))
                0.0))))))


;; a dodgy bitcrusher
(bind-func static crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits:SAMPLE)
        (* amp (/ (floor (* in (pow 2. bits)))
                  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func static hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in:SAMPLE h:SAMPLE)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))

(bind-func static hold_mc_c
  (lambda (channels:i64)
    (let ((holds:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! holds i (hold3_c)))
      (lambda (chan:i64 x h)
        (let ((f (pref holds chan)))
          (f x h))))))

;; a dodgy bitcrusher
(bind-func static crush
  (lambda (in:SAMPLE bits:SAMPLE)
    (/ (floor (* in (pow 2. bits)))
       (pow 2. bits))))

;; a dodgy amp distortion
(bind-func static distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in:SAMPLE)
        (clamp lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(bind-func static panner_c
  (lambda (channels)
    (let ((v:SAMPLE 0.0)
          (out:SAMPLE 0.0))
      (lambda (chan x:SAMPLE pan)
        (if (= chan 0) (set! out x))
        (set! v (fabs (- (* (- channels 1.0) pan) (convert chan))))
        (if (> v 1.0) 0.0
            (* (- 1.0 v) out))))))

;; simple stereo weights
(bind-func static mix2
  (lambda (chan:i64 x:SAMPLE left right)
    (cond ((= chan 0) (* x left))
          ((= chan 1) (* x right))
          (else 0.0))))

;; simple stereo weights (from mono)
(bind-func static mix2_c
  (lambda ()
    (let ((out 0.0))
      (lambda (chan:i64 x:SAMPLE left right)
        (cond ((= chan 0) (set! out x) (* out left))
              ((= chan 1) (* out right))
              (else 0.0))))))

;; simple quad weights
(bind-func static mix4
  (lambda (chan x:SAMPLE c1 c2 c3 c4)
    (cond ((= chan 0) (* x c1))
          ((= chan 1) (* x c2))
          ((= chan 2) (* x c3))
          ((= chan 3) (* x c4))
          (else 0.0))))

;; simple quad weights (from mono)
(bind-func static mix4_c
  (lambda ()
    (let ((out 0.0))
      (lambda (chan:i64 x:SAMPLE c1 c2 c3 c4)
        (cond ((= chan 0) (set! out x) (* out c1))
              ((= chan 1) (* out c2))
              ((= chan 2) (* out c3))
              ((= chan 3) (* out c4))
              (else 0.0))))))

;; simple oct weights
(bind-func static mix8
  (lambda (chan x:SAMPLE c1 c2 c3 c4 c5 c6 c7 c8)
    (cond ((= chan 0) (* x c1))
          ((= chan 1) (* x c2))
          ((= chan 2) (* x c3))
          ((= chan 3) (* x c4))
          ((= chan 4) (* x c5))
          ((= chan 5) (* x c6))
          ((= chan 6) (* x c7))
          ((= chan 7) (* x c8))
          (else 0.0))))


;; an n channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func static mixer_c
  (lambda (channels:i64)
    (lambda (cdat:SAMPLE* chan:i64 in:SAMPLE)
      (if (< chan channels)
          (* in (pref cdat chan))
          0.0))))

(bind-func static hermite_interp
  (lambda (fractional y1:SAMPLE x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
          (v (- x0 x1))
          (w (+ c v))
          (a (+ w v (* (- x2 x0) 0.5)))
          (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))




;; a rough and ready granulator
;; expects to work on 'n' channels
;; see examples/external/granular.xtm
;; or examples/core/granular.xtm
(bind-func static granulator_c
  (lambda (channels)
    (let ((idx 0)
          (iot 2000)
          (iotn 100000000) ;; we want a grain right at the start
          (dlo 5000.0)
          (dhi 5000.0)
          (rlo 1.0)
          (rhi 1.0)
          (plo 0.4)
          (phi 0.6)
          (alo 0.2)
          (ahi 0.2)
          (wet 1.0)
          (PI2:double (* 2.0 3.141592))
          (gidx 0)
          (offset 0)
          (out:SAMPLE 0.0) (i 0)
          (cachesize:i64 (* 88200 2 channels))
          (cnt cachesize)
          (audio_cache:SAMPLE* (alloc cachesize))
          (lengths:|200,double|* (alloc))
          (durations:|200,double|* (alloc))
          (phases:|200,double|* (alloc))
          (startidx:|200,i64|* (alloc))
          (amps:|200,float|* (alloc))
          (rates:|200,double|* (alloc))
          (panning:|200,float|* (alloc))
          (active:|200,i1|* (alloc)))
      (dotimes (i 200) (aset! active i 0))
      (lambda (chan time:i64 in)
        (set! iotn (+ iotn 1))
        (pset! audio_cache (% cnt cachesize) in)
        (if (and (>= iotn iot)
                 (= chan 0))
            (begin
              (set! iotn 0)
              (aset! active gidx #t)
              (aset! lengths gidx (+ dlo (* (- dhi dlo) (random))))
              (aset! amps gidx (+ alo (* (- ahi alo) (random))))
              (aset! panning gidx (+ plo (* (- phi plo) (random))))
              (aset! durations gidx (aref lengths gidx))
              (aset! rates gidx (+ rlo (* (- rhi rlo)  (random))))
              (set! offset
                    (if (> (aref rates gidx) 1.0)
                        (+ 128
                           (* channels (dtoi64 (floor (- (* (aref rates gidx)
                                                            (aref lengths gidx))
                                                         (aref lengths gidx))))))
                        128))
              (aset! startidx gidx (% (- cnt offset) cachesize))
              (aset! phases gidx 0.0)
              (set! gidx (% (+ gidx 1) 200))))
        (set! cnt (+ cnt 1))
        (set! out 0.0)
        (dotimes (i 200)
          (if (= #t (aref active i))
              (begin
                (set! idx (+ (aref startidx i)
                             chan
                             (* channels (dtoi64 (floor (aref phases i))))))
                (set! out (+ out
                             (* (aref amps i)
                                (dtof (* 0.5 (- 1.0 (cos (* PI2 (/ (aref durations i) (aref lengths i)))))))
                                (panner chan (aref panning i))
                                (pref audio_cache (% idx cachesize)))))
                (if (= chan 0)
                    (begin
                      (aset! phases i (+ (aref phases i) (aref rates i)))
                      (aset! durations i (- (aref durations i) (aref rates i)))))
                (if (< (aref durations i) 8.0)
                    (begin
                      (aset! active i #f)
                      void)
                    void))))
        (+ (* (- 1.0 wet) in)
           (* wet out))))))


;; a rough and ready granulator
;; expects to work on 'n' channels
;; see examples/external/granular.xtm
;; or examples/core/granular.xtm
;; more expensive than linear
(bind-func static granulator_hermite_c
  (lambda (channels)
    (let ((idx 0)
          (iot 2000)
          (iotn 100000000) ;; we want a grain right at the start
          (dlo 5000.0)
          (dhi 5000.0)
          (rlo 1.0)
          (rhi 1.0)
          (plo 0.5)
          (phi 0.5)
          (alo 0.2)
          (ahi 0.2)
          (wet 1.0)
          (PI2:double (* 2.0 3.141592))
          (gidx 0)
          (offset 0)
          (y1 0.0) (x0 0.0) (x1 0.0) (x2 0.0)
          (out:SAMPLE 0.0) (i 0)
          (cachesize:i64 (* 88200 2 channels))
          (cnt cachesize)
          (audio_cache:SAMPLE* (alloc cachesize))
          (lengths:|200,double|* (alloc))
          (durations:|200,double|* (alloc))
          (phases:|200,double|* (alloc))
          (startidx:|200,i64|* (alloc))
          (amps:|200,float|* (alloc))
          (rates:|200,double|* (alloc))
          (panning:|200,float|* (alloc))
          (active:|200,i1|* (alloc)))
      (dotimes (i 200) (aset! active i 0))
      (lambda (chan time:i64 in)
        (set! iotn (+ iotn 1))
        (pset! audio_cache (% cnt cachesize) in)
        (if (and (>= iotn iot)
                 (= chan 0))
            (begin
              (set! iotn 0)
              (aset! active gidx #t)
              (aset! lengths gidx (+ dlo (* (- dhi dlo) (random))))
              (aset! amps gidx (+ alo (* (- ahi alo) (random))))
              (aset! panning gidx (+ plo (* (- phi plo) (random))))
              (aset! durations gidx (aref lengths gidx))
              (aset! rates gidx (+ rlo (* (- rhi rlo)  (random))))
              (set! offset
                    (if (> (aref rates gidx) 1.0)
                        (+ 128
                           (* channels (dtoi64 (floor (- (* (aref rates gidx)
                                                            (aref lengths gidx))
                                                         (aref lengths gidx))))))
                        128))
              (aset! startidx gidx (% (- cnt offset) cachesize))
              (aset! phases gidx 0.0)
              (set! gidx (% (+ gidx 1) 200))))
        (set! cnt (+ cnt 1))
        (set! out 0.0)
        (dotimes (i 200)
          (if (= #t (aref active i))
              (begin
                (set! idx (+ (aref startidx i)
                             chan
                             (* channels (dtoi64 (floor (aref phases i))))))
                (set! y1 (pref audio_cache (% (- idx channels) cachesize)))
                (set! x0 (pref audio_cache (% idx cachesize)))
                (set! x1 (pref audio_cache (% (+ idx channels) cachesize)))
                (set! x2 (pref audio_cache (% (+ idx (* 2 channels)) cachesize)))
                (set! out (+ out
                             (* (aref amps i)
                                (dtof (* 0.5 (- 1.0 (cos (* PI2 (/ (aref durations i) (aref lengths i)))))))
                                (panner chan (aref panning i))
                                (hermite_interp (dtof (modulo (aref phases i) 1.0)) y1 x0 x1 x2))))
                (if (= chan 0)
                    (begin
                      (aset! phases i (+ (aref phases i) (aref rates i)))
                      (aset! durations i (- (aref durations i) (aref rates i)))))
                (if (< (aref durations i) 8.0)
                    (begin
                      (aset! active i #f)
                      void)
                    void))))
        (+ (* (- 1.0 wet) in)
           (* wet out))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func static lpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (- 1.0 coso) 2.0))
              (set! b1 (- 1.0 coso))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func static lpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (lpfbq_c)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))


;; biquad high-pass filter
(bind-func static hpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (+ 1.0 coso) 2.0))
              (set! b1 (* -1.0 (+ 1.0 coso)))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func static hpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (hpfbq_c)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))


;; biquad band-pass filter
(bind-func static bpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq:SAMPLE 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* 1.0 STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 alpha)
              (set! b1 0.0)
              (set! b2 (* -1.0 b0))
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))


(bind-func static bpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (bpfbq_c)))
      (lambda (chan:i64 x freq bandwidth)
        (let ((f (pref lines chan)))
          (f x freq bandwidth))))))


;; biquad notch filter
(bind-func static notchbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 1.0)
              (set! b1 (* -2.0 coso))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 b1)
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func static notchbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (notchbq_c)))
      (lambda (chan:i64 x freq bandwidth)
        (let ((f (pref lines chan)))
          (f x freq bandwidth))))))

;; Hilbert transform filter

(bind-func static hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:SAMPLE* (alloc n))
          (x_n:SAMPLE* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (convert i) SPI))
                  (pow (sin (/ (* (convert i) SPI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (% (+ i x_ptr (- n 1)) n))))))
          (% (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func static hilb_env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x:SAMPLE)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))


(bind-func static env_follow_c
  (lambda (ms:SAMPLE)
    (let ((y1 0.0)
          (coeff (/ 1000. (* ms (convert SAMPLE_RATE)))))
      (lambda (x:SAMPLE)
        (set! y1 (+ x (* coeff (- y1 x))))
        y1))))


(bind-func static atkrel_env_follow_c
  (lambda (atk:SAMPLE rel:SAMPLE)
    (let ((y1 0.0)
          (atkcoeff (/ 1000. (* atk (convert SAMPLE_RATE))))
          (relcoeff (/ 1000. (* rel (convert SAMPLE_RATE)))))
      (lambda (x)
        (set! y1 (+ x (* (if (> x y1) atkcoeff relcoeff) (- y1 x))))
        y1))))


;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func static vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4:SAMPLE 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
          y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func static vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func static vcf_c
  (lambda (type)
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ SPI 2.0)))) 1.0))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
          ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
          (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func static vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


(bind-func static vcf_mc_c
  (lambda (type:i64 channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (vcf_c type)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func static overdrive_c
  "Drive range:[1.0,3.0] - user input is 0.0-1.0"
  (lambda ()
    (lambda (x:SAMPLE drive)
      (set! drive (+ 1.0 (* 2.0 (clamp drive 0.0 1.0))))
      (let ((absx (fabs x))
            (drive_minus_1 (- drive 1.0)))
        (/ (* x (+ absx drive))
           (+ (* x x)
              (* drive_minus_1 absx)
              1.0))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

;; (bind-func saturation_c
;;   "level:[0.0,1.0] character:[0.0,1.0]"
;;   (lambda ()
;;     (let ((itm1 0.0)
;;           (otm1 0.0))
;;       (lambda (x:SAMPLE level:SAMPLE character:SAMPLE)
;;         (set! level (clamp level .001 0.999))
;;         (let ((q (- level 0.999))
;;               (dist (+ (* character 40.0) 0.1))
;;               (fx (if (= x q)
;;                       (/ (/ 1.0 (+ dist q))
;;                          (- 1.0 (exp (* dist q))))
;;                       (/ (/ (- x q)
;;                             (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
;;                          (- 1.0 (exp (* dist q)))))))
;;           (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
;;           (set! itm1 fx)
;;           otm1)))))

(bind-func static saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x:SAMPLE level:SAMPLE character:SAMPLE)
        (set! level (clamp level .1 0.9))
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (+ (/ (- x q)
                            (- 1.0 (exp (* -1.0 dist (- x q)))))
                         (/ q (- 1.0 (exp (* dist q))))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func static ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x:SAMPLE freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

(bind-func static hann_c
  "window of width samples - repeating every repeat samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64)
        (set! cnt (+ cnt 1))
        (* 0.5
           (- 1.0
              (cos (/ (* STWOPI (convert (% cnt width)))
                      (- (convert width) 1.0)))))))))

;; hann
(bind-func static hann_mc_c
  (lambda ()
    (let ((h (hann_c))
          (mem 0.0))
      (lambda (chan:i64 width:i64)
        (if (= chan 0) (set! mem (h width)))
        mem))))


(bind-func static hann_t_c
  "window of width samples - repeating every repeat samples"
  (lambda (offset)
    (lambda (time:i64 width:i64)
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* STWOPI (convert (% (- time offset) width)))
                    (- (convert width) 1.0))))))))

;; hann with time
(bind-func static hann_t_mc_c
  (lambda (offset)
    (let ((h (hann_t_c offset))
          (mem 0.0))
      (lambda (chan:i64 time:i64 width:i64)
        (if (= chan 0) (set! mem (h time width)))
        mem))))


(bind-func static hann_e_c
  "window of 'width' samples, repeating every 'repeat' samples
   with an offset of 'offset' samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64 offset:i64 repeat:i64)
        (if (> cnt repeat) (set! cnt -1))
        (set! cnt (+ cnt 1))
        (if (and (or (> cnt offset) (= offset 0))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* STWOPI (convert (% (- cnt offset) width)))
                          (convert (- width 1))))))
            0.0)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (incr)
          (set! time (+ time incr))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan incr)
          (if (= chan 0)
              (set! time (+ time incr)))
          (+ (* m time) c))))))

(bind-func static line_c
  (lambda (x1:SAMPLE y1:SAMPLE x2:SAMPLE y2)
    (let* ((zero:SAMPLE 0.0)
           (m (if (= (- x2 x1) 0.0)
                  zero
                  (/ (- y2 y1) (- x2 x1))))
           (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func static envelope_segments
  (lambda (points:SAMPLE* num_of_points:i64)
    (let ((lines:[SAMPLE,SAMPLE]** (zalloc num_of_points))
          (k 0))
      (dotimes (k num_of_points)
        (let* ((idx (* k 2))
               (x1 (pref points (+ idx 0)))
               (y1 (pref points (+ idx 1)))
               (x2 (pref points (+ idx 2)))
               (y2 (pref points (+ idx 3))))
          (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func static envelope_c
  (lambda (points:SAMPLE* num_of_points)
    (let ((klines:[SAMPLE,SAMPLE]** (envelope_segments points num_of_points))
          (line_length num_of_points))
      (lambda (time)
        (let ((res -1.0)
              (k:i64 0))
          (dotimes (k num_of_points)
            (let ((line (pref klines k))
                  (time_point (pref points (* k 2))))
              (if (or (= time time_point)
                      (< time_point time))
                  (set! res (line time)))))
          res)))))


;; pan around 'n' channels
;; with a bleed to surrounding channels.
;;
;; the 1st speaker (channel) is pan 0.0
;; the 2nd speaker           is pan 1.0
;; etc..
;; the last speaker          is pan (- n 1.0)
;; it is legal to pan past (- n 1.0) to n
;; this makes it possible to pan between the
;; last speaker and the first speaker
;;
;; for example: assuming 4 channels
;; (pan chan in 1.0 (% pos 4.0))
;; would pan around a circle of 4 speakers
;;
;; the amount of 'bleed' is the amount of bleed
;; between speakers.  A bleed of 4.0 with 4.0 channels
;; would mean all speakers would always be sounding.
;; A bleed of less than 0.5 would ensure that only one
;; speaker at a time will ever be sounding.
;;
(bind-func static pan_c
  (lambda (chans)
    (let ((fchans (i64tof (+ chans 0)))
          (fchan 0.0)
          (chk 0)
          (p1 0.0) (p2 0.0) (p3 0.0)
          (b1 0.0) (b2 0.0))
      (lambda (chan in bleed pan)
        (set! fchan (i64tof chan))
        (set! p1 pan)
        (set! p2 (- pan fchans))
        (set! p3 (+ pan fchans))
        (set! b1 (- fchan bleed))
        (set! b2 (+ fchan bleed))
        (cond ((and (> p1 b1) (< p1 b2)) (* in (/ 1.0 bleed) (- bleed (fabs (- fchan p1)))))
              ((and (> p2 b1) (< p2 b2)) (* in (/ 1.0 bleed) (- bleed (fabs (- fchan p2)))))
              ((and (> p3 b1) (< p3 b2)) (* in (/ 1.0 bleed) (- bleed (fabs (- fchan p3)))))
              (else 0.0))))))



;; explin is a function that can smoothly interpolate
;; between logarithmic and exponential curves
;;
;; t is a value between [0.0 .. 1.0] for time.
;; x is a value between [-1.0 ... 1.0] that
;; moves between logathmic (negative) and exponential (positive)
;; curves with a centre value of 0.0 being exactly linear
(bind-func explin
  (let ((time 0.0:f)
        (Ef (dtof E))
        (scale (/ 1.0 (- Ef 1.0))))
    (lambda (t:float x:float)
      (if (< x 0.0)
          (set! x (+ 1.0 x))
          (if (< (fabs x) 0.0001)
              (set! x 1.0)
              (set! x (/ 1.0 (- 1.0 x)))))
      (set! time (+ 1.0 (* t (- Ef 1.0))))
      (* (+ -1.0 (exp (pow (log time) x))) scale))))



;; g is gate
;; a is attack in milliseconds
;; d is decay in milliseconds
;; ela is the explin for attach
;; eld is the explin for decay
;;
;; cycle is a boolean closure variable that makes the ad self oscillate
;;
;; explin is a value between [-1.0 ... 1.0] that
;; moves between logathmic (negatives) and exponential (positive)
;; curves with a centre value of 0.0 being exactly linear
(bind-func static ad_c
  (lambda ()
    (let ((t:SAMPLE 0.0)
          (out:SAMPLE 0.0)
          (time:SAMPLE 0.0)
          (aa 0.0) (dd 0.0)
          (cycle:i1 #f)
          (inc1 0.0) (inc2 0.0) (inc3 0.0))
      (lambda (chan:i64 g a d ela eld)
        (if (<> chan 0)
            out
            (begin
              (if (< g 0.00001:f)
                  (begin (set! t 0.0)
                         (set! aa (+ 1.0 (* a .001 SRs)))
                         (set! dd (+ 1.0 (* d .001 SRs)))
                         (set! inc1 (/ 1.0 aa))
                         (set! inc2 (/ 1.0 dd))
                         void)
                  (begin (inc t 1.0)
                         void))
              (cond ((> t (+ aa dd))
                     (if (and cycle (> g 0.0)) ; (< out 0.0001))
                         (begin (set! t 0.0)
                                (set! aa (+ 1.0 (* a .001 SRs)))
                                (set! dd (+ 1.0 (* d .001 SRs)))
                                (set! inc1 (/ 1.0 aa))
                                (set! inc2 (/ 1.0 dd))
                                void))
                     (set! time 0.0)
                     (set! out 0.0)) ;(clamp (- out .001) 0.0 1.0)))
                    ((> t aa)
                     (dec time inc2)
                     (set! out (explin (clamp time 0.0 1.0) eld))) ;; decay
                    ((> t 0.0)
                     (inc time inc1)
                     (set! out (explin time ela))) ;; attack
                    (else (set! out 0.0)))
              out))))))


;; chan, gate, attack, decay, sustain, release
;; (bind-func adsr_c
;;   (lambda ()
;;     (let ((t:double 0.0)
;;           (tt:i64 0)
;;           (out:double 0.0)
;;           (ms (* .001 SRd))
;;           (a 0.0) (d 0.0) (r 0.0) (s 0.0)
;;           (t1 0.0) (t2 0.0) (t3 0.0) (t4 0.0)
;;           (inc1 0.0) (inc2 0.0) (inc3 0.0))
;;       (lambda (chan:i64 g:float aa:float dd:float ss:float rr:float)
;;         (if (<> chan 0)
;;             (dtof out)
;;             (begin
;;               (set! a (+ 1.0 (* (ftod aa) ms)))
;;               (set! d (+ 1.0 (* (ftod dd) ms)))
;;               (set! r (+ 1.0 (* (ftod rr) ms)))
;;               (set! s (ftod ss))
;;               (if (< g 0.00001:f) (set! t 0.0) (set! t (+ t 1.0)))
;;               ;; (set! t1 a)
;;               ;; (set! t2 (+ a d))
;;               (cond ((< t 0.001)
;;                      (set! inc3 (if (or (< s .01) (> out (+ s 0.001))) (/ 1.0 r) (/ s r)))
;;                      (set! out (- out inc3))) ;; release
;;                     ((> t (+ a d)) out) ;(set! out s)) ;; sustain
;;                     ((> t a)
;;                      (set! inc2 (/ (- 1.0 s) d))
;;                      (set! out (- out inc2))) ;; decay
;;                     ((> t 0.0)
;;                      (set! inc1 (/ 1.0 a))
;;                      (set! out (+ out inc1))) ;; attack
;;                     (else (set! out (- out .01)))) ;; fast decay to 0.0 (shouldn't get here!)
;;               (set! out (clamp out 0.0 1.0))
;;               (dtof out)))))))



;;
;;
;;
(bind-func static adsr_c
  (lambda ()
    (let ((calcCoef (lambda (rate:float targetRatio:float)
                      (exp (/ (* -1.0 (log (/ (+ 1.0 targetRatio)
                                              targetRatio)))
                              rate))))
          (retrigger #f)
          (targetRatioA 0.3)
          (targetRatioDR 0.0001)
          (env_idle 0) (env_attack 1) (env_decay 2) (env_sustain 3) (env_release 4)
          (state env_idle)
          (attackRate 0.0)
          (attackCoef 0.0)
          (attackBase 0.0)
          (decayRate 0.0)
          (decayCoef 0.0)
          (decayBase 0.0)
          (sustainLevel 0.0)
          (releaseRate 0.0)
          (releaseCoef 0.0)
          (releaseBase 0.0)
          (old_g 0.0)
          (old_a -1.0)
          (old_d -1.0)
          (old_s -1.0)
          (old_r -1.0)
          (out 0.0))
      (lambda (chan:i64 g:SAMPLE a d s r)
        (if (= chan 0)
            (begin
              (if retrigger
                  (begin (set! retrigger #f)
                         ;; (set! out 0.0)
                         (set! state env_attack)))
              (if (<> a old_a)
                  (begin
                    (set! old_a a)
                    (set! attackRate (* a SRf 0.001))
                    (set! attackCoef (calcCoef attackRate targetRatioA))
                    (set! attackBase (* (+ 1.0 targetRatioA) (- 1.0 attackCoef)))))
              (if (<> d old_d)
                  (begin
                    (set! old_d d)
                    (set! decayRate (* d SRf 0.001))
                    (set! decayCoef (calcCoef decayRate targetRatioDR))
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> s old_s)
                  (begin
                    (set! old_s s)
                    (set! sustainLevel s)
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> r old_r)
                  (begin
                    (set! old_r r)
                    (set! releaseRate (* r SRf 0.001))
                    (set! releaseCoef (calcCoef releaseRate targetRatioDR))
                    (set! releaseBase (* -1.0 targetRatioDR (- 1.0 releaseCoef)))))
              (if (<> g old_g)
                  (if (> g 0.1)
                      (cond ((> a 0.00001) (set! state env_attack))
                            ((> d 0.00001) (set! out 1.0) (set! state env_decay))
                            (else (set! out sustainLevel) (set! state env_sustain)))
                      (set! state env_release)))
              (set! old_g g)
              (cond ((= state env_idle)
                     out)
                    ((= state env_attack)
                     (set! out (+ attackBase (* out attackCoef)))
                     (if (>= out 1.0)
                         (begin (set! out 1.0)
                                (set! state env_decay)))
                     out)
                    ((= state env_decay)
                     (set! out (+ decayBase (* out decayCoef)))
                     (if (<= out sustainLevel)
                         (begin (set! out sustainLevel)
                                (set! state env_sustain)))
                     out)
                    ((= state env_sustain) out)
                    ((= state env_release)
                     (set! out (+ releaseBase (* out releaseCoef)))
                     (if (<= out 0.0)
                         (begin (set! out 0.0)
                                (set! state env_idle)))
                     out)))
            out)))))


;; adsr with initial delay in ms
(bind-func static dadsr_c
  (lambda ()
    (let ((calcCoef (lambda (rate:float targetRatio:float)
                      (exp (/ (* -1.0 (log (/ (+ 1.0 targetRatio)
                                              targetRatio)))
                              rate))))
          (retrigger #f)
          (targetRatioA 0.3)
          (targetRatioDR 0.0001)
          (env_idle 0) (env_attack 1) (env_decay 2) (env_sustain 3) (env_release 4) (env_predelay 5)
          (state env_idle)
          (attackRate 0.0)
          (attackCoef 0.0)
          (attackBase 0.0)
          (decayRate 0.0)
          (decayCoef 0.0)
          (decayBase 0.0)
          (sustainLevel 0.0)
          (releaseRate 0.0)
          (releaseCoef 0.0)
          (releaseBase 0.0)
          (delay 0:i64)
          (old_g 0.0)
          (old_a -1.0)
          (old_d -1.0)
          (old_s -1.0)
          (old_r -1.0)
          (out 0.0))
      (lambda (chan:i64 g:SAMPLE del a d s r)
        (if (= chan 0)
            (begin
              (if retrigger
                  (begin (set! retrigger #f)
                         ;; (set! out 0.0)
                         (set! state env_attack)))
              (if (<> a old_a)
                  (begin
                    (set! old_a a)
                    (set! attackRate (* a SRf 0.001))
                    (set! attackCoef (calcCoef attackRate targetRatioA))
                    (set! attackBase (* (+ 1.0 targetRatioA) (- 1.0 attackCoef)))))
              (if (<> d old_d)
                  (begin
                    (set! old_d d)
                    (set! decayRate (* d SRf 0.001))
                    (set! decayCoef (calcCoef decayRate targetRatioDR))
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> s old_s)
                  (begin
                    (set! old_s s)
                    (set! sustainLevel s)
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> r old_r)
                  (begin
                    (set! old_r r)
                    (set! releaseRate (* r SRf 0.001))
                    (set! releaseCoef (calcCoef releaseRate targetRatioDR))
                    (set! releaseBase (* -1.0 targetRatioDR (- 1.0 releaseCoef)))))
              (if (<> g old_g)
                  (if (> g 0.1)
                      (cond ((> del 0.00001)
                               (set! state env_predelay)
                               (set! delay (ftoi64 (* del SRf 0.001))))
                            ((> a 0.00001) (set! state env_attack))
                            ((> d 0.00001) (set! out 1.0) (set! state env_decay))
                            (else (set! out sustainLevel) (set! state env_sustain)))
                      (set! state env_release)))
              (set! old_g g)
              (cond ((= state env_idle)
                      out)
                    ((= state env_predelay)
                      (set! delay (- delay 1))
                      (if (<= delay 0)
                          (cond ((> a 0.00001) (set! state env_attack))
                                ((> d 0.00001) (set! out 1.0) (set! state env_decay))
                                (else (set! out sustainLevel) (set! state env_sustain))))
                      out)
                    ((= state env_attack)
                     (set! out (+ attackBase (* out attackCoef)))
                     (if (>= out 1.0)
                         (begin (set! out 1.0)
                                (set! state env_decay)))
                     out)
                    ((= state env_decay)
                     (set! out (+ decayBase (* out decayCoef)))
                     (if (<= out sustainLevel)
                         (begin (set! out sustainLevel)
                                (set! state env_sustain)))
                     out)
                    ((= state env_sustain) out)
                    ((= state env_release)
                     (set! out (+ releaseBase (* out releaseCoef)))
                     (if (<= out 0.0)
                         (begin (set! out 0.0)
                                (set! state env_idle)))
                     out)))
            out)))))




(bind-func static retrigger_adsr
  (lambda (adsr:[SAMPLE,i64,SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]*)
    (cset! adsr retrigger #t i1) ;; 1 == env_attack
    void))

(bind-func static retrigger_dadsr
  (lambda (dadsr:[SAMPLE,i64,SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]*)
    (cset! dadsr retrigger #t i1) ;; 1 == env_attack
    void))


(bind-func static adsr_ratio_c
  (lambda ()
    (let ((calcCoef (lambda (rate:float targetRatio:float)
                      (exp (/ (* -1.0 (log (/ (+ 1.0 targetRatio)
                                              targetRatio)))
                              rate))))
          (targetRatioA 0.3)
          (targetRatioDR 0.0001)
          (env_idle 0) (env_attack 1) (env_decay 2) (env_sustain 3) (env_release 4)
          (state env_idle)
          (attackRate 0.0)
          (attackCoef 0.0)
          (attackBase 0.0)
          (decayRate 0.0)
          (decayCoef 0.0)
          (decayBase 0.0)
          (sustainLevel 0.0)
          (releaseRate 0.0)
          (releaseCoef 0.0)
          (releaseBase 0.0)
          (old_g 0.0)
          (old_a -1.0)
          (old_d -1.0)
          (old_s -1.0)
          (old_r -1.0)
          (old_a_ratio targetRatioA)
          (old_dr_ratio targetRatioDR)
          (out 0.0))
      (lambda (chan:i64 g:float a d s r a_ratio dr_ratio)
        (if (= chan 0)
            (begin
              (if (<> a old_a)
                  (begin
                    (set! old_a a)
                    (set! attackRate (* a SRf 0.001))
                    (set! attackCoef (calcCoef attackRate targetRatioA))
                    (set! attackBase (* (+ 1.0 targetRatioA) (- 1.0 attackCoef)))))
              (if (<> d old_d)
                  (begin
                    (set! old_d d)
                    (set! decayRate (* d SRf 0.001))
                    (set! decayCoef (calcCoef decayRate targetRatioDR))
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> s old_s)
                  (begin
                    (set! old_s s)
                    (set! sustainLevel s)
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))))
              (if (<> r old_r)
                  (begin
                    (set! old_r r)
                    (set! releaseRate (* r SRf 0.001))
                    (set! releaseCoef (calcCoef releaseRate targetRatioDR))
                    (set! releaseBase (* -1.0 targetRatioDR (- 1.0 releaseCoef)))))
              (if (<> a_ratio old_a_ratio)
                  (begin
                    (set! old_a_ratio a_ratio)
                    (if (< a_ratio 0.000000001) (set! a_ratio 0.000000001)) ;; -180db
                    (set! targetRatioA a_ratio)
                    (set! attackCoef (calcCoef attackRate targetRatioA))
                    (set! attackBase (* (+ 1.0 targetRatioA) (- 1.0 attackCoef)))))
              (if (<> dr_ratio old_dr_ratio)
                  (begin
                    (set! old_dr_ratio dr_ratio)
                    (if (< a_ratio 0.000000001) (set! a_ratio 0.000000001)) ;; -180db
                    (set! targetRatioDR dr_ratio)
                    (set! decayCoef (calcCoef decayRate targetRatioDR))
                    (set! releaseCoef (calcCoef releaseRate targetRatioDR))
                    (set! decayBase (* (- sustainLevel targetRatioDR) (- 1.0 decayCoef)))
                    (set! releaseBase (* -1.0 targetRatioDR (- 1.0 releaseCoef)))))
              (if (<> g old_g)
                  (if (> g 0.1)
                      (set! state env_attack)
                      (set! state env_release)))
              (set! old_g g)
              (cond ((= state env_idle)
                     out)
                    ((= state env_attack)
                     (set! out (+ attackBase (* out attackCoef)))
                     (if (>= out 1.0)
                         (begin (set! out 1.0)
                                (set! state env_decay)))
                     out)
                    ((= state env_decay)
                     (set! out (+ decayBase (* out decayCoef)))
                     (if (<= out sustainLevel)
                         (begin (set! out sustainLevel)
                                (set! state env_sustain)))
                     out)
                    ((= state env_sustain) out)
                    ((= state env_release)
                     (set! out (+ releaseBase (* out releaseCoef)))
                     (if (<= out 0.0)
                         (begin (set! out 0.0)
                                (set! state env_idle)))
                     out)))
            out)))))




;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func static adsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (if (or (= atk_dur 0) (= dky_dur 0))
        (begin (set! dky_dur 0)
               (set! peak_amp sus_amp)))
    (let ((val:SAMPLE (if (> (+ atk_dur dky_dur) 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur dky_dur start_time))
          (t3 (+ atk_dur dky_dur sus_dur start_time))
          (t4 (+ atk_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t4) (set! val 0.0))
                  ((> time t3) (set! val (+ val inc3)))
                  ((> time t2) val) ;; sustain (don't do anything with val)
                  ((> time t1) (set! val (+ val inc2)))
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


;; has both hold and sustain
;; an accumulative ahdsr (random access not allowed! time must be linear).
(bind-func static ahdsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 hold_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (let ((val:SAMPLE (if (> atk_dur 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur hold_dur start_time))
          (t3 (+ atk_dur hold_dur dky_dur start_time))
          (t4 (+ atk_dur hold_dur dky_dur sus_dur start_time))
          (t5 (+ atk_dur hold_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t5) (set! val 0.0))
                  ((> time t4) (set! val (+ val inc3)))
                  ((> time t3) val) ;; sustain (don't do anything with val)
                  ((> time t2) (set! val (+ val inc2)))
                  ((> time t1) val) ;; hold don't do anything with val
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


;; a 'recorder' unit gen
(bind-func static recorder
  (lambda (buf:AudioBuffer*)
    (let ((rec 0) ;; where rec is the number of 'frames' to record
          (prec 0) ;; previous value of rec
          (chans (AudioBuffer_channels buf))
          (chan 0)
          (lgth (* chans (AudioBuffer_frames buf)))
          (l1 (- lgth 1))
          (rhead 0)
          (phead 0)
          (pos 0)
          (t 0)
          (dat (AudioBuffer_ptr buf 0 0))
          (start 0) ;; loop start in frames
          (loop 0) ;; loop length in frames (negative plays backwards)
          (ploop 0)) ;; previous loop value
      (lambda (x)
        (if (<> prec rec) (set! rhead 0))
        (if (> rec 0)
            (begin (pset! dat rhead x)
                   (set! rhead (+ 1 rhead))
                   (if (= chan 0) (set! rec (- rec 1)))
                   (if (= rhead lgth) (set! rec 0)))
            (begin (set! rhead 0)))
        (if (<> ploop loop) (set! phead 0))
        (if (<> loop 0)
            (begin
              (set! pos (+ (* start chans) phead))
              (if (or (< pos 0) (> pos l1))
                  (set! x x) ;; (i.e. don't pref if bad index)
                  (set! x (pref dat pos)))
              (set! phead (+ phead (if (< loop 0) -1 1)))
              (if (= phead (* chans loop)) (set! phead 0))))
        ;; (if (= 0 (% t (* chans SR)))
        ;;     (println "rec:" rec "loop:" loop "start:" start "rhead:" rhead "phead:" phead))
        (set! chan (+ chan 1))
        (if (= chan chans) (set! chan 0))
        (set! t (+ t 1))
        (set! ploop loop)
        (set! prec rec)
        x))))



(define *xtmlib-audio_dsp-loaded* #t)

(impc:aot:insert-footer "xtmaudio_dsp")
