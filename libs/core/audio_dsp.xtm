;;; audio_dsp.xtm -- audio DSP library

;; Author: Andrew Sorensen
;; Keywords: extempore
;; Required dylibs:

;;; Commentary:

;; Please keep in mind that these functions
;; are provided as EXAMPLES ONLY.  They are
;; things that I've thown together and are
;; not to be considered "production" in any way.
;; In particular they are very very inefficient!!
;;
;; Please feel free to fix things and contribute
;; extra juicy bits and pieces
;;
;; Contains:
;; Sine, Square, Saw, Pulse waves
;; Delay, TapDelay, Comb (variable length delay)
;; AllPass, Reverb, Flanger and Chorus
;; LowPass, HighPass, BandPass and Notch filters
;; BitCrusher

;;; Code:

;; lib-loading config
(sys:load "libs/aot-cache/audio_dsp.xtm" 'quiet)
(sys:load-preload-check 'audio_dsp)
(define *xtmlib-audio_dsp-loaded* #f)

(impc:aot:suppress-aot-do
 (sys:load "libs/core/math.xtm")
 (sys:load "libs/core/audiobuffer.xtm"))
(impc:aot:insert-forms
 (sys:load "libs/core/math.xtm" 'quiet)
 (sys:load "libs/core/audiobuffer.xtm" 'quiet))

(impc:aot:insert-header "xtmaudio_dsp")

(bind-func print_audio_state
  (lambda ()
    (printf "    FRAMES: %lld\n" FRAMES)
    (printf " OUT CHANS: %lld\n" CHANNELS)
    (printf "  IN CHANS: %lld\n" IN_CHANNELS)
    (printf "SAMPLERATE: %f\n" (ftod (convert SAMPLERATE)))))

(xtmX print_audio_state)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; silence
;; (bind-func dsp:DSP
;;   (lambda (in time chan dat)
;;     0.0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  midi/freq utilities
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func midi2frq
  (lambda (pitch:SAMPLE)
    (if (<= pitch 0.0) 0.0
        (* 440.0 (pow 2.0 (/ (- pitch 69.0) 12.0))))))

(bind-func frq2midi
  (lambda (freq:SAMPLE)
    (if (<= freq 0.0) 0.0
        (+ (* 12.0 (log2 (/ freq 440.0))) 69.0))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; metronome
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; tempo,offset,mark,total-beats,cycle-beats,beat-env,samp-env
;; (bind-type Metronome <Rational,i64,i64,Rational,Rational,[Rational,Rational]*,[Rational,Rational]*>)

;; (bind-func MakeMetro_3
;;   (lambda (tempo offset:i64 beat:Rational)
;;     (let ((tempoR (/ 60 (Rat (dtoi64 (* 100. tempo)) 100)))
;;           (line (lambda (x1:Rational y1:Rational x2:Rational y2:Rational)
;;                   (let ((m (if (= (Rat 0 1) (- x2 x1))
;;                                (Rat 0 1)
;;                                (/ (- y2 y1) (- x2 x1))))
;;                         (c (- y1 (* m x1))))
;;                     (lambda (t:Rational)
;;                       (+ (* t m) c))))))
;;       (Metronome tempoR 0 offset beat (Rat 4 1)
;;                  (line (Rat offset 1) beat
;;                        (+ offset (* tempoR SAMPLE_RATE))
;;                        (+ beat 1/1))
;;                  (line beat (Rat offset 1)
;;                        (+ beat 1/1)
;;                        (+ offset (* tempoR SAMPLE_RATE)))))))

;; (bind-func MakeMetro_1
;;   (lambda (tempo)
;;     (MakeMetro_3 tempo (now) (Rat 0 1))))

;; (bind-func MakeMetro_4
;;   (lambda (tempo offset beatn beatd)
;;     (MakeMetro_3 tempo offset (Rat beatn beatd))))

;; (bind-poly MakeMetro MakeMetro_3)
;; (bind-poly MakeMetro MakeMetro_1)
;; (bind-poly MakeMetro MakeMetro_4)

;; (bind-func metro_get_time
;;   (lambda (m:Metronome* beat:Rational)
;;     (+ (dtoi64 (* 1.0 ((tref m 6) beat))) (tref m 1))))

;; (bind-func metro_get_beat
;;   (lambda (m:Metronome* time:i64)
;;     ((tref m 5) (Rat time 1))))

;; (bind-func metro_get_quantized
;;   (lambda (m:Metronome* q:Rational)
;;     (let ((val (+ (tref m 3) ;; total beats
;;                   (/ (- (now) (tref m 2)) ;; mark
;;                      (* SAMPLE_RATE (tref m 0)))))
;;           (q2 (- q (% val q))))
;;       (+ val (- q (% val q))))))

;; (bind-func metro_get_tempo
;;   (lambda (m:Metronome*)
;;     (/ 60 (tref m 0))))

;; (bind-func metro_get_duration
;;   (lambda (m:Metronome* dur:Rational)
;;     (convert (* (convert SAMPLE_RATE SAMPLE) (* dur (tref m 0))) i64)))

;; (bind-func print_metronome:[void,Metronome*]*
;;   (lambda (m)
;;     (println "Metronome>> bpm:" (metro_get_tempo m) "beats:" (tref m 3))))

;; (bind-poly print print_metronome)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; some simple conversions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func amp2db
  (lambda (x:SAMPLE)
    (* 20. (log10 x))))

(bind-func db2amp
  (lambda (x:SAMPLE)
    (pow 10. (/ x 20.))))


;; root mean squared (mono passthrough)
;; grab current rms value from val:
;;
;; updates db every FRAMES
;; passes mono signal straight through
;;
;; DB is (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_c
  (lambda ()
    (let ((d:SAMPLE* (alloc FRAMES))
          (t 0)
          (db:SAMPLE 0.0))
      (lambda (x:SAMPLE)
        (pset! d (% t FRAMES) (* x x))
        (set! t (+ t 1))
        (if (= 0 (% t FRAMES))
            (set! db (+ 3.0 (amp2db (sqrt (vmean d FRAMES))))))
        x))))

;; rms
;;
;; left and right are db
;; (RMS is +3db - i.e. dBFS with sine 1.0 at 0.0db)
;;
(bind-func rms_st_c
  (lambda ()
    (let ((lgth (* 1 FRAMES))
          (dl:SAMPLE* (alloc lgth))
          (dr:SAMPLE* (alloc lgth))
          (t 0)
          (left:SAMPLE 0.0)
          (right:SAMPLE 0.0))
      (lambda (chan:i64 x:SAMPLE)
        (if (= chan 0)
            (begin (pset! dl (% t lgth) (* x x))
                   (set! t (+ t 1))
                   ;;(printf "left %f\n" (ftod left))
                   (if (= 0 (% t lgth))
                       (begin
                         (set! left (+ 3.0 (amp2db (sqrt (vmean dl lgth)))))
                         (set! right (+ 3.0 (amp2db (sqrt (vmean dr lgth)))))))
                   void)
            (begin (pset! dr (% t lgth) (* x x))
                   void))
        x))))

;; amount of curve
;;
;; width is duration of the curve
;;
;; the 'power' value of the curve
;; can be negative!
;;
;; 1.0 or 0.0 = flat (returns 1.0)
;; 1.01 = close to linear
;; 2.0 = normal value
;; 6.0 = steeper curve etc..
;;
;; time 0.0 -> width
(bind-func gainf:[SAMPLE,i64,i64,SAMPLE]*
  (lambda (time width power)
    (let ((amp 1.0)
          (p:double (convert power))
          (t (/ (i64tod time) (i64tod width))))
      (if (< p 0.0)
          (begin (set! p (fabs p))
                 (set! t (- 1.0 t))))
      (let ((out (* amp (/ (- (pow p t) 1.0) (- p 1.0)))))
        (convert
         (if (> out amp) amp
             (if (< out 0.0) 0.0
                 out)))))))


;; given current channel
;; and pan value [0.0-1.0]
;; returns value betwee n [0.0-1.0]
;; uses CHANNELS
(bind-func panner
  (lambda (chan:i64 pan)
    (let ((cn1:SAMPLE (convert (- CHANNELS 1))))
      (- 1.0 (/ (fabs (- (* pan cn1) (convert chan))) cn1)))))


;; a repeating hann signal of width
;;
;; where a cycle is
;; time 0.0 -> width
;;
;; repeat is:
;; 1.0 - repeat immediately
;; 2.0 - repeat after two cycles
;; 4.0 - repeat after four cycles etc..
;;
(bind-func hann
  (lambda (time:i64 width:i64 repeat:i64)
    (if (or (< width 1)
            (> (% time (* width repeat)) width))
        0.0
        (* 0.5
           (- 1.0
              (cos (* STWOPI (/ (convert time)
                                (convert width)))))))))

(bind-func hann
  (lambda (time:i64 width:i64)
    (hann:[float,i64,i64,i64]* time width 10000000000)))


;; time in samples (starting from 0)
;; apex (in samples) is after how many samples we hit 1.0 before decaying
(bind-func impulse
  (lambda (time:i64 apex:i64)
    (let ((h:SAMPLE (convert (/ time apex))))
      (* h (exp (- 1.0 h))))))



;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html
(bind-func dsp_randn
  (let ((phase:i64 0))
    (lambda ()
      (let ((u1:SAMPLE (random))
            (u2:SAMPLE (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (dsp_randn)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; x values must fall within the range -PI ... PI
(bind-func _sin
  (let ((p 0.225) ; :_abuf* (alloc))
        (b (/ 4.0 SPI))
        (c (/ -4.0 (* SPI SPI))))
    (lambda (x)
      (let ((y (+ (* b x) (* c x (fabs x)))))
        (+ (* p (- (* y (fabs y)) y)) y)))))

;; (bind-func osc_c
;;   (lambda (phase)
;;     (lambda (amp freq)
;;       (let ((incr (* TWOPI (/ freq SAMPLERATE))))
;; 	(set! phase (+ phase incr))
;; 	(* amp (sin phase))))))

(bind-func osc_c
  (lambda (phase)
    (let ((t (/ STWOPI SAMPLERATE)))
      (lambda (amp freq)
        (set! phase (+ phase (* t (clamp freq (- 0.0 SRs) SRs))))
        (if (> phase SPI) (set! phase (- phase STWOPI)))
        (* amp (_sin phase))))))

(bind-func osc_mc_c
  (lambda (phase)
    (let ((val 0.0)
          (osc (osc_c phase)))
      (lambda (chan amp freq)
        (if (= chan 0) (set! val (osc amp freq)))
        val))))

;; square oscillator
;; where 'n' is how squared off the wave is
;; an n of 1.0 is very rounded
;; an n of 30.0 is very sharp
(bind-func square_n_c
  (lambda (phase)
    (let ((osc (osc_c phase)))
      (lambda (amp freq n)
        (* amp 0.8:f (tanh (* n (osc 1.0 freq))))))))

;; same as square_n_c
;; but 'n' is a function of frequency
(bind-func square_c
  (lambda (phase)
    (let ((osc (osc_c phase)))
      (lambda (amp freq)
        (* amp 0.8:f
           (tanh (* (clamp (- 100.0 (frq2midi freq)) 2.0 150.0)
                    (osc 1.0 freq))))))))

;; square oscillator multichannel
(bind-func square_mc_c
  (lambda (phase)
    (let ((sqr (square_c phase))
          (mem 0.0))
      (lambda (chan:i64 amp freq)
        (if (= chan 0) (set! mem (sqr amp freq)))
        mem))))

;; a 'leaky' integrator
(bind-func integrator_c
  (let ((old 0.0)
        (leak 0.99))
    (lambda (x)
      (set! old (+ (* leak old) x))
      old)))

;; triangle oscillator
;; by using leak integrator over square
;; see square wave for 'n'
(bind-func triangle_n_c
  (lambda (phase)
    (let ((osc (osc_c phase))
          (old:SAMPLE 0.0)
          (new:SAMPLE 0.0)
          (leak 0.9))
      (lambda (amp freq n)
        (set! old (+ (* leak old)
                     (* amp (tanh (* n (osc 1.0 freq))))))
        (* 0.125 old)))))

(bind-func triangle_c
  (lambda (phase)
    (let ((osc (osc_c phase))
          (old:SAMPLE 0.0)
          (new:SAMPLE 0.0)
          (leak 0.9))
      (lambda (amp freq)
        (set! old (+ (* leak old)
                     (* amp (tanh (* (clamp (- 100.0 (frq2midi freq)) 2.0 150.0)
                                     (osc 1.0 freq))))))
        (* 0.125 old)))))


;; saw oscillator
(bind-func triangle_mc_c
  (lambda (phase)
    (let ((mem 0.0)
          (tri (triangle_c phase)))
      (lambda (chan:i64 amp freq)
        (if (= chan 0) (set! mem (tri amp freq)))
        mem))))

;; rect wave oscillator - useful for pulse width modulation
(bind-func rect_c
  (lambda (phase)
    (lambda (amp:SAMPLE freq duty)
      (let ((incr (/ freq SAMPLERATE)))
        (set! phase (+ phase incr))
        (if (> phase 1.0) (set! phase (- phase 1.0)))
        (if (< phase duty) amp (* -1.0 amp))))))

(bind-func rect_mc_c
  (lambda (phase)
    (let ((val 0.0)
          (rct (rect_c phase)))
      (lambda (chan:i64 amp freq duty)
        (if (= chan 0) (set! val (rct amp freq duty)))
        val))))

;; saw oscillator
(bind-func saw_c
  (lambda (phase)
    (let ((dp 1.0)
          (x:SAMPLE 0.0)
          (limitchk:SAMPLE 0.000001)
          (leak 0.995)
          (saw 0.0))
      (lambda (amp freq)
        (let* ((qmax (/ SAMPLERATE freq 2.0))
               (dc (/ -0.498 qmax)))
          (set! phase (+ phase dp))
          (if (< phase 0.0)
              (begin (set! phase (- 0.0 phase))
                     (set! dp (- 0.0 dp)))
              (if (> phase qmax)
                  (begin (set! phase (+ qmax (- qmax phase)))
                         (set! dp (- 0.0 dp)))))
          (set! x (* SPI phase))
          (if (< x limitchk) (set! x limitchk))
          (set! saw (* leak (+ saw dc (/ (sin x) x))))
          (* amp saw))))))


;; saw oscillator
(bind-func saw_mc_c
  (lambda (phase)
    (let ((mem 0.0)
          (saw (saw_c phase)))
      (lambda (chan:i64 amp freq)
        (if (= chan 0) (set! mem (saw amp freq)))
        mem))))

;; white noise generator
(bind-func white_c
  (lambda ()
    (lambda ()
      (* 0.33 (dsp_randn)))))

;; pink noise generator
;; uses Paul Kellet's economy method
;; http://www.firstpr.com.au/dsp/pink-noise/
(bind-func pink_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0))
      (lambda ()
        (set! b0 (+ (* b0 0.99765) (* (dsp_randn) 0.0555179)))
        (set! b1 (+ (* b1 0.96300) (* (dsp_randn) 0.2965164)))
        (set! b2 (+ (* b2 0.57000) (* (dsp_randn) 1.0526913)))
        (* 0.33 (+ b0 b1 b2 (* (dsp_randn) 0.1848)))))))

;; pulse train
(bind-func pulse_c
  (lambda ()
    (let ((time -1.0)
          (period:SAMPLE 0.0))
      (lambda (amp:SAMPLE freq width)
        (set! period (/ SAMPLERATE freq))
        (set! time (+ time 1.0))
        (if (< (modulo time period) width)
            amp
            0.0)))))

(bind-func pulse_mc_c
  (lambda ()
    (let ((pulse (pulse_c))
          (mem 0.0))
      (lambda (chan:i64 amp freq width)
        (if (= chan 0) (set! mem (pulse amp freq width)))
        mem))))

;; linear fade closure
(bind-func fade_c
  (lambda ()
    (let ((t 0.0)
          (incr (/ 1.0 (convert SAMPLE_RATE SAMPLE))))
      (lambda (initial:SAMPLE final dur)
        (set! t (+ t incr))
        (if (> t dur)
            final
            (+ initial (* (/ t dur) (- final initial))))))))

(bind-func fade_mc_c
  (lambda ()
    (let ((val 0.0)
          (fader (fade_c )))
      (lambda (chan:i64 initial final dur)
        (if (= chan 0) (set! val (fader initial final dur)))
        val))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_old_c
  (lambda (max_delay)
    (let ((line:SAMPLE* (zalloc max_delay))
          (time 0)
          (delay max_delay)
          (in 1.0)
          (out 0.5))
      (lambda (x:SAMPLE)
        (let* ((n (modulo time delay))
               (delayed (pref line n))
               (y (+ (* in x) (* out delayed))))
          (pset! line n y)
          (set! time (+ time 1))
          y)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
(bind-func delay_c
  (lambda (max_delay:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
          (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE wet feedback)
        (set! n (modulo time delay))
        (set! y (pref line n))
        (set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(bind-func delay_mc_c
  (lambda (channels:i64 max_delay)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (delay_c max_delay)))
      (lambda (chan:i64 x wet feedback)
        ((pref dlines chan) x wet feedback)))))

(bind-func delay_st_c
  (lambda (d1 d2)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc 2))
          (i:i64 0))
      (pset! dlines 0 (delay_c d1))
      (pset! dlines 1 (delay_c d2))
      (lambda (chan:i64 x wet feedback)
        ((pref dlines chan) x wet feedback)))))

;; iir comb without interpolation
;; more efficient than comb if you
;; don't need variable length
;;
;; offset is for metro 'get-mark offset
(bind-func delay_t_c
  (lambda (max_delay offset:i64)
    (let ((delay max_delay)
          (line:SAMPLE* (zalloc delay))
          ;; (time 0)
          (n 0)
          (y 0.0))
      (lambda (x:SAMPLE time:i64 wet:SAMPLE feedback:SAMPLE)
        (set! n (modulo (convert (- time offset)) delay))
        (set! y (pref line n))
        ;;(set! time (+ time 1))
        (pset! line n (* feedback (+ x y)))
        (+ x (* y wet))))))


(bind-func delay_t_mc_c
  (lambda (channels:i64 max_delay:i64 offset:i64)
    (let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (delay_t_c max_delay offset)))
      (lambda (chan:i64 x time:i64 wet:SAMPLE feedback)
        ((pref dlines chan) x time wet feedback)))))

(bind-func delay_t_st_c
  (lambda (d1 d2 offset)
    (let ((dlines:[SAMPLE,SAMPLE,i64,SAMPLE,SAMPLE]** (alloc 2))
          (i:i64 0))
      (pset! dlines 0 (delay_t_c d1 offset))
      (pset! dlines 1 (delay_t_c d2 offset))
      (lambda (chan:i64 x time wet feedback)
        ((pref dlines chan) x time wet feedback)))))




;; iir comb with interpolation
;; delay for COMB needs to stay
;; as a fractional argument (i.e. float)
(bind-func comb_c
  (lambda (max_delay:i64)
    (let ((maxdelay max_delay)
          (line:SAMPLE* (zalloc maxdelay))
          (in_head 0)
          (out_head 0)
          (delay_:SAMPLE (convert max_delay))
          (alpha 0.0)
          (om_alpha 1.0)
          (ih:i64 0)
          (oh:i64 0)
          (delayed1 0.0)
          (delayed2 0.0)
          (delayed 0.0))
      (dotimes (ih maxdelay) (pset! line ih 0.0))
      (lambda (x:SAMPLE delay:SAMPLE wet:SAMPLE feedback:SAMPLE)
        (if (<> delay delay_)
            (begin (set! delay_ delay)
                   (set! alpha (- delay (floor delay)))
                   (set! om_alpha (- 1.0 alpha))
                   (set! out_head (- (+ maxdelay in_head)
                                     (convert delay)))))
        (set! ih (modulo in_head maxdelay))
        (set! oh (modulo out_head maxdelay))
        (set! delayed1 (pref line oh))
        (set! delayed2 (pref line (modulo (+ oh 1) maxdelay)))
        (set! delayed (+ (* alpha delayed1) (* om_alpha delayed2)))
        ;;(set! y (+ (* in x) (* out delayed)))
        (pset! line ih (* feedback (+ x delayed)))
        (set! in_head (+ ih 1))
        (set! out_head (+ oh 1))
        (+ x (* delayed wet))))))


(bind-func comb_mc_c
  (lambda (channels:i64 max_delay)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (comb_c max_delay)))
      (lambda (chan:i64 x delay wet feedback)
        (let ((f (pref dlines chan)))
          (f x delay wet feedback))))))


;; flanger
(bind-func flanger_c
  (lambda (delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
    (let ((comb (comb_c (convert (+ delay mod_range))))
          (mod (osc_c mod_phase)))
      (lambda (x:SAMPLE wet feedback)
        (comb x (+ delay (mod mod_range mod_rate)) wet feedback)))))


(bind-func flanger_mc_c
  (lambda (channels:i64 delay:SAMPLE mod_phase:SAMPLE mod_range mod_rate)
    (let ((comb (comb_mc_c channels (convert (+ delay mod_range))))
          (mod (osc_mc_c mod_phase))
          (i:i64 0))
      (lambda (chan:i64 x wet feedback)
        (comb chan x (+ delay (mod chan mod_range mod_rate)) wet feedback)))))

;; chorus
(bind-func chorus_c
  (lambda (phase)
    (let ((delay:SAMPLE 700.)
          (range:SAMPLE 200.)
          (rate:SAMPLE 0.1)
          (comb1 (comb_c (convert (+ delay range))))
          (comb2 (comb_c (convert (+ delay range))))
          (comb3 (comb_c (convert (+ delay range))))
          (mrng1 range)
          (mrng2 (* (random) range))
          (mrng3 (* (random) range))
          (mrte1 rate)
          (mrte2 (* rate 1.372))
          (mrte3 (* rate 0.792))
          (dly1 delay)
          (dly2 (* (random) delay))
          (dly3 (* (random) delay))
          (mod1 (osc_c phase))
          (mod2 (osc_c phase))
          (mod3 (osc_c phase)))
      (lambda (x:SAMPLE wet fb)
        (+ (comb1 x (+ dly1 (mod1 mrng1 mrte1) wet fb) wet fb)
           (comb2 x (+ dly2 (mod2 mrng2 mrte2) wet fb) wet fb)
           (comb3 x (+ dly3 (mod3 mrng3 mrte3) wet fb) wet fb))))))

(bind-func chorus_mc_c
  (lambda (channels:i64 phase)
    (let ((dlines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! dlines i (chorus_c phase)))
      (lambda (chan:i64 x wet fb)
        (let ((f (pref dlines chan)))
          (f x wet fb))))))


;; tap delay
(bind-func tap_delay_c
  (lambda (max_delay num_of_taps)
    (let ((line:SAMPLE* (zalloc max_delay))
          (taps:i64* (zalloc num_of_taps))
          (delay max_delay)
          (time 0))
      (lambda (x:SAMPLE)
        (let ((y 0.0)
              (i 0)
              (n (modulo time delay))
              (gain (/ 1.0 (convert num_of_taps))))
          (pset! line n x)
          (dotimes (i num_of_taps)
            (set! y (+ y (* gain (pref line (% (+ (pref taps i) n) delay))))))
          (set! time (+ time 1))
          y)))))

(bind-func tap_delay_mc_c
  (lambda (nchan:i64 max_delay num_of_taps)
    (let ((tap_delay_buf:[SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan)
        (pset! tap_delay_buf i (tap_delay_c max_delay num_of_taps)))
      (lambda (chan x)
        ((pref tap_delay_buf chan) x)))))

;; allpass
(bind-func allpass_old_c
  (lambda (delay)
    (let ((inline:SAMPLE* (zalloc delay))
          (outline:SAMPLE* (zalloc delay))
          (time 0)
          (g 0.9))
      (lambda (x)
        (let* ((n (% time delay))
               (dy (pref outline n))
               (dx (pref inline n))
               (y (+ (* -1.0 g x)
                     dx
                     (* g dy))))
          (pset! inline n x)
          (pset! outline n y)
          (set! time (+ time 1))
          y)))))

;; allpass
(bind-func allpass_c
  (lambda (delay)
    (let ((_delay delay)
          (inline:SAMPLE* (zalloc _delay))
          (outline:SAMPLE* (zalloc _delay))
          (time 0))
      (lambda (x fb)
        (let* ((n (% time _delay))
               (dy (pref outline n))
               (dx (pref inline n))
               (y (+ (* -1.0 fb x)
                     dx
                     (* fb dy))))
          (pset! inline n x)
          (pset! outline n y)
          (set! time (+ time 1))
          y)))))


(bind-func allpass_mc_c
  (lambda (channels:i64 delay)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (allpass_c delay)))
      (lambda (chan:i64 x wet)
        (let ((f (pref lines chan)))
          (f x wet))))))


;; a dodgy reverb
;; (bind-func reverb_c
;;   (lambda (size) ; size in ms
;;     (let ((ms (/ SAMPLERATE 1000.0))
;; 	  (wet .25)
;; 	  (dly1 (delay_c (dtoi64 (* ms (* .192 size)))))
;; 	  (dly2 (delay_c (dtoi64 (* ms (* .373 size)))))
;; 	  (dly3 (delay_c (dtoi64 (* ms (* .671 size)))))
;; 	  (dly4 (delay_c (dtoi64 (* ms (* .712 size)))))
;; 	  (ap1 (allpass_c (dtoi64 (* ms size))))
;; 	  (ap2 (allpass_c (dtoi64 (* ms (* .329 size))))))
;;       (ap1.g .8)
;;       (ap2.g .8)
;;       (lambda (in)
;; 	(let ((wetin (* in wet)))
;; 	  (+ (* in (- 1.0 wet)) (ap1 (ap2 (+ (dly1 wetin)
;; 					     (dly2 wetin)
;; 					     (dly3 wetin)
;; 					     (dly4 wetin))))))))))

;; a dodgy reverb mk2
(bind-func reverb_old_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (dly1 (delay_old_c (convert (* ms (* .192 size)))))
          (dly2 (delay_old_c (convert (* ms (* .373 size)))))
          (dly3 (delay_old_c (convert (* ms (* .671 size)))))
          (dly4 (delay_old_c (convert (* ms (* .712 size)))))
          (ap1 (allpass_old_c (convert (* ms size))))
          (ap3 (allpass_old_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_old_c (convert (* ms (* .329 size))))))
      (ap1.g .8)
      (ap2.g .7)
      (ap3.g .6)
      (lambda (in:SAMPLE wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (+ (dly1 wetin)
                               (dly2 wetin)
                               (dly3 wetin)
                               (dly4 wetin)))))))))))


;; a dodgy reverb mk2
(bind-func reverb_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (dly1 (delay_c (convert (* ms (* .192 size)))))
          (dly2 (delay_c (convert (* ms (* .373 size)))))
          (dly3 (delay_c (convert (* ms (* .671 size)))))
          (dly4 (delay_c (convert (* ms (* .712 size)))))
          (ap1 (allpass_c (convert (* ms size))))
          (ap3 (allpass_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet fb)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 (* .3 (+ (dly1 wetin 1.0 fb)
                                     (dly2 wetin 1.0 fb)
                                     (dly3 wetin 1.0 fb)
                                     (dly4 wetin 1.0 fb)))
                            .8)
                       .7)
                  .6)))))))

(bind-func reverb_mc_c
  (lambda (channels:i64 size)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (reverb_c size)))
      (lambda (chan:i64 x wet fb)
        (let ((f (pref lines chan)))
          (f x wet fb))))))


;; a dodgy reverb mk2
(bind-func reverb2_c
  (lambda (size:SAMPLE) ; size in ms
    (let ((ms (/ SAMPLERATE 1000.0))
          (ap1 (allpass_c (convert (* ms size))))
          (ap3 (allpass_c (convert (* ms (* .929 size)))))
          (ap2 (allpass_c (convert (* ms (* .329 size))))))
      (lambda (in:SAMPLE wet)
        (let ((wetin (* in wet)))
          (+ (* in (- 1.0 wet))
             (ap1 (ap2 (ap3 wetin .8) .7) .6)))))))


(bind-func reverb2_mc_c
  (lambda (channels:i64 size)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (reverb2_c size)))
      (lambda (chan:i64 x wet)
        (let ((f (pref lines chan)))
          (f x wet))))))



;; a dodgy bitcrusher
(bind-func crusher_c
  (lambda ()
    (let ((amp 1.0))
      (lambda (in bits:SAMPLE)
        (* amp (/ (floor (* in (pow 2. bits)))
                  (pow 2. bits)))))))

;; if h is greater than 0.0
;; the continue to play last
;; held sample
(bind-func hold3_c
  (lambda ()
    (let ((mem 0.0))
      (lambda (in:SAMPLE h:SAMPLE)
        (if (> h 0.0)
            mem
            (begin (set! mem in)
                   in))))))

(bind-func hold_mc_c
  (lambda (channels:i64)
    (let ((holds:[SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! holds i (hold3_c)))
      (lambda (chan:i64 x h)
        (let ((f (pref holds chan)))
          (f x h))))))

;; a dodgy bitcrusher
(bind-func crush
  (lambda (in:SAMPLE bits:SAMPLE)
    (/ (floor (* in (pow 2. bits)))
       (pow 2. bits))))

;; a dodgy amp distortion
(bind-func distort_c
  (lambda (gain)
    (let ((lim 0.5))
      (lambda (in:SAMPLE)
        (clamp lim (* -1.0 lim) (* gain in))))))

;; mono in (ignores all other channels)
;; pan value [0.0-1.0]
(bind-func panner_c
  (lambda (channels)
    (let ((v:SAMPLE 0.0)
          (out:SAMPLE 0.0))
      (lambda (chan x:SAMPLE pan)
        (if (= chan 0) (set! out x))
        (set! v (fabs (- (* (- channels 1.0) pan) (convert chan))))
        (if (> v 1.0) 0.0
            (* (- 1.0 v) out))))))

;; simple stereo weights
(bind-func mix2
  (lambda (chan:i64 x:SAMPLE left right)
    (cond ((= chan 0) (* x left))
          ((= chan 1) (* x right))
          (else 0.0))))

;; simple stereo weights (from mono)
(bind-func mix2_c
  (lambda ()
    (let ((out 0.0))
      (lambda (chan:i64 x:SAMPLE left right)
        (cond ((= chan 0) (set! out x) (* out left))
              ((= chan 1) (* out right))
              (else 0.0))))))

;; simple quad weights
(bind-func mix4
  (lambda (chan x:SAMPLE c1 c2 c3 c4)
    (cond ((= chan 0) (* x c1))
          ((= chan 1) (* x c2))
          ((= chan 2) (* x c3))
          ((= chan 3) (* x c4))
          (else 0.0))))

;; simple quad weights (from mono)
(bind-func mix4_c
  (lambda ()
    (let ((out 0.0))
      (lambda (chan:i64 x:SAMPLE c1 c2 c3 c4)
        (cond ((= chan 0) (set! out x) (* out c1))
              ((= chan 1) (* out c2))
              ((= chan 2) (* out c3))
              ((= chan 3) (* out c4))
              (else 0.0))))))


;; simple oct weights
(bind-func mix8
  (lambda (chan x:SAMPLE c1 c2 c3 c4 c5 c6 c7 c8)
    (cond ((= chan 0) (* x c1))
          ((= chan 1) (* x c2))
          ((= chan 2) (* x c3))
          ((= chan 3) (* x c4))
          ((= chan 4) (* x c5))
          ((= chan 5) (* x c6))
          ((= chan 6) (* x c7))
          ((= chan 7) (* x c8))
          (else 0.0))))

;; an n channel mixer
;; cdat is an array of doubles values
;; each array element is a channels mix (between 0.0 and 1.0)
(bind-func mixer_c
  (lambda (channels:i64)
    (lambda (cdat:SAMPLE* chan:i64 in:SAMPLE)
      (if (< chan channels)
          (* in (pref cdat chan))
          0.0))))


;; http://www.cytomic.com/files/dsp/SvfLinearTrapOptimised2.pdf
;; the 'using v1 to compute v2' version


;; the @param tags in the docstring are actually for the returned
;; closure (hence being below the @return tag in the docstring)
(bind-func svf_c
  "a state variable filter (SVF)

@return - a closure which takes 4 arguments:
@param in - input pointer |6,SAMPLE|* (|in,low,band,high,notch,peak|)
@param cutoff - filter cutoff (Hz)
@param res - filter resonance
@param outarray - place to store the output
"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res outarray:|6,SAMPLE|*)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (aset! outarray 0 in) ;; input
        (aset! outarray 1 v2) ;; low
        (aset! outarray 2 v1) ;; band
        (aset! outarray 3 (- in (- (* k v1) v2))) ;; high
        (aset! outarray 4 (- in (* k v1))) ;; notch
        (aset! outarray 5 (- in (- (* k v1) (* 2.0 v2)))) ;; peak
        outarray))))

(bind-func svf_mc_c
  (lambda (nchan:i64)
    (let ((svf_buf:[|6,float|*,float,float,float,|6,float|*]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! svf_buf i (svf_c)))
      (lambda (chan in cutoff res outarray)
        ((pref svf_buf chan) in cutoff res outarray)))))

(bind-func lpf_c
  "lowpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g:SAMPLE 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func lpf_mc_c
  (lambda (nchan:i64)
    (let ((lpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! lpf_buf i (lpf_c)))
      (lambda (chan in cutoff res)
        ((pref lpf_buf chan) in cutoff res)))))

(bind-func lpf2_c
  "a state variable lowpass filter. slightly more flops than lpf_c,
but v1 and v2 can be computed in parallel"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff res)
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k )))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func lpf2_mc_c
  (lambda (nchan:i64)
    (let ((lpf2_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan)
        (pset! lpf2_buf i (lpf2_c)))
      (lambda (chan in cutoff res)
        ((pref lpf2_buf chan) in cutoff res)))))

(bind-func bpf_c
  "bandpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v1))))

(bind-func bpf_mc_c
  (lambda (nchan:i64)
    (let ((bpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! bpf_buf i (bpf_c)))
      (lambda (chan in cutoff res)
        ((pref bpf_buf chan) in cutoff res)))))

(bind-func hpf_c
  "highpass filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (- (* k v1) v2))))))

(bind-func hpf_mc_c
  (lambda (nchan:i64)
    (let ((hpf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! hpf_buf i (hpf_c)))
      (lambda (chan in cutoff res)
        ((pref hpf_buf chan) in cutoff res)))))

(bind-func notch_c
  "notch filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (* k v1))))))

(bind-func notch_mc_c
  (lambda (nchan:i64)
    (let ((notch_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! notch_buf i (notch_c)))
      (lambda (chan in cutoff res)
        ((pref notch_buf chan) in cutoff res)))))

(bind-func peak_c
  "peak filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (- 2.0 (* 2.0 res)))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! v1 (+ (* a1 ic1eq) (* a2 (- in ic2eq))))
        (set! v2 (+ ic2eq (* g v1)))
        (set! ic1eq (- (* 2.0 v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (- in (- (* k v1) (* 2.0 v2)))))))

(bind-func peak_mc_c
  (lambda (nchan:i64)
    (let ((peak_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! peak_buf i (peak_c)))
      (lambda (chan in cutoff res)
        ((pref peak_buf chan) in cutoff res)))))

(bind-func lshelf_c
  "low shelf filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 1.0) (m1 1.0) (m2 1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff gain Q)
        ;; one option: do the check (= res oldres) trick here
	      (set! A (pow 10.0 (/ gain 40.0)))
        (set! g (/ (tan (* SPI (/ cutoff (convert SAMPLE_RATE))))
                   (sqrt A)))
        (set! k (/ 1.0 Q))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! m1 (* k (- A 1.0)))
        (set! m2 (- (* A A) 1.0))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ in (* m1 v1) (* m2 v2))))))

(bind-func lshelf_mc_c
  (lambda (nchan:i64)
    (let ((lshelf_buf:[float,float,float,float,float]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! lshelf_buf i (lshelf_c)))
      (lambda (chan in cutoff gain Q)
        ((pref lshelf_buf chan) in cutoff gain Q)))))


(bind-func hshelf_c
  "low shelf filter: returns filtering closure which implements a state variable filter"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (A 0.0)
          (g 0.0)
          (k 0.0)
          (a1 0.0) (a2 0.0) (a3 0.0)
          (m0 0.0) (m1 1.0) (m2 1.0)
          (v1 0.0) (v2 0.0) (v3:SAMPLE 0.0))
	    (lambda (in cutoff gain Q)
        ;; one option: do the check (= res oldres) trick here
	      (set! A (pow 10.0 (/ gain 40.0)))
        (set! g (/ (tan (* SPI (/ cutoff (convert SAMPLE_RATE))))
                   (sqrt A)))
        (set! k (/ 1.0 Q))
        (set! a1 (/ 1.0 (+ 1.0 (* g (+ g k)))))
        (set! a2 (* g a1))
        (set! a3 (* g a2))
        (set! m0 (* A A))
        (set! m1 (* k (- 1.0 A) A))
        (set! m2 (- 1.0 (* A A)))
        (set! v3 (- in ic2eq))
        (set! v1 (+ (* a1 ic1eq) (* a2 v3)))
        (set! v2 (+ ic2eq (* a2 ic1eq) (* a3 v3)))
        (set! ic1eq (- (* 2.0:f v1) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        (+ (* m0 in) (* m1 v1) (* m2 v2))))))

(bind-func hshelf_mc_c
  (lambda (nchan:i64)
    (let ((hshelf_buf:[float,float,float,float,float]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! hshelf_buf i (hshelf_c)))
      (lambda (chan in cutoff gain Q)
        ((pref hshelf_buf chan) in cutoff gain Q)))))

;; Andy Simper's Sallen Key LPF
;; http://cytomic.com/files/dsp/SkfLinearTrapOptimised2.pdf

(bind-func skf_c
  "lowpass filter: returns filtering closure using a Sallen Key lpf"
	(lambda ()
	  (let ((ic1eq 0.0) (ic2eq 0.0)
          (g 0.0)
          (k 0.0)
          (a0 0.0) (a1 0.0) (a2 0.0) (a3 0.0) (a4 0.0) (a5 0.0)
          (v1 0.0) (v2:SAMPLE 0.0))
	    (lambda (in cutoff res)
        ;; one option: do the check (= res oldres) trick here
	      (set! g (tan (* SPI (/ cutoff (convert SAMPLE_RATE)))))
        (set! k (* 2.0 res))
        (set! a0 (/ 1.0 (- (* (+ 1.0 g)
                              (+ 1.0 g))
                           (* g k))))
        (set! a1 (* k a0))
        (set! a2 (* (+ 1.0 g) a0))
        (set! a3 (* g a2))
        (set! a4 (/ 1.0 (+ 1.0 g)))
        (set! a5 (* g a4))
        (set! v1 (+ (* a1 ic2eq)
                    (* a2 ic1eq)
                    (* a3 in)))
        (set! v2 (+ (* a4 ic2eq)
                    (* a5 v1)))
        (set! ic1eq (- (* 2.0 (- v1 (* k v2))) ic1eq))
        (set! ic2eq (- (* 2.0 v2) ic2eq))
        v2))))

(bind-func skf_mc_c
  (lambda (nchan:i64)
    (let ((skf_buf:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (zalloc nchan))
          (i:i64 0))
      (dotimes (i nchan) (pset! skf_buf i (skf_c)))
      (lambda (chan in cutoff res)
        ((pref skf_buf chan) in cutoff res)))))


(bind-func hermite_interp
  (lambda (fractional y1:SAMPLE x0 x1 x2)
    (let ((c (* 0.5 (- x1 y1)))
          (v (- x0 x1))
          (w (+ c v))
          (a (+ w v (* (- x2 x0) 0.5)))
          (b (+ w a)))
      (+ (* (+ (* (- (* a fractional) b) fractional) c) fractional) x0))))


;; a rough and ready granulator
;; expects to work on 'n' channels
;; see examples/external/granular.xtm
;; or examples/core/granular.xtm
(bind-func granulator_c
  (lambda (channels)
    (let ((idx 0)
          (iot 2000)
          (iotn 100000000) ;; we want a grain right at the start
          (dlo 5000.0)
          (dhi 5000.0)
          (rlo 1.0)
          (rhi 1.0)
          (plo 0.4)
          (phi 0.6)
          (alo 0.2)
          (ahi 0.2)
          (wet 1.0)
          (PI2:double (* 2.0 3.141592))
          (gidx 0)
          (offset 0)
          (out:SAMPLE 0.0) (i 0)
          (cachesize:i64 (* 88200 2 channels))
          (cnt cachesize)
          (audio_cache:SAMPLE* (alloc cachesize))
          (lengths:|200,double|* (alloc))
          (durations:|200,double|* (alloc))
          (phases:|200,double|* (alloc))
          (startidx:|200,i64|* (alloc))
          (amps:|200,float|* (alloc))
          (rates:|200,double|* (alloc))
          (panning:|200,float|* (alloc))
          (active:|200,i1|* (alloc)))
      (dotimes (i 200) (aset! active i 0))
      (lambda (chan time:i64 in)
        (set! iotn (+ iotn 1))
        (pset! audio_cache (% cnt cachesize) in)
        (if (and (>= iotn iot)
                 (= chan 0))
            (begin
              (set! iotn 0)
              (aset! active gidx #t)
              (aset! lengths gidx (+ dlo (* (- dhi dlo) (random))))
              (aset! amps gidx (+ alo (* (- ahi alo) (random))))
              (aset! panning gidx (+ plo (* (- phi plo) (random))))
              (aset! durations gidx (aref lengths gidx))
              (aset! rates gidx (+ rlo (* (- rhi rlo)  (random))))
              (set! offset
                    (if (> (aref rates gidx) 1.0)
                        (+ 128
                           (* channels (dtoi64 (floor (- (* (aref rates gidx)
                                                            (aref lengths gidx))
                                                         (aref lengths gidx))))))
                        128))
              (aset! startidx gidx (% (- cnt offset) cachesize))
              (aset! phases gidx 0.0)
              (set! gidx (% (+ gidx 1) 200))))
        (set! cnt (+ cnt 1))
        (set! out 0.0)
        (dotimes (i 200)
          (if (= #t (aref active i))
              (begin
                (set! idx (+ (aref startidx i)
                             chan
                             (* channels (dtoi64 (floor (aref phases i))))))
                (set! out (+ out
                             (* (aref amps i)
                                (dtof (* 0.5 (- 1.0 (cos (* PI2 (/ (aref durations i) (aref lengths i)))))))
                                (panner chan (aref panning i))
                                (pref audio_cache (% idx cachesize)))))
                (if (= chan 0)
                    (begin
                      (aset! phases i (+ (aref phases i) (aref rates i)))
                      (aset! durations i (- (aref durations i) (aref rates i)))))
                (if (< (aref durations i) 8.0)
                    (begin
                      (aset! active i #f)
                      void)
                    void))))
        (+ (* (- 1.0 wet) in)
           (* wet out))))))


;; a rough and ready granulator
;; expects to work on 'n' channels
;; see examples/external/granular.xtm
;; or examples/core/granular.xtm
;; more expensive than linear
(bind-func granulator_hermite_c
  (lambda (channels)
    (let ((idx 0)
          (iot 2000)
          (iotn 100000000) ;; we want a grain right at the start
          (dlo 5000.0)
          (dhi 5000.0)
          (rlo 1.0)
          (rhi 1.0)
          (plo 0.5)
          (phi 0.5)
          (alo 0.2)
          (ahi 0.2)
          (wet 1.0)
          (PI2:double (* 2.0 3.141592))
          (gidx 0)
          (offset 0)
          (y1 0.0) (x0 0.0) (x1 0.0) (x2 0.0)
          (out:SAMPLE 0.0) (i 0)
          (cachesize:i64 (* 88200 2 channels))
          (cnt cachesize)
          (audio_cache:SAMPLE* (alloc cachesize))
          (lengths:|200,double|* (alloc))
          (durations:|200,double|* (alloc))
          (phases:|200,double|* (alloc))
          (startidx:|200,i64|* (alloc))
          (amps:|200,float|* (alloc))
          (rates:|200,double|* (alloc))
          (panning:|200,float|* (alloc))
          (active:|200,i1|* (alloc)))
      (dotimes (i 200) (aset! active i 0))
      (lambda (chan time:i64 in)
        (set! iotn (+ iotn 1))
        (pset! audio_cache (% cnt cachesize) in)
        (if (and (>= iotn iot)
                 (= chan 0))
            (begin
              (set! iotn 0)
              (aset! active gidx #t)
              (aset! lengths gidx (+ dlo (* (- dhi dlo) (random))))
              (aset! amps gidx (+ alo (* (- ahi alo) (random))))
              (aset! panning gidx (+ plo (* (- phi plo) (random))))
              (aset! durations gidx (aref lengths gidx))
              (aset! rates gidx (+ rlo (* (- rhi rlo)  (random))))
              (set! offset
                    (if (> (aref rates gidx) 1.0)
                        (+ 128
                           (* channels (dtoi64 (floor (- (* (aref rates gidx)
                                                            (aref lengths gidx))
                                                         (aref lengths gidx))))))
                        128))
              (aset! startidx gidx (% (- cnt offset) cachesize))
              (aset! phases gidx 0.0)
              (set! gidx (% (+ gidx 1) 200))))
        (set! cnt (+ cnt 1))
        (set! out 0.0)
        (dotimes (i 200)
          (if (= #t (aref active i))
              (begin
                (set! idx (+ (aref startidx i)
                             chan
                             (* channels (dtoi64 (floor (aref phases i))))))
                (set! y1 (pref audio_cache (% (- idx channels) cachesize)))
                (set! x0 (pref audio_cache (% idx cachesize)))
                (set! x1 (pref audio_cache (% (+ idx channels) cachesize)))
                (set! x2 (pref audio_cache (% (+ idx (* 2 channels)) cachesize)))
                (set! out (+ out
                             (* (aref amps i)
                                (dtof (* 0.5 (- 1.0 (cos (* PI2 (/ (aref durations i) (aref lengths i)))))))
                                (panner chan (aref panning i))
                                (hermite_interp (dtof (modulo (aref phases i) 1.0)) y1 x0 x1 x2))))
                (if (= chan 0)
                    (begin
                      (aset! phases i (+ (aref phases i) (aref rates i)))
                      (aset! durations i (- (aref durations i) (aref rates i)))))
                (if (< (aref durations i) 8.0)
                    (begin
                      (aset! active i #f)
                      void)
                    void))))
        (+ (* (- 1.0 wet) in)
           (* wet out))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; BiQuad coefficient formulae from
;; Audio EQ Cookbook Robert Bristow-Johnson
;;
;; http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; biquad low-pass filter
(bind-func lpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (- 1.0 coso) 2.0))
              (set! b1 (- 1.0 coso))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func lpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (lpfbq_c)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))


;; biquad high-pass filter
(bind-func hpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (oldres 0.0)
           (oldfreq 0.0))
      (lambda (x freq res:SAMPLE)
        ;; if frequency changes
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> res oldres))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (/ sino (* 2.0 res))))
              (set! oldfreq freq)
              (set! oldres res)
              (set! b0 (/ (+ 1.0 coso) 2.0))
              (set! b1 (* -1.0 (+ 1.0 coso)))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func hpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (hpfbq_c)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))


;; biquad band-pass filter
(bind-func bpfbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq:SAMPLE 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* 1.0 STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 alpha)
              (set! b1 0.0)
              (set! b2 (* -1.0 b0))
              (set! a0 (+ 1.0 alpha))
              (set! a1 (* -2.0 coso))
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))


(bind-func bpfbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (bpfbq_c)))
      (lambda (chan:i64 x freq bandwidth)
        (let ((f (pref lines chan)))
          (f x freq bandwidth))))))


;; biquad notch filter
(bind-func notchbq_c
  (lambda ()
    (let* ((y1 0.0)
           (y2 0.0)
           (x1 0.0)
           (x2 0.0)
           (b0 0.0)
           (b1 0.0)
           (b2 0.0)
           (a0 0.0)
           (a1 0.0)
           (a2 0.0)
           (two:SAMPLE 2.0)
           (oldfreq 0.0)
           (oldbw 0.0))
      ;; bandwidth in octaves
      (lambda (x freq bandwidth)
        ;; if frequency or bandwidth change
        ;; recalculate coefficients
        (if (or (<> freq oldfreq)
                (<> bandwidth oldbw))
            (let* ((omega (* STWOPI (/ freq SAMPLERATE)))
                   (sino (sin omega))
                   (coso (cos omega))
                   (alpha (* sino (sinh (* (/ (log2 two) two)
                                           bandwidth
                                           (/ omega sino))))))
              (set! oldfreq freq)
              (set! oldbw bandwidth)
              (set! b0 1.0)
              (set! b1 (* -2.0 coso))
              (set! b2 b0)
              (set! a0 (+ 1.0 alpha))
              (set! a1 b1)
              (set! a2 (- 1.0 alpha))))
        (let ((y (- (+ (* (/ b0 a0) x)
                       (* (/ b1 a0) x1)
                       (* (/ b2 a0) x2))
                    (* (/ a1 a0) y1)
                    (* (/ a2 a0) y2))))
          (set! y2 y1)
          (set! y1 y)
          (set! x2 x1)
          (set! x1 x)
          y)))))

(bind-func notchbq_mc_c
  (lambda (channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (notchbq_c)))
      (lambda (chan:i64 x freq bandwidth)
        (let ((f (pref lines chan)))
          (f x freq bandwidth))))))

;; Hilbert transform filter

(bind-func hilbert_c
  "n = filter order (should be 2^n + 1)"
  (lambda (n)
    (let ((i 0)
          (h_n:SAMPLE* (alloc n))
          (x_n:SAMPLE* (alloc n))
          (x_ptr 0))
      ;; h[i] = (2/(i*pi))*sin^2((i*pi)/2) for i=-n/2,...,n/2
      (dotimes (i n (/ (* n -1) 2))
        (pset! h_n
               (+ i (/ n 2))
               (* (/ 2.0 (* (convert i) SPI))
                  (pow (sin (/ (* (convert i) SPI) 2.0)) 2.0))))
      ;; h[0] = 0
      (pset! h_n (+ 1 (/ n 2)) 0.0)
      (lambda (x)
        (pset! x_n x_ptr x)
        (let ((out 0.0))
          (dotimes (i n)
            (set! out (+ out (* (pref h_n i)
                                (pref x_n (% (+ i x_ptr (- n 1)) n))))))
          (% (set! x_ptr (+ x_ptr 1)) n)
          out)))))

(bind-func hilb_env_follow_c
  (lambda (n)
    (let ((hilb (hilbert_c n)))
      (lambda (x:SAMPLE)
        (sqrt (+ (pow x 2.0)
                 (pow (hilb x) 2.0)))))))


(bind-func env_follow_c
  (lambda (ms:SAMPLE)
    (let ((y1 0.0)
          (coeff (/ 1000. (* ms (convert SAMPLE_RATE)))))
      (lambda (x:SAMPLE)
        (set! y1 (+ x (* coeff (- y1 x))))
        y1))))


(bind-func atkrel_env_follow_c
  (lambda (atk:SAMPLE rel:SAMPLE)
    (let ((y1 0.0)
          (atkcoeff (/ 1000. (* atk (convert SAMPLE_RATE))))
          (relcoeff (/ 1000. (* rel (convert SAMPLE_RATE)))))
      (lambda (x)
        (set! y1 (+ x (* (if (> x y1) atkcoeff relcoeff) (- y1 x))))
        y1))))


;;
;; moog VCF
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf_old_c
  (lambda ()
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4:SAMPLE 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
          y4)))))


;;
;; moog VCF variation 1
;;
;; from Stilson/Smith CCRMA
;;
(bind-func vcf1_c
  (lambda ()
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0) (t3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667))) ;; clipping
          (set! b0 in)
          b4)))))

;;
;; moog VCF variation 2
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf_c
  (lambda (type)
    (let ((x 0.0) (y1 0.0) (y2 0.0) (y3 0.0) (y4 0.0)
          (oldx 0.0) (oldy1 0.0) (oldy2 0.0) (oldy3 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((f (* 1.75 (/ cutoff SAMPLERATE)))
              ;;(k (- (* 2.0 (sin (* f (/ SPI 2.0)))) 1.0))
              (k (- (- (* 3.6 f) (* 1.6 (* f f))) 1.0))
              (p (* 0.5 (+ k 1.0)))
              (scale (exp (* (- 1.0 p) 1.386249)))
              (r (* res scale)))
          (set! x (- in (* r y4)))
          (set! y1 (+ (* x  p) (* oldx  p) (* -1.0 k y1)))
          (set! y2 (+ (* y1 p) (* oldy1 p) (* -1.0 k y2)))
          (set! y3 (+ (* y2 p) (* oldy2 p) (* -1.0 k y3)))
          (set! y4 (+ (* y3 p) (* oldy3 p) (* -1.0 k y4)))

          (set! oldx x) (set! oldy1 y1) (set! oldy2 y2) (set! oldy3 y3)
          ;; y4 is output
          (set! y4 (- y4 (* y4 y4 y4 0.1666667))) ;; clipping
          ;;(set! y4 (- y4 (/ (pow y4 3.0) 6.0))) ;; clipping
          (if (= 2 type) (- x y4)
              (if (= 3 type) (* 3.0 (- y3 y4))
                  y4)))))))


;;
;; moog VCF variation 3
;;
;; from Stilson/Smith CCRMA
;;
;; type is:
;; lp 1 (or anything)
;; hp 2
;; bp 3
(bind-func vcf3_c
  (lambda (type)
    (let ((b0 0.0) (b1 0.0) (b2 0.0) (b3 0.0) (b4 0.0)
          (t1 0.0) (t2 0.0))
      (lambda (in:SAMPLE cutoff res)
        (let ((frq (* 1.75 (/ cutoff SAMPLERATE)))
              (q (- 1.0 frq))
              (p (+ frq (* 0.8 frq q)))
              (f (+ p (- p 1.0))))
          (set! q (* res (+ 1.0 (* 0.5 q (+ (- 1.0 q) (* 5.6 q q))))))
          (set! in (- in (* q b4))) ;; feedback
          (set! t1 b1) (set! b1 (- (* (+ in b0) p) (* b1 f)))
          (set! t2 b2) (set! b2 (- (* (+ b1 t1) p) (* b2 f)))
          (set! t1 b3) (set! b3 (- (* (+ b2 t2) p) (* b3 f)))
          (set! b4 (- (* (+ b3 t1) p) (* b4 f)))
          (set! b4 (- b4 (* b4 b4 b4 0.166667)))
          ;;(set! b4 (- b4 (* b4 b4 0.25))) ;; clipping
          (set! b0 in)
          (if (= type 2) (- b0 b4) ;; high pass
              (if (= type 3) (* 3.0 (- b3 b4))
                  b4)))))))


(bind-func vcf_mc_c
  (lambda (type:i64 channels:i64)
    (let ((lines:[SAMPLE,SAMPLE,SAMPLE,SAMPLE]** (alloc channels))
          (i:i64 0))
      (dotimes (i channels) (pset! lines i (vcf_c type)))
      (lambda (chan:i64 x freq res)
        (let ((f (pref lines chan)))
          (f x freq res))))))

;; based on Steve Harris's foverdrive lv2 plugin
;; http://plugin.org.uk/

(bind-func overdrive_c
  "Drive range:[1.0,3.0]"
  (lambda (drive)
    (let ((drive_minus_1 (- drive 1.0)))
      (lambda (x:SAMPLE)
        (let ((absx (fabs x)))
          (/ (* x (+ absx drive))
             (+ (* x x)
                (* drive_minus_1 absx)
                1.0)))))))

;; based on Steve Harris's Valve Saturation lv2 plugin
;; http://plugin.org.uk/

(bind-func saturation_c
  "level:[0.0,1.0] character:[0.0,1.0]"
  (lambda ()
    (let ((itm1 0.0)
          (otm1 0.0))
      (lambda (x:SAMPLE level:SAMPLE character:SAMPLE)
        (let ((q (- level 0.999))
              (dist (+ (* character 40.0) 0.1))
              (fx (if (= x q)
                      (/ (/ 1.0 (+ dist q))
                         (- 1.0 (exp (* dist q))))
                      (/ (/ (- x q)
                            (+ (- 1.0 (exp (* -1.0 dist (- x q)))) q))
                         (- 1.0 (exp (* dist q)))))))
          (set! otm1 (- (+ (* 0.999 otm1) fx) itm1))
          (set! itm1 fx)
          otm1)))))

(bind-func ringmod_c
  "freq feedback:[0.0,1.0]"
  (lambda ()
    (let ((osc (osc_c 0.0)))
      (lambda (x:SAMPLE freq feedback)
        (+ (* (- 1.0 feedback) x)
           (* feedback (* x (osc freq 1.0))))))))

(bind-func hann_c
  "window of width samples - repeating every repeat samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64)
        (set! cnt (+ cnt 1))
        (* 0.5
           (- 1.0
              (cos (/ (* STWOPI (convert (% cnt width)))
                      (- (convert width) 1.0)))))))))

;; hann
(bind-func hann_mc_c
  (lambda ()
    (let ((h (hann_c))
          (mem 0.0))
      (lambda (chan:i64 width:i64)
        (if (= chan 0) (set! mem (h width)))
        mem))))


(bind-func hann_t_c
  "window of width samples - repeating every repeat samples"
  (lambda (offset)
    (lambda (time:i64 width:i64)
      ;;(set! cnt (+ cnt 1.0))
      (* 0.5
         (- 1.0
            (cos (/ (* STWOPI (convert (% (- time offset) width)))
                    (- (convert width) 1.0))))))))

;; hann with time
(bind-func hann_t_mc_c
  (lambda (offset)
    (let ((h (hann_t_c offset))
          (mem 0.0))
      (lambda (chan:i64 time:i64 width:i64)
        (if (= chan 0) (set! mem (h time width)))
        mem))))


(bind-func hann_e_c
  "window of 'width' samples, repeating every 'repeat' samples
   with an offset of 'offset' samples"
  (lambda ()
    (let ((cnt -1))
      (lambda (width:i64 offset:i64 repeat:i64)
        (if (> cnt repeat) (set! cnt -1))
        (set! cnt (+ cnt 1))
        (if (and (or (> cnt offset) (= offset 0))
                 (< cnt (+ width offset)))
            (* 0.5
               (- 1.0
                  (cos (/ (* STWOPI (convert (% (- cnt offset) width)))
                          (convert (- width 1))))))
            0.0)))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; envelope stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func linear_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (incr)
          (set! time (+ time incr))
          (+ (* m time) c))))))

(bind-func linear_mc_c
  (let ((time 0.0))
    (lambda (start:SAMPLE end:SAMPLE dur:SAMPLE)
      (let* ((m (/ (- end start) dur))
             (c (- end (* m dur))))
        (lambda (chan incr)
          (if (= chan 0)
              (set! time (+ time incr)))
          (+ (* m time) c))))))

(bind-func line_c
  (lambda (x1:SAMPLE y1:SAMPLE x2:SAMPLE y2)
    (let* ((zero:SAMPLE 0.0)
           (m (if (= (- x2 x1) 0.0)
                  zero
                  (/ (- y2 y1) (- x2 x1))))
           (c (- y2 (* m x2))))
      (lambda (time) (+ (* m time) c)))))

(bind-func envelope_segments
  (lambda (points:SAMPLE* num_of_points:i64)
    (let ((lines:[SAMPLE,SAMPLE]** (zalloc num_of_points))
          (k 0))
      (dotimes (k num_of_points)
        (let* ((idx (* k 2))
               (x1 (pref points (+ idx 0)))
               (y1 (pref points (+ idx 1)))
               (x2 (pref points (+ idx 2)))
               (y2 (pref points (+ idx 3))))
          (pset! lines k (line_c x1 y1 x2 y2))))
      lines)))

(bind-func envelope_c
  (lambda (points:SAMPLE* num_of_points)
    (let ((klines:[SAMPLE,SAMPLE]** (envelope_segments points num_of_points))
          (line_length num_of_points))
      (lambda (time)
        (let ((res -1.0)
              (k:i64 0))
          (dotimes (k num_of_points)
            (let ((line (pref klines k))
                  (time_point (pref points (* k 2))))
              (if (or (= time time_point)
                      (< time_point time))
                  (set! res (line time)))))
          res)))))


;; chan, gate, attack, decay, sustain, release
(bind-func adsr_c
  (lambda ()
    (let ((t:SAMPLE 0.0)
          (out:SAMPLE 0.0)
          (t1 0.0) (t2 0.0) (t3 0.0) (t4 0.0)
          (inc1 0.0) (inc2 0.0) (inc3 0.0))
      (lambda (chan:i64 g a d s r)
        (if (<> chan 0)
            out
            (begin
              (set! a (+ 1.0 (* a .001 SRs)))
              (set! d (+ 1.0 (* d .001 SRs)))
              (set! r (+ 1.0 (* r .001 SRs)))
              (if (< g 0.00001:f) (set! t 0.0) (inc t 1.0))
              (set! t1 a)
              (set! t2 (+ a d))
              (set! inc1 (/ 1.0 a))
              (set! inc2 (/ (- 1.0 s) d))
              (set! inc3 (if (or (< s .01) (> out s)) (/ 1.0 r) (/ s r)))
              (cond ((< t 0.001) (dec out inc3)) ;; release
                    ((> t (+ a d)) (set! out s)) ;; sustain
                    ((> t a) (dec out inc2)) ;; decay
                    ((> t 0.0) (inc out inc1)) ;; attack
                    (else (set! out 0.0)))
              (set! out (clamp out 0.0 1.0))
              out))))))


;; an accumulative adsr (random access not allowed! time must be linear).
(bind-func adsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (if (or (= atk_dur 0) (= dky_dur 0))
        (begin (set! dky_dur 0)
               (set! peak_amp sus_amp)))
    (let ((val:SAMPLE (if (> (+ atk_dur dky_dur) 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur dky_dur start_time))
          (t3 (+ atk_dur dky_dur sus_dur start_time))
          (t4 (+ atk_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t4) (set! val 0.0))
                  ((> time t3) (set! val (+ val inc3)))
                  ((> time t2) val) ;; sustain (don't do anything with val)
                  ((> time t1) (set! val (+ val inc2)))
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


;; has both hold and sustain
;; an accumulative ahdsr (random access not allowed! time must be linear).
(bind-func ahdsr_accum_c
  (lambda (start_time:i64 atk_dur:i64 hold_dur:i64 dky_dur:i64 sus_dur:i64 rel_dur:i64 peak_amp:SAMPLE sus_amp:SAMPLE)
    (let ((val:SAMPLE (if (> atk_dur 1) 0.0 peak_amp))
          (t1 (+ atk_dur start_time))
          (t2 (+ atk_dur hold_dur start_time))
          (t3 (+ atk_dur hold_dur dky_dur start_time))
          (t4 (+ atk_dur hold_dur dky_dur sus_dur start_time))
          (t5 (+ atk_dur hold_dur dky_dur sus_dur rel_dur start_time))
          (inc1:SAMPLE (/ peak_amp (convert atk_dur)))
          (inc2 (* -1.0 (/ (- peak_amp sus_amp) (convert dky_dur))))
          (inc3 (* -1.0 (/ sus_amp (convert rel_dur)))))
      (lambda (time:i64 chan:i64)
        (if (= chan 0)
            (cond ((> time t5) (set! val 0.0))
                  ((> time t4) (set! val (+ val inc3)))
                  ((> time t3) val) ;; sustain (don't do anything with val)
                  ((> time t2) (set! val (+ val inc2)))
                  ((> time t1) val) ;; hold don't do anything with val
                  ((> time start_time) (set! val (+ val inc1)))
                  (else (set! val 0.0))))
        val))))


;; a 'recorder' unit gen
(bind-func recorder
  (lambda (buf:AudioBuffer*)
    (let ((rec 0) ;; where rec is the number of 'frames' to record
          (prec 0) ;; previous value of rec
          (chans (AudioBuffer_channels buf))
          (chan 0)
          (lgth (* chans (AudioBuffer_frames buf)))
          (l1 (- lgth 1))
          (rhead 0)
          (phead 0)
          (pos 0)
          (t 0)
          (dat (AudioBuffer_ptr buf 0 0))
          (start 0) ;; loop start in frames
          (loop 0) ;; loop length in frames (negative plays backwards)
          (ploop 0)) ;; previous loop value
      (lambda (x)
        (if (<> prec rec) (set! rhead 0))
        (if (> rec 0)
            (begin (pset! dat rhead x)
                   (set! rhead (+ 1 rhead))
                   (if (= chan 0) (set! rec (- rec 1)))
                   (if (= rhead lgth) (set! rec 0)))
            (begin (set! rhead 0)))
        (if (<> ploop loop) (set! phead 0))
        (if (<> loop 0)
            (begin
              (set! pos (+ (* start chans) phead))
              (if (or (< pos 0) (> pos l1))
                  (set! x x) ;; (i.e. don't pref if bad index)
                  (set! x (pref dat pos)))
              (set! phead (+ phead (if (< loop 0) -1 1)))
              (if (= phead (* chans loop)) (set! phead 0))))
        ;; (if (= 0 (% t (* chans SR)))
        ;;     (println "rec:" rec "loop:" loop "start:" start "rhead:" rhead "phead:" phead))
        (set! chan (+ chan 1))
        (if (= chan chans) (set! chan 0))
        (set! t (+ t 1))
        (set! ploop loop)
        (set! prec rec)
        x))))



(define *xtmlib-audio_dsp-loaded* #t)

(impc:aot:insert-footer "xtmaudio_dsp")
