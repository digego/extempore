;; math.xtm -- extempore math library

;; Author: Andrew Sorensen, Ben Swift
;; Keywords: extempore

;;; Commentary:

;; This file contains math routines written in xtlang.  If you're
;; concerned about raw performance at all costs, it may be better to
;; dynamically link to BLAS or something like that.  However, because
;; everything is dynamically rebindable, there are also lots of
;; opportunities to do cool things with this library.

;; This file contains xtlang functions (and the odd data type) for
;; dealing with:
;; - vectors
;; - matrices
;; - complex numbers
;; - windowing

;;; Code:

;; lib-loading config

(if *impc:compiler:with-cache* (sys:load "libs/aot-cache/math.xtm" 'quiet))
(sys:load-preload-check 'math)
(define *xtmlib-math-loaded* #t)

(impc:aot:suppress-aot-do
 (sys:load "libs/base/base.xtm"))
(impc:aot:insert-forms (sys:load "libs/base/base.xtm" 'quiet))

(impc:aot:insert-header "xtmmath")
(impc:aot:import-ll "xtmmath")

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; "vector" data arrays ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; these functions deal raw (float/int) data in memory, and in general
;; just take a pointer and length arguments. It's up to the programmer
;; to make sure that the data is valid (and owned by your process). If
;; you try and do stuff with bad data, incorrect `length' arguments or
;; null pointers, you're gonna have a bad time.

;; Having said that, these things are all pretty fast & efficient, and
;; will also play really nicely with any C code you've roped in. There
;; are obviously even faster options (such as linking to BLAS or
;; LAPACK) than these but these ones are nice if you want to keep
;; everything in xtlang.

;; For more sophisticated Vector and Matrix types, see libs/core/math_ext.xtm

;; Naming conventions:

;; we use a "v" naming prefix convention for 1D vectors, and an "m"
;; previx for (row-major) matrices. Furthermore, if the function takes
;; just one vector then there's just 1 "v", but if it adds two vectors
;; together there will be 2 "v"s. Also, a couple of the functions use
;; "s" for scalar and "a" for angle

;; e.g.

;;    sum of all the elements in a vector:   vsum
;;
;;    sum of two vectors:                    vvsum
;;
;;    sum of two matrices:                   mmsum
;;
;;    rotate matrix around vector:           vmrotate

;; Remember, making sure the data pointer and length arguments make
;; sense is up to the programmer.

;; 1D sum, mean, median, mode

(bind-func vsum
  (lambda (buf:i32* len:i64)
    (let ((tot:i32 0) (i 0))
      (if (> len 3)
        (let ((chunks (/ len 4)) (vbuf:/4,i32/* (cast buf)) (vtot:/4,i32/* (salloc)))
          (vfill! vtot 0 0 0 0)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
              (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1) (vref totref 2) (vref totref 3))))
          (set! len (& len 3))
          (set! buf (pref-ptr buf (* i 4)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:i64* len:i64)
    (let ((tot 0) (i 0))
      (if (> len 1)
        (let ((chunks (/ len 2)) (vbuf:/2,i64/* (cast buf)) (vtot:/2,i64/* (salloc)))
          (vfill! vtot 0 0)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
                (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1))))
        (set! len (& len 1))
        (set! buf (pref-ptr buf (* i 2)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:float* len:i64)
    (let ((tot:float 0.) (i 0))
      (if (> len 3)
        (let ((chunks (/ len 4)) (vbuf:/4,float/* (cast buf)) (vtot:/4,float/* (salloc)))
          (vfill! vtot 0. 0. 0. 0.)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
              (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1) (vref totref 2) (vref totref 3))))
          (set! len (& len 3))
          (set! buf (pref-ptr buf (* i 4)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

(bind-func vsum
  (lambda (buf:double* len:i64)
    (let ((tot:double 0.) (i 0))
      (if (> len 1)
        (let ((chunks (/ len 2)) (vbuf:/2,double/* (cast buf)) (vtot:/2,double/* (salloc)))
          (vfill! vtot 0. 0.)
          (let ((totref (pref vtot 0)))
            (dotimes (i chunks)
                (set! totref (+ totref (pref-ptr vbuf i))))
            (set! tot (+ (vref totref 0) (vref totref 1))))
        (set! len (& len 1))
        (set! buf (pref-ptr buf (* i 2)))))
      (dotimes (i len)
        (set! tot (+ tot (pref buf i))))
      tot)))

;; even for ints, you probably want a floating-point answer for the
;; mean - these ones return doubles to minimize the chance of
;; precision error

(bind-func vmean
  (lambda (buf:i32* len:i64)
    (/ (i32tod (vsum buf len)) (convert len))))

(bind-func vmean
  (lambda (buf:i64* len:i64)
    (/ (i64tod (vsum buf len)) (convert len))))

(bind-func vmean
  (lambda (buf:float* len:i64)
    (/ (vsum buf len) (convert len))))

(bind-func vmean
  (lambda (buf:double* len:i64)
    (/ (vsum buf len) (convert len))))

(bind-func vmin
  (lambda (buf:i32* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:i64* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:float* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmin
  (lambda (buf:double* len:i64)
    (let ((min_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (< (pref buf i) min_val)
            (set! min_val (pref buf i))))
      min_val)))

(bind-func vmax
  (lambda (buf:i32* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:i64* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:float* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vmax
  (lambda (buf:double* len:i64)
    (let ((max_val (pref buf 0))
          (i 0))
      (dotimes (i len)
        (if (> (pref buf i) max_val)
            (set! max_val (pref buf i))))
      max_val)))

(bind-func vprint
  "print a packed i32* buffer"
  (lambda (buf:i32* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %. 6d " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed i32* buffer"
  (lambda (buf len)
    (vprint:[void,i32*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed i64* buffer"
  (lambda (buf:i64* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %. 6lld " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed i64* buffer"
  (lambda (buf len)
    (vprint:[void,i64*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed float* buffer"
  (lambda (buf:float* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %.4f " i (convert (pref buf i) double))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed float* buffer"
  (lambda (buf len)
    (vprint:[void,float*,i64,i64]* buf len 1)))

(bind-func vprint
  "print a packed double* buffer"
  (lambda (buf:double* len ncols)
    (doloop (i len)
      (printf "buf[%. 3lld] = %.4f " i (pref buf i))
      (if (= (% i ncols) (- ncols 1))
          (println)))
    (println)))

(bind-func vprint
  "print a packed double* buffer"
  (lambda (buf len)
    (vprint:[void,double*,i64,i64]* buf len 1)))

;; other naming options: sparse/dense, stride/unstride

(bind-func vcopy_unpack
  "take a packed float* buffer and copy it into a sparse representation"
  (lambda (src:float* dest:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-func vcopy_unpack
  "take a packed double* buffer and copy it into a sparse representation"
  (lambda (src:double* dest:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* stride i) j) (pref src (+ (* neighbors i) j)))))))

(bind-func vcopy_pack
  "take a sparse float* buffer and copy it into a packed representation"
  (lambda (src:float* dest:float* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-func vcopy_pack
  "take a sparse double* buffer and copy it into a packed representation"
  (lambda (src:double* dest:double* stride neighbors srclen)
    (doloop (i srclen)
      (doloop (j neighbors)
        (pset! dest (+ (* neighbors i) j) (pref src (+ (* stride i) j)))))))

(bind-func vcopy
  (lambda (src:double* len:i64 dest:double*)
    (doloop (i len)
      (pset! dest i (pref src i)))
    void))

(bind-func vcopy
  (lambda (src:float* len:i64 dest:float*)
    (doloop (i len)
      (pset! dest i (pref src i)))
    void))

(bind-func vcopy
  (lambda (src:i64* len:i64 dest:i64*)
    (doloop (i len)
      (pset! dest i (pref src i)))
    void))

(bind-func vcopy
  (lambda (src:i32* len:i64 dest:i32*)
    (doloop (i len)
      (pset! dest i (pref src i)))
    void))

(bind-func vnormalise
  (lambda (v1:float* len:i64 result:float*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v1 i) (pref v1 i)))))
      (set! mag (sqrt mag))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) mag)))
      void)))

(bind-func vnormalise
  (lambda (v1:double* len:i64 result:double*)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v1 i) (pref v1 i)))))
      (set! mag (sqrt mag))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) mag)))
      void)))

(bind-func vvdot
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64)
      (let ((res 0.0))
        (dotimes (i len)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

(bind-func vvdot
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64)
      (let ((res 0.0))
        (dotimes (i len)
          (set! res (+ res (* (pref v1 i) (pref v2 i)))))
        res))))

;; for 3d only SO NO LGTH
(bind-func vvcross
  (let ((i 0))
    (lambda (v1:float* v2:float* result:float*)
      (pfill! result
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))

;; for 3d only SO NO LGTH
(bind-func vvcross
  (let ((i 0))
    (lambda (v1:double* v2:double* result:double*)
      (pfill! result
              (- (* (pref v1 1) (pref v2 2))
                 (* (pref v2 1) (pref v1 2)))
              (- (* (pref v2 0) (pref v1 2))
                 (* (pref v1 0) (pref v2 2)))
              (- (* (pref v1 0) (pref v2 1))
                 (* (pref v2 0) (pref v1 1))))
      void)))

(bind-func vsmul
  (lambda (v1:float* s:float len:i64 result:float*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (* s (pref v1 i))))
      void)))

(bind-func vsmul
  (lambda (v1:double* s:double len:i64 result:double*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (* s (pref v1 i))))
      void)))

(bind-func vsdiv
  (lambda (v1:float* s:float len:i64 result:float*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) s)))
      void)))

(bind-func vsdiv
  (lambda (v1:double* s:double len:i64 result:double*)
    (let ((i 0))
      (dotimes (i len)
        (pset! result i (/ (pref v1 i) s)))
      void)))

(bind-func vvsum
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 result:float*)
      (dotimes (i len)
        (pset! result i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsum
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 result:double*)
      (dotimes (i len)
        (pset! result i (+ (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsub
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 result:float*)
      (dotimes (i len)
        (pset! result i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvsub
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 result:double*)
      (dotimes (i len)
        (pset! result i (- (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvmul
  (let ((i 0))
    (lambda (v1:float* v2:float* len:i64 v3:float*)
      (dotimes (i len)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-func vvmul
  (let ((i 0))
    (lambda (v1:double* v2:double* len:i64 v3:double*)
      (dotimes (i len)
        (pset! v3 i (* (pref v1 i) (pref v2 i))))
      void)))

(bind-func vmag
  (lambda (v:float* len:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))

(bind-func vmag
  (lambda (v:double* len:i64)
    (let ((mag 0.0)
          (i 0))
      (dotimes (i len)
        (set! mag (+ mag (* (pref v i) (pref v i)))))
      (sqrt mag))))

;; Quaternions

(bind-func vaquat
  "@param v - axis vector (3d)
@param angle - angle in radians
@param result - quaternion (4d vector xyzw) in which to store the result"
  (lambda (v:float* angle:float result:float*)
    (let ((m (vmag v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! result
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

(bind-func vaquat
  "@param v - axis vector (3d)
@param angle - angle in radians
@param result - quaternion (4d vector xyzw) in which to store the result"
  (lambda (v:double* angle:double result:double*)
    (let ((m (vmag v 3))
          (s (/ (sin (* 0.5 angle)) m)))
      (pfill! result
              (* (pref v 0) s) (* (pref v 1) s) (* (pref v 2) s)
              (cos (* 0.5 angle)))
      void)))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; "matrix" data arrays ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

;; helper macros for calculating row/column major indices

(bind-macro
  "helper macro for 2D column-major indexing"
  (colmaj_idx_2D r c nrows)
  `(+ (* ,c ,nrows) ,r))

(bind-macro
  "helper macro for 2D row-major indexing"
  (rowmaj_idx_2D r c ncols)
  `(+ ,c (* ,r ,ncols)))

(bind-func mprint
  (lambda (m:float* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      ;;(printf "[")
      (dotimes (i nrows)
        (printf "[")
        (dotimes (j ncols)
          (printf " %f" (ftod (pref m (rowmaj_idx_2D i j ncols)))))
        (printf " ]\n"))
      ;;(printf "]")
      void)))

(bind-func mprint
  (lambda (m:double* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      ;;(printf "[")
      (dotimes (i nrows)
        (printf "[")
        (dotimes (j ncols)
          (printf " %f" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]\n"))
      ;;(printf "]")
      void)))

(bind-func mprint
  (lambda (m:i32* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      ;;(printf "[")
      (dotimes (i nrows)
        (printf "[")
        (dotimes (j ncols)
          (printf " %d" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]\n"))
      ;;(printf "]")
      void)))

(bind-func mprint
  (lambda (m:i64* nrows:i64 ncols:i64)
    (let ((i 0) (j 0))
      ;;(printf "[")
      (dotimes (i nrows)
        (printf "[")
        (dotimes (j ncols)
          (printf " %lld" (pref m (rowmaj_idx_2D i j ncols))))
        (printf " ]\n"))
      ;;(printf "]")
      void)))

(bind-func mmmul
  (lambda (m1:float* r1:i64 c1:i64 m2:float* r2:i64 c2:i64 result:float*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null float*)))))

(bind-func mmmul
  (lambda (m1:double* r1:i64 c1:i64 m2:double* r2:i64 c2:i64 result:double*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0.0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null double*)))))

(bind-func mmmul
  (lambda (m1:i32* r1:i64 c1:i64 m2:i32* r2:i64 c2:i64 result:i32*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i32*)))))

(bind-func mmmul
  (lambda (m1:i64* r1:i64 c1:i64 m2:i64* r2:i64 c2:i64 result:i64*)
    (if (= c1 r2)
        (let ((r 0) (c 0) (k 0))
          (dotimes (r r1)
            (dotimes (c c2)
              (pset! result (+ c (* r c2)) 0)
              (dotimes (k c1)
                (pset! result (+ c (* r c2))
                       (+ (pref result (+ c (* r c2)))
                          (* (pref m1 (+ k (* r c1)))
                             (pref m2 (+ (* k c2) c))))))))
          result)
        (begin (printf "bad matrix multiplication [%lld,%lld]*[%lld,%lld]\n"
                       r1 c1 r2 c2)
               (cast null i64*)))))


;; optimized 4x4 matrix only!!!
;; NEED TO ALSO DO integers and doubles!!
(bind-func mmmul
  (lambda (m1:float* m2:float* result:float*)
    (let ((row1:/4,float/* (cast (pref-ptr m2 0)))
          (row2:/4,float/* (cast (pref-ptr m2 4)))
          (row3:/4,float/* (cast (pref-ptr m2 8)))
          (row4:/4,float/* (cast (pref-ptr m2 12)))
          (out:/4,float/* (cast result))
          (tmp:/4,float/* null) (i 0))
      (dotimes (i 4)
        (set! tmp (cast (pref-ptr m1 (* 4 i))))
        (let ((a (vshuffle tmp null 0 0 0 0))
              (b (vshuffle tmp null 1 1 1 1))
              (c (vshuffle tmp null 2 2 2 2))
              (d (vshuffle tmp null 3 3 3 3)))
          (pset! out i
                 (+ (+ (* a row1)
                       (* b row2))
                    (+ (* c row3)
                       (* d row4))))))
      result)))

(bind-func mtrans
  (lambda (m1:float* nrows:i64 ncols:i64 result:float*)
    (let ((i 0) (j 0))
      (dotimes (i nrows)
        (dotimes (j ncols)
          (pset! result (+ (* j ncols) i)
                 (pref m1 (+ (* i ncols) j)))))
      result)))

(bind-func mtranspose
  (lambda (m1:double* nrows:i64 ncols:i64 result:double*)
    (let ((i 0) (j 0))
      (dotimes (i nrows)
        (dotimes (j ncols)
          (pset! result (+ (* j ncols) i)
                 (pref m1 (+ (* i ncols) j)))))
      result)))

(bind-func mdeterminant
  "matrix determinant - matrix must be square (= nrows ncols)"
  (lambda (m1:float* nrows:i64)
    (if (= nrows 1) (pref m1 0)
        (let ((det:float 0.0) (s:float 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:float* (salloc (* nrows nrows))))
          (dotimes (c nrows)
            (set! m 0) (set! n 0)
            (dotimes (i nrows)
              (dotimes (j nrows)
                (pset! mb (+ (* i nrows) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- nrows 1)) n)
                             (pref m1 (+ (* i nrows) j)))
                      (if (< n (- nrows 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref m1 c)
                                     (mdeterminant mb (- nrows 1))))))
            (set! s (* -1.0 s)))
          det))))

(bind-func mdeterminant
  "matrix determinant - matrix must be square (= nrows ncols)"
  (lambda (m1:double* nrows:i64)
    (if (= nrows 1) (pref m1 0)
        (let ((det:double 0.0) (s:double 1.0)
              (c 0) (i 0) (j 0) (m 0) (n 0)
              (mb:double* (salloc (* nrows nrows))))
          (dotimes (c nrows)
            (set! m 0) (set! n 0)
            (dotimes (i nrows)
              (dotimes (j nrows)
                (pset! mb (+ (* i nrows) j) 0.0)
                (if (and (<> i 0) (<> j c))
                    (begin
                      (pset! mb (+ (* m (- nrows 1)) n)
                             (pref m1 (+ (* i nrows) j)))
                      (if (< n (- nrows 2))
                          (set! n (+ n 1))
                          (begin
                            (set! n 0)
                            (set! m (+ m 1)))))
                    (begin 1))))
            (set! det (+ det (* s (* (pref m1 c)
                                     (mdeterminant mb (- nrows 1))))))
            (set! s (* -1.0 s)))
          det))))

(bind-func minverse
  "matrix inverse - matrix must be square (= nrows ncols)"
  (lambda (m1:float* nrows:i64 result:float*)
    (let ((m2:float* (salloc (* nrows nrows)))
          (fac:float* (salloc (* nrows nrows)))
          (d:float 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q nrows)
        (dotimes (p nrows)
          (set! m 0)
          (set! n 0)
          (dotimes (i nrows)
            (dotimes (j nrows)
              (pset! m2 (+ (* i nrows) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! m2 (+ (* m (- nrows 1)) n)
                           (pref m1 (+ (* i nrows) j)))
                    (if (< n (- nrows 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q nrows) p)
                 (* (pow -1.0 (i64tof (+ q p)))
                    (mdeterminant m2 (- nrows 1))))))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! m2 (+ (* i nrows) j)
                 (pref fac (+ (* j nrows) i)))))
      (set! d (mdeterminant m1 nrows))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! result (+ (* i nrows) j)
                 (/ (pref m2 (+ (* i nrows) j)) d))))
      void)))

(bind-func minverse
  "matrix inverse - matrix must be square (= nrows ncols)"
  (lambda (m1:double* nrows:i64 result:double*)
    (let ((m2:double* (salloc (* nrows nrows)))
          (fac:double* (salloc (* nrows nrows)))
          (d:double 0.0)
          (i 0) (j 0) (m 0) (n 0) (q:i64 0) (p:i64 0))
      (dotimes (q nrows)
        (dotimes (p nrows)
          (set! m 0)
          (set! n 0)
          (dotimes (i nrows)
            (dotimes (j nrows)
              (pset! m2 (+ (* i nrows) j) 0.0)
              (if (and (<> i q) (<> j p))
                  (begin
                    (pset! m2 (+ (* m (- nrows 1)) n)
                           (pref m1 (+ (* i nrows) j)))
                    (if (< n (- nrows 2))
                        (set! n (+ n 1))
                        (begin
                          (set! n 0)
                          (set! m (+ m 1)))))
                  (begin 1))))
          (pset! fac (+ (* q nrows) p)
                 (* (pow -1.0 (i64tod (+ q p)))
                    (mdeterminant m2 (- nrows 1))))))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! m2 (+ (* i nrows) j)
                 (pref fac (+ (* j nrows) i)))))
      (set! d (mdeterminant m1 nrows))
      (dotimes (i nrows)
        (dotimes (j nrows)
          (pset! result (+ (* i nrows) j)
                 (/ (pref m2 (+ (* i nrows) j)) d))))
      void)))

(bind-func mcopy
  (lambda (src:float* row col dest:float*)
    (memcpy (cast dest i8*) (cast src i8*) (* row col 4))
    void))

(bind-func mcopy
  (lambda (src:double* row col dest:double*)
    (memcpy (cast dest i8*) (cast src i8*) (* row col 8))
    void))


(bind-func varotate
  "calcuate rotation matrix around vector

This function is particularly useful in graphics, so it's
column-major (the same as OpenGL)

@param axis - the unit vector around which you want to rotate
@param theta - the angle (radians) by which to rotate
@param result - a pointer to memory to store the calculated 4x4 rotation matrix in"
  (lambda (axis:float* theta:float result:float*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! result 0 (+ cost (* (* x x) mcost)))
      (pset! result 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! result 2 (- (* (* z x) mcost) (* y sint)))
      (pset! result 3 0.0)
      (pset! result 4 (- (* (* x y) mcost) (* z sint)))
      (pset! result 5 (+ cost (* (* y y) mcost)))
      (pset! result 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! result 7 0.0)
      (pset! result 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! result 9 (- (* (* y z) mcost) (* x sint)))
      (pset! result 10 (+ cost (* (* z z) mcost)))
      (pset! result 11 0.0)
      (pset! result 12 0.0)
      (pset! result 13 0.0)
      (pset! result 14 0.0)
      (pset! result 15 1.0)
      result)))

(bind-func varotate
  "calcuate rotation matrix around vector

This function is particularly useful in graphics, so it's
column-major (the same as OpenGL)

@param axis - the unit vector around which you want to rotate
@param theta - the angle (radians) by which to rotate
@param result - a pointer to memory to store the calculated 4x4 rotation matrix in"
  (lambda (axis:double* theta:double result:double*)
    (let ((x (pref axis 0))
          (y (pref axis 1))
          (z (pref axis 2))
          (cost (cos theta))
          (sint (sin theta))
          (mcost (- 1.0 cost)))
      (pset! result 0 (+ cost (* (* x x) mcost)))
      (pset! result 1 (+ (* (* y x) mcost) (* z sint)))
      (pset! result 2 (- (* (* z x) mcost) (* y sint)))
      (pset! result 3 0.0)
      (pset! result 4 (- (* (* x y) mcost) (* z sint)))
      (pset! result 5 (+ cost (* (* y y) mcost)))
      (pset! result 6 (+ (* (* z y) mcost) (* x sint)))
      (pset! result 7 0.0)
      (pset! result 8 (+ (* (* x z) mcost) (* y sint)))
      (pset! result 9 (- (* (* y z) mcost) (* x sint)))
      (pset! result 10 (+ cost (* (* z z) mcost)))
      (pset! result 11 0.0)
      (pset! result 12 0.0)
      (pset! result 13 0.0)
      (pset! result 14 0.0)
      (pset! result 15 1.0)
      result)))

;;;;;;;;;;;;;
;; sorting ;;
;;;;;;;;;;;;;

;; in-place quicksort

(bind-func vquicksort
  (lambda (buf:double* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:float* left right)
    (if (< left right)
        (let ((tmp 0.0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i64* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i32* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i16* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

(bind-func vquicksort
  (lambda (buf:i8* left right)
    (if (< left right)
        (let ((tmp 0)
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

;; this generic vquicksort works but is SUPER slow!
(bind-func vquicksort:[void,!a,i64,i64]*
  (lambda (buf left right)
    (if (< left right)
        (let ((tmp (convert 0))
              (_swap (lambdas (x y)
                              (set! tmp (pref buf x))
                              (pset! buf x (pref buf y))
                              (pset! buf y tmp)))
              (pivot (pref buf right))
              (index left)
              (i 0))
          (dotimes (i left (- right left))
            (if (or (< (pref buf i) pivot)
                    (= (pref buf i) pivot))
                (begin (_swap i index)
                       (set! index (+ index 1)))))
          (_swap right index)
          (vquicksort buf left (- index 1))
          (vquicksort buf (+ index 1) right))
        void)))

;; default vector sort - quicksort the whole buffer

(bind-func vsort
  (lambda (buf:double* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:float* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i64* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i32* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i16* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vsort
  (lambda (buf:i8* len)
    (vquicksort buf 0 (- len 1))
    buf))

(bind-func vmedian
  (lambda (buf:float* len:i64)
    (let ((h (vsort buf len))
          (idx (dtoi64 (ceil (/ (i64tod len) 2.0)))))
      (if (evenp len)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

(bind-func vmedian
  (lambda (buf:double* len:i64)
    (let ((h (vsort buf len))
          (idx (dtoi64 (ceil (/ (i64tod len) 2.0)))))
      (if (evenp len)
          (/ (+ (pref h idx) (pref h (- idx 1))) 2.0)
          (pref h idx)))))

;; naive mode needs to be replaced!
(bind-func vmode
  (lambda (buf:float* len:i64)
    (let ((h (vsort buf len))
          (p NaNf) (l 0) (largest 0) (j:float 0.0) (i 0))
      (dotimes (i len)
        (if (= p (pref buf i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref buf i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

(bind-func vmode
  (lambda (buf:double* len:i64)
    (let ((h (vsort buf len))
          (p NaN) (l 0) (largest 0) (j:double 0.0) (i 0))
      (dotimes (i len)
        (if (= p (pref buf i))
            (set! l (+ l 1)) ;; increment l
            (set! l 0))
        (set! p (pref buf i))
        (if (> l largest)
            (begin
              (set! largest l)
              (set! j p))))
      j)))

;;;;;;;;;;;;;;
;;
;; v sphere ;;
;;
;;;;;;;;;;;;;;

;; calculate the minimum bouning sphere
;; for a buf full of 'n' 3d vertices
;; stride will usually ee either 3 (if already 3d) or 4 if (4d)
;;
;; c and r are a |3,float|* and a |1,float|*
;; they are the centre and radius of the returned bounding sphere
;;
;; bouncing bouble algorithm - Tian Bo
(bind-func vsphere
  (lambda (buf:float* n:i64 stride:i64 c:float* r:float*)
    (let ((centre:float* buf) ;; start guess with 1st vertex
          (radius 0.0001:f)
          (pos:float* null)
          (diff:float* (salloc 3))
          (tmp:float* (salloc 3))
          (len:float 0.0)
          (alpha:float 0.0)
          (alphasq:float 0.0)
          (i 0) (j 0))
      (dotimes (i 2)
        (dotimes (j n)
          (set! pos (pref-ptr buf (* stride j)))
          (vvsub pos centre 3 diff)
          (set! len (vmag diff 3))
          (if (> len radius)
              (begin
                (set! alpha (/ len radius))
                (set! alphasq (* alpha alpha))
                (set! radius (* 0.5:f (+ alpha (/ 1.0 alpha)) radius))
                ;; (set! centre (+ (* 0.5:f (+ 1 (/ 1.0 alphasq)) centre)
                ;;                 (* (- 1 (/ 1.0 alphasq)) pos)))))))
                (vsmul centre (* 0.5 (+ 1.0 (/ 1.0 alphasq))) 3 centre)
                (vsmul pos (- 1.0 (/ 1.0 alphasq)) 3 tmp)
                (vvsum centre tmp 3 centre)))))
      (dotimes (j n)
        (set! pos (pref-ptr buf (* stride j)))
        (vvsub pos centre 3 diff)
        (set! len (vmag diff 3))
        (if (> len radius)
            (begin
              (set! radius (/ (+ radius len) 2.0))
              ;; (set! centre (+ centre (/ (- len radius) (* len diff)))))))
              (vsmul diff len 3 diff)
              (vsdiv diff (- len radius) 3 diff)
              (vvsum centre diff 3 centre))))
      (vcopy centre 3 c) ;; set c
      (pset! r 0 radius) ;; set r
      void)))

;;;;;;;;;; COMPLEX NUMBERS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; xtlang's complex number types and helper functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Complexd (double versions)

(bind-type Complexd <double,double> (printer? . #f))

(bind-func Cpxd
  (lambda (re im)
    (let ((c:Complexd* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func print
  "specialised print function for Complexd"
  (lambda (c:Complexd)
    (printf "%.2f%+.2fi"
            (tref c 0)
            (tref c 1))
    void))

(bind-func print
  "specialised print function for Complexd*"
  (lambda (c:Complexd*)
    (if (null? c)
        (printf "<Complexd 0x0>")
        (printf "%.2f%+.2fi"
                (tref c 0)
                (tref c 1)))
    void))

(bind-func toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (tref c 0)
               (tref c 1))
      (Str str))))

(bind-func toString
  "specialised toString function for Complexd"
  (lambda (c:Complexd*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexd 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (tref c 0)
                   (tref c 1)))
      (Str str))))

(bind-func xtm_addition
  (lambda (a:Complexd b:Complexd)
    (Cpxd (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func xtm_addition
  (lambda (a:Complexd b:double)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func xtm_addition
  (lambda (b:double a:Complexd)
    (Cpxd (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complex_addition_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (+ (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (+ (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-func xtm_subtraction
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func xtm_subtraction
  (lambda (a:Complexd b:double)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:double a:Complexd)
    (Cpxd (- (tref a 0) b)
          (tref a 1))))

(bind-func Complex_subtraction_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (- (tref (pref-ptr a i) 0)
                  (tref (pref-ptr b i) 0)))
        (tset! (pref-ptr c i) 1
               (- (tref (pref-ptr a i) 1)
                  (tref (pref-ptr b i) 1))))
      void)))

(bind-func xtm_multiplication
  (lambda (a:Complexd b:Complexd)
    (Cpxd (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func xtm_multiplication
  (lambda (a:Complexd b:double)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func xtm_multiplication
  (lambda (b:double a:Complexd)
    (Cpxd (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complex_multiplication_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr c i) 0
               (- (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 0))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 1
               (+ (* (tref (pref-ptr a i) 0)
                     (tref (pref-ptr b i) 1))
                  (* (tref (pref-ptr a i) 1)
                     (tref (pref-ptr b i) 0)))))
      void)))

(bind-func xtm_division
  (lambda (a:Complexd b:Complexd)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (a:Complexd b:double)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (b:double a:Complexd)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxd (/ i j)
            (/ k j)))))

(bind-func Complex_division_bybuf
  (lambda (a:Complexd* b:Complexd* c:Complexd* len)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i len)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))

(bind-func Complex_mag
  (lambda (a:Complexd)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))

(bind-func Complex_phase
  (lambda (a:Complexd)
    (atan2 (tref a 1) (tref a 0))))

(bind-func Complex_conj
  (lambda (a:Complexd)
    (Cpxd (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-func cart_to_pol
  (lambda (a:Complexd)
    (Cpxd (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan2 (tref a 1) (tref a 0)))))

(bind-func cart_to_pol
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexd* n:i64)
    (let ((temp:double 0.0))
      (doloop (i n)
        (set! temp (sqrt (+ (* (tref (pref a i) 0) (tref (pref a i) 0))
                            (* (tref (pref a i) 1) (tref (pref a i) 1)))))
        (tset! (pref-ptr a i) 1
               (atan2 (tref (pref a i) 1) (tref (pref a i) 0)))
        (tset! (pref-ptr a i) 0 temp))
      void)))

(bind-func pol_to_cart
  (lambda (a:Complexd)
    (Cpxd (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func pol_to_cart
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexd* n:i64)
    (let ((temp:double 0.0))
      (doloop (i n)
        (set! temp (* (tref (pref a i) 0) (cos (tref (pref a i) 1))))
        (tset! (pref-ptr a i) 1
               (* (tref (pref a i) 0) (sin (tref (pref a i) 1))))
        (tset! (pref-ptr a i) 0 temp))
      void)))

;; Complexf (float versions)

(bind-type Complexf <float,float> (printer? . #f))

(bind-func Cpxf
  (lambda (re im)
    (let ((c:Complexf* (salloc)))
      (tset! c 0 re)
      (tset! c 1 im)
      (pref c 0))))

(bind-func print
  "specialised print function for Complexf"
  (lambda (c:Complexf)
    (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1)))
    void))

(bind-func print
  "specialised print function for Complexf*"
  (lambda (c:Complexf*)
    (if (null? c)
        (printf "<Complexf 0x0>")
        (printf "%.2f%+.2fi"
            (ftod (tref c 0))
            (ftod (tref c 1))))
    void))

(bind-func toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf)
    (let ((str:i8* (salloc 256)))
      (sprintf str "%.2f%+.2fi"
               (ftod (tref c 0))
               (ftod (tref c 1)))
      (Str str))))

(bind-func toString
  "specialised toString function for Complexf"
  (lambda (c:Complexf*)
    (let ((str:i8* (salloc 256)))
      (if (null? c)
          (sprintf str "<Complexf 0x0>")
          (sprintf str "%.2f%+.2fi"
                   (ftod (tref c 0))
                   (ftod (tref c 1))))
      (Str str))))

(bind-func xtm_addition
  (lambda (a:Complexf b:Complexf)
    (Cpxf (+ (tref a 0) (tref b 0))
          (+ (tref a 1) (tref b 1)))))

(bind-func xtm_addition
  (lambda (a:Complexf b:float)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func xtm_addition
  (lambda (b:float a:Complexf)
    (Cpxf (+ (tref a 0) b)
          (tref a 1))))

(bind-func Complex_addition_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
    (if (evenp len)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ len 2))
            (pset! cc k (+ (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i len)
            (tset! (pref-ptr c i) 0
                   (+ (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (+ (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))


(bind-func xtm_subtraction
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (tref a 0) (tref b 0))
          (- (tref a 1) (tref b 1)))))

(bind-func xtm_subtraction
  (lambda (a:Complexf b:float)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func xtm_subtraction
  (lambda (b:float a:Complexf)
    (Cpxf (- (tref a 0) b)
          (tref a 1))))

(bind-func Complex_subtraction_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
    (if (evenp len)
        (let ((aa:/4,float/* (cast a))
              (bb:/4,float/* (cast b))
              (cc:/4,float/* (cast c))
              (k 0))
          (dotimes (k (/ len 2))
            (pset! cc k (- (pref-ptr aa k) (pref-ptr bb k)))
            void))
        (let ((i 0))
          (dotimes (i len)
            (tset! (pref-ptr c i) 0
                   (- (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0)))
            (tset! (pref-ptr c i) 1
                   (- (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
          void))))

(bind-func xtm_multiplication
  (lambda (a:Complexf b:Complexf)
    (Cpxf (- (* (tref a 0) (tref b 0))
             (* (tref a 1) (tref b 1)))
          (+ (* (tref a 0) (tref b 1))
             (* (tref a 1) (tref b 0))))))

(bind-func xtm_multiplication
  (lambda (a:Complexf b:float)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func xtm_multiplication
  (lambda (b:float a:Complexf)
    (Cpxf (- (* (tref a 0) b)
             (tref a 1))
          (+ (tref a 0)
             (* (tref a 1) b)))))

(bind-func Complex_multiplication_bybuf
  (let ((dd:/4,float/* (alloc)))
    (vfill! dd -1.0 1.0 -1.0 1.0)
    (lambda (a:Complexf* b:Complexf* c:Complexf* len:i64)
      (if (evenp len)
          (let ((j 0)
                (aa:/4,float/* (cast a))
                (bb:/4,float/* (cast b))
                (cc:/4,float/* (cast c)))
            (dotimes (j (/ len 2))
              (pset! cc j
                     (+ (* (vshuffle (pref-ptr aa j) null 0 0 2 2)
                           (vshuffle (pref-ptr bb j) null 0 1 2 3))
                        (* (* (vshuffle (pref-ptr aa j) null 1 1 3 3)
                              (vshuffle (pref-ptr bb j) null 1 0 3 2))
                           dd))))
            void)
          (let ((i 0))
            (dotimes (i len)
              (tset! (pref-ptr c i) 0
                     (- (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 0))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 1))))
              (tset! (pref-ptr c i) 1
                     (+ (* (tref (pref-ptr a i) 0)
                           (tref (pref-ptr b i) 1))
                        (* (tref (pref-ptr a i) 1)
                           (tref (pref-ptr b i) 0)))))
            void)))))

(bind-func xtm_division
  (lambda (a:Complexf b:Complexf)
    (let ((i (+ (* (tref a 0) (tref b 0))
                (* (tref a 1) (tref b 1))))
          (j (+ (* (tref b 0) (tref b 0))
                (* (tref b 1) (tref b 1))))
          (k (- (* (tref a 1) (tref b 0))
                (* (tref a 0) (tref b 1)))))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (a:Complexf b:float)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func xtm_division
  (lambda (b:float a:Complexf)
    (let ((i (+ (* (tref a 0) b)
                (tref a 1)))
          (j (* b b))
          (k (- (* (tref a 1) b)
                (tref a 0) )))
      (Cpxf (/ i j)
            (/ k j)))))

(bind-func Complex_division_bybuf
  (lambda (a:Complexf* b:Complexf* c:Complexf* len)
    (let ((i 0) (j 0.0) (k 0.0) (l 0.0))
      (dotimes (i len)
        (set! j (+ (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! k (+ (* (tref (pref-ptr b i) 0)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr b i) 1)
                      (tref (pref-ptr b i) 1))))
        (set! l (- (* (tref (pref-ptr a i) 1)
                      (tref (pref-ptr b i) 0))
                   (* (tref (pref-ptr a i) 0)
                      (tref (pref-ptr b i) 1))))
        (tset! (pref-ptr c i) 0 (/ j k))
        (tset! (pref-ptr c i) 1 (/ l k)))
      void)))

(bind-func Complex_mag
  (lambda (a:Complexf)
    (sqrt (+ (* (tref a 0) (tref a 0))
             (* (tref a 1) (tref a 1))))))

(bind-func Complex_phase
  (lambda (a:Complexf)
    (atan2 (tref a 1) (tref a 0))))

(bind-func Complex_conj
  (lambda (a:Complexf)
    (Cpxf (tref a 0)
          (* -1.0 (tref a 0)))))

(bind-func cart_to_pol
  (lambda (a:Complexf)
    (Cpxf (sqrt (+ (* (tref a 0) (tref a 0))
                   (* (tref a 1) (tref a 1))))
          (atan2 (tref a 1) (tref a 0)))))

(bind-func cart_to_pol
  "transform a whole buffer cart->pol in-place"
  (lambda (a:Complexf* n:i64)
    (let ((temp:float 0.0))
      (doloop (i n)
        (set! temp (sqrt (+ (* (tref (pref a i) 0) (tref (pref a i) 0))
                            (* (tref (pref a i) 1) (tref (pref a i) 1)))))
        (tset! (pref-ptr a i) 1
               (atan2 (tref (pref a i) 1) (tref (pref a i) 0)))
        (tset! (pref-ptr a i) 0 temp))
      void)))

(bind-func pol_to_cart
  (lambda (a:Complexf)
    (Cpxf (* (tref a 0) (cos (tref a 1)))
          (* (tref a 0) (sin (tref a 1))))))

(bind-func pol_to_cart
  "transform a whole buffer pol->cart in-place"
  (lambda (a:Complexf* n:i64)
    (let ((temp:float 0.0))
      (doloop (i n)
        (set! temp (* (tref (pref a i) 0) (cos (tref (pref a i) 1))))
        (tset! (pref-ptr a i) 1
               (* (tref (pref a i) 0) (sin (tref (pref a i) 1))))
        (tset! (pref-ptr a i) 0 temp))
      void)))

;; "bufferize" whole buffers of real & complex values (take two real
;; buffers with real & imaginary components, fill buffer of Complex
;; values)

(bind-func Complex_bufferize
  (lambda (re:float* im:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complex_bufferize
  (lambda (re:float* com:Complexf* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

(bind-func Complex_bufferize
  (lambda (re:double* im:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 (pref im i))))
    void))

(bind-func Complex_bufferize
  (lambda (re:double* com:Complexd* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (tset! (pref-ptr com i) 0 (pref re i))
        (tset! (pref-ptr com i) 1 0.0)))
    void))

;; do the opposite (take buffer of Complex, fill two real buffers with
;; real & imaginary components)

(bind-func Complex_unbufferize
  (lambda (com:Complexf* re:float* im:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0))
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexf* re:float* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexd* re:double* im:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0))
        (pset! im i (tref (pref-ptr com i) 1))))
    void))

(bind-func Complex_unbufferize
  (lambda (com:Complexd* re:double* len:i64)
    (let ((i 0))
      (dotimes (i len)
        (pset! re i (tref (pref-ptr com i) 0)) ))
    void))

;;;;;;;;;;;;;;;
;; histogram ;;
;;;;;;;;;;;;;;;

;; currently uses floating-point values, i32 counts

(bind-type HistBin <float,float> (printer? . #f)
  "a histogram bin: <lower,count>")

(bind-func print
  "specialised print function for HistBin*"
  (lambda (histbin:HistBin*)
    (if (null? histbin)
        (printf "<HistBin 0x0>")
        (printf "<HistBin %p minval=%f count=%f>"
                histbin
                (convert (tref histbin 0) double)
                (convert (tref histbin 1) double)))
    void))

(bind-func toString
  "specialised toString function for HistBin*"
  (lambda (histbin:HistBin*)
    (let ((str:i8* (salloc 256)))
      (if (null? histbin)
          (sprintf str "<HistBin 0x0>")

          (sprintf str
                   "<HistBin %p minval=%f count=%f>"
                   histbin
                   (convert (tref histbin 0) double)
                   (convert (tref histbin 1) double)))
      (Str str))))


(bind-func histogram
  (lambda (hist:HistBin* buf:float* len lower upper nbins)
    (let ((current_bin:HistBin* null)
          (range (- upper lower)))
      (if (not (> range 0.))
          (begin
            (println "Error in histogram: range (- upper lower) must be greater than 0.0")
            null)
          (begin
            ;; setup the bins
            (doloop (i nbins)
              (tset! (pref-ptr hist i)
                     0
                     (+ lower (* (convert i) (/ range (convert nbins)))))
              (tset! (pref-ptr hist i)
                     1
                     0.))
            (doloop (i len)
              (set! current_bin
                    ;; use "mod nbins" to make sure it always goes
                    ;; into a valid slot in memory
                    (pref-ptr hist (% (convert (* (convert nbins float) (/ (- (pref buf i) lower) range)) i64) nbins)))
              (tset! current_bin 1 (+ (tref current_bin 1) 1.0)))
            hist)))))

(bind-func histogram
  "like the full version, but use the min and max values in the buffer as upper and lower"
  (lambda (hist:HistBin* buf:float* len nbins)
    (let ((lower 0.0)
          (upper 0.0))
      ;; find max/min values
      (doloop (i len)
        (if (< (pref buf i) lower)
            (set! lower (pref buf i)))
        (if (> (pref buf i) upper)
            (set! upper (pref buf i))))
      (histogram:[HistBin*,HistBin*,float*,i64,float,float,i64]* hist buf len lower upper nbins))))


;;;;;;;;;;
;; Misc ;;
;;;;;;;;;;

;; assorted maths-y functions.  not really sure where these should go

;; DFT/IDFT (for teaching purposes)

;; real in -> complex out
(bind-func dft
  (lambda (in:double* out:Complexd* len)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod len)))
      (memset (cast out i8*) 0 (convert (* len 16)))
      (dotimes (k len)
        (set! cpx (pref-ptr out k))
        (dotimes (n len)
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (tset! cpx 0
                 (+ (tref cpx 0)
                    (* (pref in n) (cos tmp))))
          (tset! cpx 1
                 (- (tref cpx 1)
                    (* (pref in n) (sin tmp))))))
      void)))

;; complex in -> real out
(bind-func idft
  (lambda (in:Complexd* out:double* len)
    (let ((n:i64 0) (k:i64 0) (tmp 0.0) (cpx:Complexd* null) (N (i64tod len)))
      (dotimes (n len)
        (pset! out n 0.0)
        (dotimes (k len)
          (set! cpx (pref-ptr in k))
          (set! tmp (* (i64tod (* k n)) (/ TWOPI N)))
          (pset! out n
                 (+ (pref out n)
                    (- (* (tref cpx 0) (cos tmp))
                       (* (tref cpx 1) (sin tmp))))))
        ;; scale
        (pset! out n (/ (pref out n) N)))
      void)))

;; gaussian random number X ~ N(0,1)
;; algorithm by Marsaglia http://c-faq.com/lib/gaussian.html

(bind-func gaussr
  (let ((phase 0))
    (lambda ()
      (let ((u1:double (random))
            (u2:double (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (gaussr)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))

(bind-func gaussr
  (let ((phase 0))
    (lambda ()
      (let ((u1:float (random))
            (u2:float (random))
            (v1 (- (* 2.0 u1) 1.0))
            (v2 (- (* 2.0 u2) 1.0))
            (s (+ (* v1 v1) (* v2 v2))))
        (if (= phase 0)
            (if (or (> s 1.0) (= s 0.0) (= s 1.0))
                (gaussr)
                (* v1 (sqrt (/ (* -2.0 (log s)) s))))
            (begin (set! phase (- 1 phase))
                   (* v2 (sqrt (/ (* -2.0 (log s)) s)))))))))


;; where t is time between [0.0 - 1.0]
(bind-func hanning
  (lambda (t)
    (- 0.5 (* 0.5
              (cos (* TWOPI t))))))

(bind-func window_hanning
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPI (i64tod i))
                                        (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hanning
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.5 (* 0.5 (cos (/ (* TWOPIf (i64tof i))
                                        (i64tof (- window_length 1)))))))))
      void)))


;; where to is [0.0 - 1.0]
(bind-func hamming
  (lambda (t)
    (- 0.54 (* 0.46 (cos (* TWOPI t))))))

(bind-func window_hamming
  (let ((i:i64 0))
    (lambda (window_buffer:double* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPI (i64tod i))
                                          (i64tod (- window_length 1)))))))))
      void)))

(bind-func window_hamming
  (let ((i:i64 0))
    (lambda (window_buffer:float* window_length)
      (dotimes (i window_length)
        (pset! window_buffer i
               (* (pref window_buffer i)
                  (- 0.54 (* 0.46 (cos (/ (* TWOPIf (i64tof i))
                                          (i64tof (- window_length 1)))))))))
      void)))

;; string hashing functions

(bind-func djb2
  (lambda (str:i8*)
    (let ((hash:i64 5381)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (+ (<< hash 5) hash (convert (pref str i)))))
      hash)))

(bind-func sdbm
  (lambda (str:i8*)
    (let ((hash:i64 0)
          (len (strlen str))
          (i 0))
      (dotimes (i len)
        (set! hash (- (+ (convert (pref str i)) (<< hash 6) (<< hash 16)) hash)))
      hash)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; numeric integration and differentiation
;;
;; numeric diff with floats is error prone (precision)
;; try to stick to double precision and convert results
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; numeric differentation
(bind-func ndiff
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (f (+ x (/ 1e-5 2.0)))
          (f (- x (/ 1e-5 2.0))))
       1e-5)))

(bind-func ndiff
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (f (+ x (/ dx 2.0)))
          (f (- x (/ dx 2.0))))
       dx)))

;; same as above (i.e. central)
(bind-func ndifferentiate
  "numeric differentiation - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (f (+ x (/ 1e-5 2.0)))
          (f (- x (/ 1e-5 2.0))))
       1e-5)))

(bind-func ndiff_extrapolated
  "numeric differentiation - extrapolated diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (* 8.0 (- (f (+ x (/ dx 4.0)))
                    (f (- x (/ dx 4.0)))))
          (- (f (+ x (/ dx 2.0)))
             (f (- x (/ dx 2.0)))))
       (* 3.0 dx))))

(bind-func ndiff2
  "numeric differentiation (2nd deriv) - central diff"
  (lambda (f:[double,double]* x)
    (/ (- (- (f (+ x 1e-5)) (f x))
          (- (f x) (f (- x 1e-5))))
       (* 1e-5 1e-5))))

(bind-func ndiff2
  "numeric differentiation (2nd deriv) - central diff"
  (lambda (f:[double,double]* x dx)
    (/ (- (- (f (+ x dx)) (f x))
          (- (f x) (f (- x dx))))
       (* dx dx))))

(bind-func nintegrate
  "integrate using Simpsons rule - N must be odd"
  (lambda (f:[double,double]* xmin xmax N)
    (let ((sumeven:double 0.0)
          (sumodd:double 0.0)
          (x 0.0) (n 0)
          (interval (/ (- xmax xmin) (i64tod (- N 1)))))
      (set! n 2)
      (while (< n N)
        (set! x (+ xmin (* interval (i64tod (- n 1)))))
        (set! sumodd (+ sumodd (f x)))
        (set! n (+ n 2)))
      (set! n 3)
      (while (< n N)
        (set! x (+ xmin (* interval (i64tod (- n 1)))))
        (set! sumeven (+ sumeven (f x)))
        (set! n (+ n 2)))
      (* (+ (* sumeven 2.0) (* sumodd 4.0)
            (f xmin) (f xmax))
         (/ interval 3.0)))))

(bind-func nintegrate
  "integrate using Simpsons rule - N must be odd"
  (lambda (f:[double,double]* xmin xmax)
    (nintegrate:[double,[double,double]*,double,double,i64]* f xmin xmax 501)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; perlin noise function ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

(bind-func fade
  (lambda (t)
    (* t t t (+ (* t (- (* t 6.) 15.)) 10.))))

(bind-func grad
  (lambda (hash:i64 x:double y:double z:double)
    (set! hash (bitwise-and hash 15))
    (cond
     ((= hash 0) (+ x y))
     ((= hash 1) (+ (- 0. x) y))
     ((= hash 2) (- x y))
     ((= hash 3) (- (- 0. x) y))
     ((= hash 4) (+ x z))
     ((= hash 5) (+ (- 0. x) z))
     ((= hash 6) (- x z))
     ((= hash 7) (- (- 0. x) z))
     ((= hash 8) (+ y z))
     ((= hash 9) (+ (- 0. y) z))
     ((= hash 10) (- y z))
     ((= hash 11) (- (- 0. y) z))
     ((= hash 12) (+ y x))
     ((= hash 13) (+ (- 0. y) z))
     ((= hash 14) (- y x))
     ((= hash 15) (- (- 0. y) z))
     (else 0.))))

(bind-func lerp
  (lambda (a:double b:double x:double)
    (+ a (* x (- b a)))))

(bind-func perlin
  (let ((permutation:|256,i64|* (alloc))
        (p:|512,i64|* (alloc))
        (i:i64 0)
        (xi:i64 0)
        (yi:i64 0)
        (zi:i64 0)
        (xf:double 0.)
        (yf:double 0.)
        (zf:double 0.)
        (u:double 0.)
        (v:double 0.)
        (w:double 0.)
        (aaa:i64 0)
        (aba:i64 0)
        (aab:i64 0)
        (abb:i64 0)
        (baa:i64 0)
        (bba:i64 0)
        (bab:i64 0)
        (bbb:i64 0)
        (x1:double 0.)
        (x2:double 0.)
        (y1:double 0.)
        (y2:double 0.))
    (afill! permutation 151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180)
    (dotimes (i 0 256)
      (aset! p i (aref permutation i))
      (aset! p (+ i 256) (aref permutation i)))
    (lambda (x:double y:double z:double)
      (set! xi (bitwise-and (dtoi64 x) 255))
      (set! yi (bitwise-and (dtoi64 y) 255))
      (set! zi (bitwise-and (dtoi64 z) 255))
      (set! xf (- x (i64tod (dtoi64 x))))
      (set! yf (- y (i64tod (dtoi64 y))))
      (set! zf (- z (i64tod (dtoi64 z))))
      (set! u (fade xf))
      (set! v (fade yf))
      (set! w (fade zf))

      (set! aaa (aref p (+ (aref p (+ (aref p xi) yi)) zi)))
      (set! aba (aref p (+ (aref p (+ (aref p xi) (+ yi 1))) zi)))
      (set! aab (aref p (+ (aref p (+ (aref p xi) yi)) (+ zi 1))))
      (set! abb (aref p (+ (aref p (+ (aref p xi) (+ yi 1))) (+ zi 1))))
      (set! baa (aref p (+ (aref p (+ (aref p (+ xi 1)) yi)) zi)))
      (set! bba (aref p (+ (aref p (+ (aref p (+ xi 1)) (+ yi 1))) zi)))
      (set! bab (aref p (+ (aref p (+ (aref p (+ xi 1)) yi)) (+ zi 1))))
      (set! bbb (aref p (+ (aref p (+ (aref p (+ xi 1)) (+ yi 1))) (+ zi 1))))

      (set! x1 (lerp (grad aaa xf yf zf) (grad baa (- xf 1.) yf zf) u))
      (set! x2 (lerp (grad aba xf (- yf 1.) zf) (grad bba (- xf 1.) (- yf 1.) zf) u))
      (set! y1 (lerp x1 x2 v))

      (set! x1 (lerp (grad aab xf yf (- zf 1.)) (grad bab (- xf 1.) yf (- zf 1.)) u))
      (set! x2 (lerp (grad abb xf (- yf 1.) (- zf 1.)) (grad bbb (- xf 1.) (- yf 1.) (- zf 1.)) u))
      (set! y2 (lerp x1 x2 v))

      (/ (+ (lerp y1 y2 w) 1.) 2.))))


;; end libs/core/math.xtm

(define *xtmlib-math-loaded* #t)
(impc:aot:insert-footer "xtmmath")
