;; lib-loading config
(sys:load "libs/aot-cache/kinect2.xtm" 'quiet)
(sys:load-preload-check 'kinect2)
(define *xtmlib-kinect2-loaded* #t)

(impc:aot:insert-header "xtmkinect2")

;; set up the current dylib name and path (for AOT compilation)
(bind-dylib libkinect2
  (cond ((string=? (sys:platform) "Windows")
         "xtmkinect.dll")))

(bind-alias TrackingState i32)
(bind-alias JointType i32)
(bind-alias XTM_Kinect_Sensor i8)

(bind-val JointType_SpineBase i32 0)
(bind-val JointType_SpineMid i32 1)
(bind-val JointType_Neck i32 2)
(bind-val JointType_Head i32 3)
(bind-val JointType_ShoulderLeft i32 4)
(bind-val JointType_ElbowLeft i32 5)
(bind-val JointType_WristLeft i32 6)
(bind-val JointType_HandLeft i32 7)
(bind-val JointType_ShoulderRight i32 8)
(bind-val JointType_ElbowRight i32 9)
(bind-val JointType_WristRight i32 10)
(bind-val JointType_HandRight i32 11)
(bind-val JointType_HipLeft i32 12)
(bind-val JointType_KneeLeft i32 13)
(bind-val JointType_AnkleLeft i32 14)
(bind-val JointType_FootLeft i32 15)
(bind-val JointType_HipRight i32 16)
(bind-val JointType_KneeRight i32 17)
(bind-val JointType_AnkleRight i32 18)
(bind-val JointType_FootRight i32 19)
(bind-val JointType_SpineShoulder i32 20)
(bind-val JointType_HandTipLeft i32 21)
(bind-val JointType_ThumbLeft i32 22)
(bind-val JointType_HandTipRight i32 23)
(bind-val JointType_ThumbRight i32 24)
(bind-val JointType_Count i32 25)

(bind-val	TrackingState_NotTracked i32 0)
(bind-val	TrackingState_Inferred i32 1)
(bind-val	TrackingState_Tracked i32 2)

(bind-val HandState_Unknown i32 0)
(bind-val HandState_NotTracked i32 1)
(bind-val HandState_Open i32 2)
(bind-val HandState_Closed i32 3)
(bind-val HandState_Lasso i32 4)

(bind-type CameraSpacePoint <float,float,float>)
(bind-func get_x:[float,CameraSpacePoint*]* (lambda (obj) (tref obj 0)))
(bind-func get_x:[float,CameraSpacePoint]* (lambda (obj) (tref obj 0)))
(bind-func get_y:[float,CameraSpacePoint*]* (lambda (obj) (tref obj 1)))
(bind-func get_y:[float,CameraSpacePoint]* (lambda (obj) (tref obj 1)))
(bind-func get_z:[float,CameraSpacePoint*]* (lambda (obj) (tref obj 2)))
(bind-func get_z:[float,CameraSpacePoint]* (lambda (obj) (tref obj 2)))

(bind-type Joint <JointType,CameraSpacePoint,TrackingState> (printer? . #f))
(bind-func get_type:[JointType,Joint*]* (lambda (obj) (tref obj 0)))
(bind-func get_position:[CameraSpacePoint,Joint*]* (lambda (obj) (tref obj 1)))
(bind-func get_state:[TrackingState,Joint*]* (lambda (obj) (tref obj 2)))

(bind-type XTM_Point2d <float,float>)
(bind-func get_x:[float,XTM_Point2d]* (lambda (obj) (tref obj 0)))
(bind-func get_y:[float,XTM_Point2d]* (lambda (obj) (tref obj 1)))
(bind-func get_x:[float,XTM_Point2d*]* (lambda (obj) (tref obj 0)))
(bind-func get_y:[float,XTM_Point2d*]* (lambda (obj) (tref obj 1)))

(bind-func print:[void,Joint*]*
  (lambda (x)
    (if (null? x)
        (begin (printf "") void)
        (let ((type (tref x 0))
              (pos (tref x 1))
              (state (tref x 2))
              (track (cond ((= state TrackingState_NotTracked) "NotTracked")
                           ((= state TrackingState_Inferred) "Inferred")
                           ((= state TrackingState_Tracked) "Tracked")
                           (else "Err")))
              (name (cond ((= type JointType_SpineBase) "SpineBase")
                          ((= type JointType_SpineMid) "SpineMid")
                          ((= type JointType_Neck) "Neck   ")
                          ((= type JointType_Head) "Head   ")
                          ((= type JointType_ShoulderLeft) "ShoulderL")
                          ((= type JointType_ElbowLeft) "ElbowLeft")
                          ((= type JointType_WristLeft) "WristLeft")
                          ((= type JointType_HandLeft) "HandLeft")
                          ((= type JointType_ShoulderRight) "ShoulderR")
                          ((= type JointType_ElbowRight) "ElbowRight")
                          ((= type JointType_WristRight) "WristRight")
                          ((= type JointType_HandRight) "HandRight")
                          ((= type JointType_HipLeft) "HipLeft ")
                          ((= type JointType_KneeLeft) "KneeLeft")
                          ((= type JointType_AnkleLeft) "AnkleLeft")
                          ((= type JointType_FootLeft) "FootLeft")
                          ((= type JointType_HipRight) "HipRight")
                          ((= type JointType_KneeRight) "KneeRight")
                          ((= type JointType_AnkleRight) "AnkleRight")
                          ((= type JointType_FootRight) "FootRight")
                          ((= type JointType_SpineShoulder) "SpineShoulder")
                          ((= type JointType_HandTipLeft) "HandTipLeft")
                          ((= type JointType_ThumbLeft) "ThumbLeft")
                          ((= type JointType_HandTipRight) "HandTipRight")
                          ((= type JointType_ThumbRight) "ThumbRight")
                          (else "Err"))))
          (printout "<" (String name) "\t[" (tref pos 0) "," (tref pos 1) "," (tref pos 2) "]\t" (String track) ">")
          void))))

;; XTM_Kinect_Sensor* owned by library
(bind-lib libkinect2 kinect_init_sensor [XTM_Kinect_Sensor*]*)
(bind-lib libkinect2 kinect_close_sensor [i32,XTM_Kinect_Sensor*]*)
;; ids, joints, hands, points, width, height
(bind-lib libkinect2 kinect_get_joints [i32,XTM_Kinect_Sensor*,i64*,Joint*,i32*,XTM_Point2d*,i32,i32]*)
(bind-lib libkinect2 kinect_body_to_screen [void,XTM_Kinect_Sensor*,CameraSpacePoint*,XTM_Point2d*,i32,i32]*)

(bind-func kinect_start
  (lambda ()
    (kinect_init_sensor)))

(bind-func kinect_stop
  (lambda (sensor)
    (kinect_close_sensor sensor)))

(bind-func kinect_update_body
  (let ((hands:i32* (alloc (* 6 2)))
        (ids:i64* (alloc 6))
        (points:XTM_Point2d* (alloc (* 6 25)))
        (joints:Joint* (alloc (* 6 25))))
    (lambda (sensor width height)
      (let ((res (kinect_get_joints sensor ids joints hands points width height)))
        (if (< res 0)
            (println "NO DATA AVAILABLE"))
        void))))

(bind-func kinect_get_tracked:[i64*]*
  (lambda ()
    (kinect_update_body.ids)))

(bind-func kinect_get_joint_pos
  (lambda (id:i64 joint_id:i32 pos:CameraSpacePoint*)
    (let ((joints:Joint* (kinect_update_body.joints))
          (ids:i64* (kinect_update_body.ids))
          (i:i64 0) (idx:i64 -1))
      (dotimes (i 6) (if (= (pref ids i) id) (set! idx i)))
      (if (> idx 0)
          (begin (tfill! pos 0.0 0.0 0.0) #f)
          (let ((j (pref-ptr joints (+ (* idx 25) (convert joint_id))))
                (p (tref j 1)))
            (tfill! pos (tref p 0) (tref p 1) (tref p 2))
            #t)))))

(bind-func kinect_get_joint_xy
  (lambda (id:i64 joint_id:i32 xy:XTM_Point2d*)
    (let ((points:XTM_Point2d* (kinect_update_body.points))
          (ids:i64* (kinect_update_body.ids))
          (i:i64 0) (idx:i64 -1))
      (dotimes (i 6) (if (= (pref ids i) id) (set! idx i)))
      (if (< idx 0)
          (begin (tfill! xy 0.0 0.0) #f)
          (let ((p (pref-ptr points (+ (* idx 25) (convert joint_id)))))
            (tfill! xy (tref p 0) (tref p 1))
            #t)))))

(bind-func kinect_get_joint_xy
  (lambda (id:i64 joint_id:i32)
    (let ((points:XTM_Point2d* (kinect_update_body.points))
          (ids:i64* (kinect_update_body.ids))
          (i:i64 0) (idx:i64 -1))
      (dotimes (i 6) (if (= (pref ids i) id) (set! idx i)))
      (if (< idx 0)
          (tuple 0.0:f 0.0:f)
          (let ((p (pref-ptr points (+ (* idx 25) (convert joint_id)))))
            (tuple (tref p 0) (tref p 1)))))))

;; returns the left hands state (i.e. HandState_*)
(bind-func kinect_get_hand_left
  (lambda (id:i64)
    (let ((hands:i32* (kinect_update_body.hands))
          (ids:i64* (kinect_update_body.ids))
          (i:i64 0) (idx:i64 -1))
      (dotimes (i 6) (if (= (pref ids i) id) (set! idx i)))
      (if (< idx 0)
          -1
          (pref hands (* 2 idx))))))

;; returns the left hands state (i.e. HandState_*)
(bind-func kinect_get_hand_right
  (lambda (id:i64)
    (let ((hands:i32* (kinect_update_body.hands))
          (ids:i64* (kinect_update_body.ids))
          (i:i64 0) (idx:i64 -1))
      (dotimes (i 6) (if (= (pref ids i) id) (set! idx i)))
      (if (< idx 0)
          -1
          (pref hands (+ 1 (* 2 idx)))))))

(bind-func kinect_print_body
  (lambda ()
    (let ((hands:i32* (kinect_update_body.hands))
          (ids:i64* (kinect_update_body.ids))
          (points:XTM_Point2d* (kinect_update_body.points))
          (joints:Joint* (kinect_update_body.joints)))
      (doloop (k 6)
        (if (>= (pref ids k) 0)
            (begin
              (println "----------------------------")
              (println "Body ID: " (pref ids k))
              (println "Body Idx: " k)
              (println "left-hand:" (pref hands (+ 0 (* k 2))))
              (println "right-hand:" (pref hands (+ 1 (* k 2))))
              (doloop (i 25)
                (println "Joint:" (pref-ptr joints (+ (* k 25) i))
                         "\tx:" (tref (pref-ptr points (+ (* k 25) i)) 0)
                         "y:" (tref (pref-ptr points (+ (* k 25) i)) 1))))))
      void)))


(impc:aot:insert-footer "xtmkinect2")
(define *xtmlib-kinect2-loaded* #t)

;; (bind-func send-skeleton-osc
;;   (let ((skel-frame:NUI_SKELETON_FRAME* (zalloc))
;;  (pos:double* (zalloc 100))
;;  (buf:i8* (halloc 8000))
;;  (data:float* (halloc (* 20 4)))) ;; 20 Vector4's
;;     (lambda (addy port)
;;       (kinect_get_skeleton 100 skel-frame)
;;       (kinect-smooth-params skel-frame 0.5 0.5 0.5 0.05 0.04)
;;       (let ((skels:|6,NUI_SKELETON_DATA|* (tref-ptr skel-frame 5))
;;      (i 0))
;;  (dotimes (i 6)
;;    (let ((skel-data:NUI_SKELETON_DATA* (aref-ptr skels i))
;;    (state (tref skel-data 0))
;;    (position:Vector4* (tref-ptr skel-data 4))
;;    (positions:|20,Vector4|* (tref-ptr skel-data 5)))
;;      (if (= state 2)
;;    (let ((address:i8* (salloc 15))
;;          (types ",b")
;;          (addressl 16)
;;          (typesl 4)
;;          (datal 320)
;;          (length (+ addressl typesl 4 datal)))
;;      ;(printf "sending %d:%f\n" i (ftod (tref (aref-ptr positions 0) 0)))
;;      ;; setup address
;;      (memset address 0 15)
;;      (strcat address "/kinect/skel/")
;;      (strcat address (extitoa i))
;;      ;; clear message
;;      (memset buf 0 (+ length 1))
;;      ;; copy address into message
;;      (strcpy (pref-ptr buf 0) address)
;;      ;; copy types into message
;;      (strcpy (pref-ptr buf addressl) types)
;;      ;; copy blob size into message
;;      (pset! (bitcast (pref-ptr buf (+ addressl typesl)) i32*)
;;       0 (i64toi32 datal))
;;      ;; copy blob data into message
;;      (memcpy (pref-ptr buf (+ addressl typesl 4))
;;        (bitcast positions i8*) datal)
;;      ;; send message
;;      (llvm_send_udp addy port buf (i64toi32 length))))))))))


;; (bind-val _skeletons_ |6,|20,Vector4||* (* 6 (* 20 4 4)))
;; (bind-val _skeletons-alive_ |6,i1|)

;; (bind-func receive-skel-osc
;;   (lambda (address:i8* types:i8* args:i8* size:i32)
;;     (if (= (strncmp address "/kinect/skel" 12) 0)
;;  (let ((skel-num (- (i8toi64 (pref address 13)) 48))
;;        (positions (pref-ptr args 4))
;;        (posarg (bitcast positions |20,Vector4|*))
;;        (i 0) (k 0)
;;        (skel (aref-ptr _skeletons_ skel-num)))
;;    ;(printf "receiving %d:%f\n" skel-num (ftod (tref (aref-ptr posarg 0) 0)))
;;    (dotimes (i 20)
;;      (let ((v4p (aref-ptr posarg i)))
;;        (tfill! (aref-ptr skel i) (tref v4p 0) (tref v4p 1) (tref v4p 2) (tref v4p 3))))
;;    ;(memcpy skel positions (* 20 4 4))
;;    (aset! _skeletons-alive_ skel-num 1)
;;    1)
;;  1)))
