

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>xtlang type reference &mdash; Extempore 0.6.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Extempore 0.6.1 documentation" href="index.html"/>
        <link rel="next" title="Generics" href="generics.html"/>
        <link rel="prev" title="Concurrency" href="concurrency.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Extempore
          

          
          </a>

          
            
            
              <div class="version">
                0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="editor-support.html">Text editors</a></li>
<li class="toctree-l1"><a class="reference internal" href="about-this-documentation.html">About this documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Key concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">The Extempore philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="caas.html">Interacting with the Extempore Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="time.html">Time in Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-xtlang-interop.html">C-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheme-xtlang-interop.html">Scheme-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="concurrency.html">Concurrency</a></li>
</ul>
<p class="caption"><span class="caption-text">xtlang&#8212;the Extempore language</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">xtlang type reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#primitive-types">Primitive types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integers">Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floats">Floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-types">Pointer types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#aggregate-types">Aggregate types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tuples">Tuples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays">Arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vectors">Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#closure-type">Closure type</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#strings">Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#named-types">Named types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-inferencing-in-the-xtlang-compiler">Type inferencing in the xtlang compiler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scheme-and-xtlang-types">Scheme and xtlang types</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="generics.html">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management in Extempore</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials &amp; Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="audio-signal-processing.html">Audio signal processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="making-an-instrument.html">Making an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="note-level-music.html">Playing an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampler.html">Loading and using a sampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphics.html">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="impromptu-users.html">Extempore for Impromptu users</a></li>
</ul>
<p class="caption"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting-help.html">Getting Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Extempore</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>xtlang type reference</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/type-system.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xtlang-type-reference">
<h1>xtlang type reference<a class="headerlink" href="#xtlang-type-reference" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This was once a blog post&#8212;corrections/improvements
welcome.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s not really possible to explain detour into some <a class="reference internal" href="memory.html"><em>memory
stuff</em></a> as well, so we&#8217;ll cover some of that as well. For
more info on how xtlang fits into the big picture of
Extempore, see <a class="reference internal" href="philosophy.html"><em>The Extempore philosophy</em></a>.</p>
</div>
<p>xtlang, the &#8216;systems language&#8217; component of Extempore, has a rich
static type system.</p>
<p>xtlang code is statically typed&#8212;the types are determined at compile
time, and the compiler checks that the types of the arguments to a
function match the type signature of that closure. If they don&#8217;t match,
you get a compile error, and a (hopefully) helpful message about where
things are going wrong and what needs to be fixed.</p>
<p>The base types will be familiar to those who are used to working with C,
although there are a couple of slight differences. Just like C, the
types are all low level in the sense that they represent a particular
bit pattern in memory&#8212;there&#8217;s no boxing and unboxing going on.</p>
<p>In xtlang, type annotations (a type definition following a colon in the
source code) are used to tell the compiler about the types of variables.
The compiler will infer incomplete type information (such as the size of
int and float literals), but will never silently coerce the types. If
there&#8217;s a problem, the compiler will complain and you have to fix it,
either with an explicit coercion or by changing the structure of the
code.</p>
<p>The examples here use a lot of these type annotations. This is for
clarity&#8212;some of these aren&#8217;t strictly necessary (<em>as I&#8217;ll show
later</em>) because the type inferencing compiler will figure out the
types of variables in many cases.</p>
<div class="section" id="primitive-types">
<h2>Primitive types<a class="headerlink" href="#primitive-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="integers">
<span id="int-type-doc"></span><h3>Integers<a class="headerlink" href="#integers" title="Permalink to this headline">¶</a></h3>
<img alt="_images/int-examples.png" src="_images/int-examples.png" />
<p>Extempore supports signed integers of various different sizes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">i1</span></code> (boolean)</li>
<li><code class="docutils literal"><span class="pre">i8</span></code> (char)</li>
<li><code class="docutils literal"><span class="pre">i32</span></code></li>
<li><code class="docutils literal"><span class="pre">i64</span></code> (default)</li>
</ul>
<p>A couple of gotchas:</p>
<ul class="simple">
<li>the default integer size is <code class="docutils literal"><span class="pre">i64</span></code>, so int literals in the code will
be interpreted as <code class="docutils literal"><span class="pre">i64</span></code>, <em>unless</em> the function signature suggests
otherwise e.g. if the signature is <code class="docutils literal"><span class="pre">[double,i32]*</span></code>, then a (single)
int literal argument will be read as an <code class="docutils literal"><span class="pre">i32</span></code>.</li>
<li>there is no <code class="docutils literal"><span class="pre">char</span></code> type, only <code class="docutils literal"><span class="pre">i8</span></code>. In xtlang, strings are
null-terminated char arrays/pointers with the signature <code class="docutils literal"><span class="pre">i8*</span></code>.</li>
</ul>
</div>
<div class="section" id="floats">
<span id="float-type-doc"></span><h3>Floats<a class="headerlink" href="#floats" title="Permalink to this headline">¶</a></h3>
<img alt="_images/float-examples.png" src="_images/float-examples.png" />
<p>There are two sizes of floating point number:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">float</span></code> (32 bit)</li>
<li><code class="docutils literal"><span class="pre">double</span></code> (64 bit, default)</li>
</ul>
<p>Float literals in xtlang code (e.g. <code class="docutils literal"><span class="pre">4.2</span></code>) are interpreted as
<code class="docutils literal"><span class="pre">double</span></code> unless the type signatures suggest otherwise (as is the case
with <code class="docutils literal"><span class="pre">i64</span></code> int literals).</p>
</div>
<div class="section" id="pointer-types">
<span id="pointer-type-doc"></span><h3>Pointer types<a class="headerlink" href="#pointer-types" title="Permalink to this headline">¶</a></h3>
<img alt="_images/pointer-examples.png" src="_images/pointer-examples.png" />
<p>xtlang supports <a class="reference external" href="http://en.wikipedia.org/wiki/Pointer_(computer_programming)">pointers</a> to any type, in fact some types (such as
closures) are almost always handled by reference (that is, through
pointers). Pointers in xtlang are indicated by the usual <code class="docutils literal"><span class="pre">*</span></code> syntax.</p>
<p>Examples:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">double*</span></code>: a pointer to a double</li>
<li><code class="docutils literal"><span class="pre">i64**</span></code>: a pointer to a pointer to a 64-bit integer</li>
</ul>
<p>Pointers represent <em>memory addresses</em>, and the use of pointers in
xtlang is one of the key differences between xtlang and Scheme (and
indeed between xtlang and any high-level language). C programmers will
be (intimately) familiar with the concept of pointers, and xtlang&#8217;s
pointers are the same (you can <code class="docutils literal"><span class="pre">printf</span></code> them with <code class="docutils literal"><span class="pre">%p</span></code>) For
others, though, a more in-depth explanation of the concept of pointers
can be found <a class="reference internal" href="memory.html#pointer-doc"><span>here</span></a>. If you&#8217;ve never encountered
pointers before then I suggest you check it out before continuing.</p>
<p>The way to allocate (and store a pointer to) memory is through a call to
one of xtlang&#8217;s &#8216;alloc&#8217; functions. Extempore has 3 different alloc
functions: <code class="docutils literal"><span class="pre">salloc</span></code>, <code class="docutils literal"><span class="pre">halloc</span></code> and <code class="docutils literal"><span class="pre">zalloc</span></code>. They all allocate a
chunk of memory and return a pointer type, but they differ in <em>where</em>
that memory is allocated from. In order of how &#8216;long-lived&#8217; the memory
will be: <code class="docutils literal"><span class="pre">salloc</span></code> allocates memory on the stack (shortest-lived),
<code class="docutils literal"><span class="pre">zalloc</span></code> allocates memory from the current zone, and <code class="docutils literal"><span class="pre">halloc</span></code>
allocates memory from the heap (longest-lived). Finally, <code class="docutils literal"><span class="pre">alloc</span></code> is an
alias for <code class="docutils literal"><span class="pre">zalloc</span></code>.</p>
<p>More detail about the Extempore&#8217;s memory architecture (and the
difference between <code class="docutils literal"><span class="pre">salloc</span></code>, <code class="docutils literal"><span class="pre">halloc</span></code> and <code class="docutils literal"><span class="pre">zalloc</span></code>) can be found
in <a class="reference internal" href="memory.html"><em>Memory management in Extempore</em></a>. For
now, though, we&#8217;ll just use <code class="docutils literal"><span class="pre">zalloc</span></code>, which allocates memory from the
current zone, which for these examples will work fine.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">ptr_test</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span><span class="kt">:double*</span> <span class="p">(</span><span class="nf">zalloc</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;address = %p\n&quot;</span> <span class="nv">a</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">ptr_test</span><span class="p">)</span> <span class="c1">;; prints &quot;address = 0x1163bc030&quot;</span>
</pre></div>
</div>
<p>In this example, the function closure <code class="docutils literal"><span class="pre">ptr_test</span></code> takes no arguments,
binds a pointer to a <code class="docutils literal"><span class="pre">double</span></code> (<code class="docutils literal"><span class="pre">a</span></code>) in the <code class="docutils literal"><span class="pre">let</span></code>, and then prints
the memory address that <code class="docutils literal"><span class="pre">a</span></code> points to.</p>
<p>Pointers aren&#8217;t very interesting, though, if you can&#8217;t read and write to
the values they point to. That&#8217;s where the xtlang functions <code class="docutils literal"><span class="pre">pref</span></code>,
<code class="docutils literal"><span class="pre">pset!</span></code> and <code class="docutils literal"><span class="pre">pref-ptr</span></code> come in.</p>
<p>Unlike in C, <code class="docutils literal"><span class="pre">*</span></code> is not a dereference <em>operator</em>, it&#8217;s just the syntax
for the specifying pointer types. Instead, there&#8217;s a function <code class="docutils literal"><span class="pre">pref</span></code>
for <em>dereferencing</em> a pointer (getting the value the pointer &#8216;points&#8217;
to). <code class="docutils literal"><span class="pre">pref</span></code> takes two arguments: the pointer, and an (integer) offset.
So if <code class="docutils literal"><span class="pre">a</span></code> is a pointer to a chunk of 10 <code class="docutils literal"><span class="pre">double</span></code> in memory (such as
returned by <code class="docutils literal"><span class="pre">zalloc</span></code>, for instance), then <code class="docutils literal"><span class="pre">(pref</span> <span class="pre">a</span> <span class="pre">2)</span></code> in xtlang is
the value of the third (<code class="docutils literal"><span class="pre">pref</span></code> uses 0-based indexing) of those
<code class="docutils literal"><span class="pre">double</span></code> (equivalent to <code class="docutils literal"><span class="pre">a[2]</span></code> in C).</p>
<p>To <em>set</em> the value associated with a pointer, there&#8217;s <code class="docutils literal"><span class="pre">pset!</span></code>. Like
<code class="docutils literal"><span class="pre">pref</span></code>, <code class="docutils literal"><span class="pre">pset!</span></code> takes a pointer as the first argument, and offset as
the second argument, but it also takes an additional third argument&#8212;the
value to set into that memory location. This must be of the appropriate
type: so if the pointer is to a double, then the value passed to
<code class="docutils literal"><span class="pre">pset!</span></code> must also be a double.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">ptr_test2</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span><span class="kt">:double*</span> <span class="p">(</span><span class="nf">zalloc</span><span class="p">)))</span> <span class="c1">; allocate some memory for a double, bind</span>
                                        <span class="c1">; the pointer to the symbol a</span>
      <span class="p">(</span><span class="nf">pset!</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mf">2.4</span><span class="p">)</span>          <span class="c1">; set the value at index 0 (of a) to 2.4</span>
      <span class="p">(</span><span class="nf">pref</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">))))</span>            <span class="c1">; read the value at index 0 of a</span>

<span class="p">(</span><span class="nv">ptr_test2</span><span class="p">)</span> <span class="c1">;; returns 2.400000</span>
</pre></div>
</div>
<p>In this example the closure <code class="docutils literal"><span class="pre">ptr_test2</span></code> takes no arguments, allocates
some memory, sets a value into that memory location, then reads it back
out. Notice that for both <code class="docutils literal"><span class="pre">pref</span></code> and <code class="docutils literal"><span class="pre">pset!</span></code> the index argument was
zero&#8212;this means that we were storing and reading the value directly into
the pointer (memory location) bound to <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>This is important (and useful) because the call to <code class="docutils literal"><span class="pre">zalloc</span></code> can
(optionally) take an integer argument. So, if we know we&#8217;re going to
store 4 doubles, we can do this:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">ptr_test3</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span><span class="kt">:double*</span> <span class="p">(</span><span class="nf">zalloc</span> <span class="mi">4</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">pfill!</span> <span class="nv">a</span> <span class="mf">1.2</span> <span class="mf">3.4</span> <span class="mf">4.2</span> <span class="mf">1.1</span><span class="p">)</span> <span class="c1">; fill the pointer a with values</span>
      <span class="p">(</span><span class="nf">pref</span> <span class="nv">a</span> <span class="mi">2</span><span class="p">))))</span>              <span class="c1">; read the value at index 2 of a</span>

<span class="p">(</span><span class="nv">ptr_test3</span><span class="p">)</span> <span class="c1">;; returns 4.200000</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">(zalloc</span> <span class="pre">4)</span></code> will allocate enough memory for <code class="docutils literal"><span class="pre">4</span></code> doubles (4 doubles
with 64 bytes/double means 256 bytes all up).</p>
<p>There&#8217;s one new function in this example: <code class="docutils literal"><span class="pre">pfill!</span></code>, which is helpful
for filling multiple values into a byte array. Using <code class="docutils literal"><span class="pre">pfill!</span></code> is
exactly the same as calling <code class="docutils literal"><span class="pre">pset!</span></code> 4 times with an index of 0, 1, 2,
and 3, but it&#8217;s a bit more concise.</p>
<p>Finally, one more useful way to fill values into a chunk of memory is
using a loop.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">ptr_test4</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span><span class="kt">:double*</span> <span class="p">(</span><span class="nf">zalloc</span> <span class="mi">10</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">i</span><span class="kt">:i64</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="k">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">pset!</span> <span class="nv">a</span> <span class="nv">i</span> <span class="p">(</span><span class="nf">i64tod</span> <span class="nv">i</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">pref</span> <span class="nv">a</span> <span class="mi">6</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">ptr_test4</span><span class="p">)</span> <span class="c1">;; returns 6.000000</span>
</pre></div>
</div>
<p>There&#8217;s one more useful function for working with pointers:
<code class="docutils literal"><span class="pre">pref-ptr</span></code>. Where <code class="docutils literal"><span class="pre">(pref</span> <span class="pre">a</span> <span class="pre">3)</span></code> returns the <em>value</em> of the 4th
element of the chunk of memory pointed to by <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">(pref-ptr</span> <span class="pre">a</span> <span class="pre">3)</span></code>
returns a <em>pointer</em> to that value. This also implies that
<code class="docutils literal"><span class="pre">(pref</span> <span class="pre">(pref-ptr</span> <span class="pre">a</span>
<span class="pre">n))</span></code> is the same as <code class="docutils literal"><span class="pre">(pref</span> <span class="pre">(pref-ptr</span> <span class="pre">a</span> <span class="pre">0)</span> <span class="pre">n)</span></code> for any integer <em>n</em>.</p>
<p>One final note for C programmers: there is no <code class="docutils literal"><span class="pre">void*</span></code> in xtlang, use
an <code class="docutils literal"><span class="pre">i8*</span></code> instead.</p>
</div>
</div>
<div class="section" id="aggregate-types">
<h2>Aggregate types<a class="headerlink" href="#aggregate-types" title="Permalink to this headline">¶</a></h2>
<p>After that brief detour into xtlang&#8217;s direct memory access (which is
kindof inevitable when you&#8217;re dealing with pointer types), let&#8217;s get
into the aggregate types (types which contain other types). There are
three base aggregate types in xtlang: tuples, arrays and vectors. In
each case, these names mean pretty much the same thing they do in other
languages.</p>
<p>Normally the best way to work with these types is through pointers (that
is, by reference). Allocating memory for a tuples, array or vector is
done through a call to one of the alloc functions, as in the example
above with pointers to primitive types.</p>
<div class="section" id="tuples">
<span id="tuple-type-doc"></span><h3>Tuples<a class="headerlink" href="#tuples" title="Permalink to this headline">¶</a></h3>
<p>An n-tuple is a fixed-length structure with n elements. <em>Different</em>
tuples can have different lengths (different values of <em>n</em>), but a
particular tuple always has the same fixed length.</p>
<p>The elements of a tuple need not be of the same type, tuples are
heterogeneous. Each element can be any type that the xtlang compiler
recognises, including another tuple&#8212;turtles all the way down!</p>
<p>The syntax for declaring and identifying tuples in xtlang is the use of
angle brackets (<code class="docutils literal"><span class="pre">&lt;&gt;</span></code>). Tuples in xtlang are analogous to C structs,
except without named members. This is a bit of a pain at the moment, but
named structs are high on the Extempore to-do list at the moment and
will be added in a future release.</p>
<p>Examples:</p>
<img alt="_images/tuple-examples.png" src="_images/tuple-examples.png" />
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;double,i32&gt;*</span></code> is a pointer to a 2-tuple: the first element is a
<code class="docutils literal"><span class="pre">double</span></code> and the second element is an <code class="docutils literal"><span class="pre">i32</span></code></li>
<li><code class="docutils literal"><span class="pre">&lt;i64*,i64,float**&gt;*</span></code> is a pointer to a 3 tuple: the first element
is a pointer to an <code class="docutils literal"><span class="pre">i64</span></code>, the second is an <code class="docutils literal"><span class="pre">i64</span></code>, and the third
is a <em>pointer to a pointer to</em> a <code class="docutils literal"><span class="pre">float</span></code></li>
<li><code class="docutils literal"><span class="pre">&lt;double,&lt;i64*&gt;*&gt;*</span></code> is a pointer to a 2-tuple, with a <code class="docutils literal"><span class="pre">double</span></code> as
the first element and a pointer to a 1-tuple as the second</li>
</ul>
<p>Like <code class="docutils literal"><span class="pre">pref</span></code> for pointers, getting an element from a tuple involves a
function called <code class="docutils literal"><span class="pre">tref</span></code>. So, to get element number <code class="docutils literal"><span class="pre">i</span></code> from a tuple
pointer <code class="docutils literal"><span class="pre">t</span></code>, use <code class="docutils literal"><span class="pre">(tref</span> <span class="pre">t</span> <span class="pre">i)</span></code>. If <code class="docutils literal"><span class="pre">tref</span></code> doesn&#8217;t have an <em>i</em> th
element, the compiler will complain (as it should). The first argument
to <code class="docutils literal"><span class="pre">tref</span></code> should be a pointer to a tuple rather than the tuple
itself, and this holds for the array and vector equivalents as well.
In fact, you&#8217;ll almost never work with aggregate data types directly,
instead getting pointers to them via calls to the memory allocation
functions. The exception to this rule is if you&#8217;re binding to a C
library and you need to pass structs around by value (rather than by
reference).</p>
<p>Similarly, <code class="docutils literal"><span class="pre">tset!</span></code> is used to set a value into a tuple. Again, the
compiler will check that the value being set is of the right type, and
will throw a compile error if there&#8217;s a problem.</p>
<p>There&#8217;s <code class="docutils literal"><span class="pre">tfill!</span></code> for filling values into tuples. Again, it&#8217;s up to you
to make sure that you pass values of the correct types into the
different slots. But if you don&#8217;t, at least you get a compile time error
rather than weird behaviour at runtime.</p>
<p>And finally, if you want a <em>reference to</em> (rather than the value of) an
element in the tuple, use <code class="docutils literal"><span class="pre">tref-ptr</span></code> instead of <code class="docutils literal"><span class="pre">tref</span></code>.</p>
<p>All of these tuple ref/ref-ptr/set!/fill! functions have the same syntax
as the pointer (i.e. <code class="docutils literal"><span class="pre">pref</span></code>) versions. There are also equivalent
functions for arrays (with an <code class="docutils literal"><span class="pre">a</span></code> prefix) and vectors (<code class="docutils literal"><span class="pre">v</span></code> prefix).
This consistency makes it easier to remember how to work with and access
the different types. And because xtlang is strongly typed, even if you
do get confused and try to <code class="docutils literal"><span class="pre">tset!</span></code> an array type the compiler will
catch the error for you.</p>
</div>
<div class="section" id="arrays">
<span id="array-type-doc"></span><h3>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h3>
<p>An array in xtlang is a fixed length array of elements of a single type
(like a static C array). The array type signature specifies the length
of the array, the type of the array elements, and is closed off with the
pipe (<code class="docutils literal"><span class="pre">|</span></code>) character.</p>
<p>Examples:</p>
<img alt="_images/array-examples.png" src="_images/array-examples.png" />
<ul class="simple">
<li><code class="docutils literal"><span class="pre">|4,double|*</span></code>: a pointer to an array of 4 <code class="docutils literal"><span class="pre">double</span></code></li>
<li><code class="docutils literal"><span class="pre">|10000000,i32|*</span></code>: a pointer to an array of one million <code class="docutils literal"><span class="pre">i32</span></code></li>
<li><code class="docutils literal"><span class="pre">|3,&lt;double,|15,float*|*&gt;*|**</span></code>: a pointer to a pointer to an array
of pointers to 2-tuples, the second element of which is a pointer to
an array of 15 float pointers. Whew!</li>
</ul>
<p>It&#8217;s probably clear at this point that the combinations of types allow
for heaps of flexibility, but can get pretty confusing if you use lots
of nesting of aggregate types within one another. If you <em>do</em> need to
use complex types, then you can define your own types and the compiler
can do some of the bookkeeping for you (more on this below).</p>
<p>Setting and getting values from arrays is done with (you guessed it!)
<code class="docutils literal"><span class="pre">aref</span></code>, <code class="docutils literal"><span class="pre">aset!</span></code>, and <code class="docutils literal"><span class="pre">afill!</span></code>. And if you want to get a pointer
into an array (that is, not to the first element but to some element
further into the array), use <code class="docutils literal"><span class="pre">aref-ptr</span></code>.</p>
</div>
<div class="section" id="vectors">
<span id="vector-type-doc"></span><h3>Vectors<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h3>
<p>The final aggregate data type in xtlang is the vector type. Vectors are
like arrays in that they are fixed length homogeneous type buffers, but
operations vector types will use the CPUs SIMD registers and
instructions (if your hardware has them). This can potentially give
significant speedups for certain types of processing. The downside is
that there&#8217;s a bit less flexibility (certain operations can&#8217;t be
performed on vector elements, especially conditionals and branching) and
it does make your code a bit less portable, at least from a performance
standpoint.</p>
<p>The syntax for vector types looks just like the array syntax, except the
pipes (<code class="docutils literal"><span class="pre">|</span></code>) are replaced with slashes (<code class="docutils literal"><span class="pre">/</span></code>), presumably because
they&#8217;re going <em>faster</em>.</p>
<p>Examples:</p>
<img alt="_images/vector-examples.png" src="_images/vector-examples.png" />
<ul class="simple">
<li><code class="docutils literal"><span class="pre">/4,float/*</span></code>: a pointer to a vector of four floats</li>
<li><code class="docutils literal"><span class="pre">/256,i32/*</span></code>: a pointer to a vector of 256 ints</li>
</ul>
<p>In general, if you&#8217;re working with vector types you&#8217;ll know what you&#8217;re
doing, and pick algorithms and word sizes which make good use of the
vector hardware on your computer. Unless you know that the particular
code you&#8217;re working on is the performance bottleneck in your system,
it&#8217;s probably best to start out with arrays, and to change to vectors
later on if it becomes necessary.</p>
</div>
<div class="section" id="closure-type">
<span id="closure-type-doc"></span><h3>Closure type<a class="headerlink" href="#closure-type" title="Permalink to this headline">¶</a></h3>
<p>The final important type in xtlang is the <a class="reference external" href="http://en.wikipedia.org/wiki/Closure_(computer_science)">closure</a> type, and
understanding closures is crucial to understanding how xtlang works as a
whole.</p>
<p>xtlang&#8217;s closures are lexical closures (like in Scheme), which means
that they are the combination of a function and its referencing
environment. This basically means that any variables referred to in the
scope of the function (even if they weren&#8217;t passed in as arguments) is
captured along with the function, and the whole &#8216;world&#8217; (as far as each
little function is concerned) can be passed around in a nice little
package.</p>
<p>In xtlang, closure types are indicated by square brackets (<code class="docutils literal"><span class="pre">[]</span></code>), with
the first element inside the brackets being the return type, and any
other elements representing the type signature of the function.</p>
<p>Examples:</p>
<img alt="_images/closure-examples.png" src="_images/closure-examples.png" />
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[i64]*</span></code>: a pointer to a closure which takes no arguments and
returns a single <code class="docutils literal"><span class="pre">i64</span></code></li>
<li><code class="docutils literal"><span class="pre">[i64,double,double]*</span></code>: a pointer to a closure which takes two
<code class="docutils literal"><span class="pre">double</span></code> arguments and returns a single <code class="docutils literal"><span class="pre">i64</span></code></li>
<li><code class="docutils literal"><span class="pre">[&lt;i64,i32&gt;*,|8,double|*]*</span></code>: a pointer to a closure which takes as
a n argument a pointer to an 8-element <code class="docutils literal"><span class="pre">double</span></code> array and returns a
pointer to a 2-tuple</li>
<li><code class="docutils literal"><span class="pre">[[i64,i32]*,[double]*]*</span></code>: a pointer to a closure which takes a
pointer to a closure (which returns a <code class="docutils literal"><span class="pre">double</span></code>) as an argument and
returns a pointer to another closure</li>
</ul>
<p>The last example in particular is interesting: closures can take
closures as arguments, and closures can return other closures. This
comes in handy in lots of situations, as lots of the files in
Extempore&#8217;s <code class="docutils literal"><span class="pre">examples</span></code> directory show.</p>
<p>The way to make closures in xtlang is with a <a class="reference external" href="http://en.wikipedia.org/wiki/Lambda_(programming)">lambda form</a>, just like
in Scheme. A <code class="docutils literal"><span class="pre">lambda</span></code> returns an <em>anonymous</em> function closure&#8212;that&#8217;s
what it means for xtlang to have &#8216;first class&#8217; functions/closures.
Closures don&#8217;t have to have names, they can be elements of lists and
arrays, they can be passed to and returned from other closures, they can
do anything any other type can do.</p>
<p>Sometimes, though, we want to give a closure a name, and that&#8217;s where
<code class="docutils literal"><span class="pre">bind-func</span></code> comes in. <code class="docutils literal"><span class="pre">bind-func</span></code> is the (only) way in xtlang
to assign a global name to a closure. Here&#8217;s an example of creating a
simple (named) xtlang closure using <code class="docutils literal"><span class="pre">bind-func</span></code></p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">xt_add</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:i64</span> <span class="nv">b</span><span class="kt">:i64</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">xt_add</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">;; returns 9</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">xt_add</span></code> takes two int arguments (see how the <code class="docutils literal"><span class="pre">i64</span></code> type annotations
are provided in the initial argument list) and returns their sum. It&#8217;s
also worth noting that when we compile <code class="docutils literal"><span class="pre">xt_add</span></code> the log view prints
the closure&#8217;s type signature:</p>
<div class="code highlight-python"><div class="highlight"><pre>Compiled xt_add &gt;&gt;&gt; [i64,i64,i64]*
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">bind-func</span></code> is xtlang&#8217;s equivalent to Scheme&#8217;s <code class="docutils literal"><span class="pre">define</span></code>, although
with the limitation that <code class="docutils literal"><span class="pre">define</span></code> in Scheme can bind any scheme
object (not just a closure) to a symbol, while in xtlang <code class="docutils literal"><span class="pre">bind-func</span></code>
has to return a closure (via a <code class="docutils literal"><span class="pre">lambda</span></code> form). Although if you need
to compile &amp; bind an xtlang entity of some other type, there are other
functions like <code class="docutils literal"><span class="pre">bind-val</span></code> and <code class="docutils literal"><span class="pre">bind-type</span></code> which will do the
necessary for you.</p>
<p>As another example, if you want to return a closure from the function
it&#8217;s exactly like you would do it in Scheme:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">make_xt_adder</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:i64</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">b</span><span class="kt">:i64</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;; type of make_xt_adder is [[i64,i64]*,i64]*</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">test_xt_adder</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="kt">:i64</span><span class="p">)</span>
    <span class="p">((</span><span class="nv">make_xt_adder</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">c</span><span class="p">)))</span>

<span class="c1">;; type of test_xt_adder is [i64,i64]*</span>

<span class="p">(</span><span class="nv">test_xt_adder</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; returns 8</span>
</pre></div>
</div>
<p>This example is a bit more complicated: the first closure
(<code class="docutils literal"><span class="pre">make_xt_adder</span></code>) takes one argument <code class="docutils literal"><span class="pre">a</span></code> and returns a closure
(notice the <em>second</em> <code class="docutils literal"><span class="pre">lambda</span></code> form inside the toplevel one) which
takes one argument <code class="docutils literal"><span class="pre">b</span></code> and adds it to <code class="docutils literal"><span class="pre">a</span></code>. Note that <code class="docutils literal"><span class="pre">a</span></code> is &#8216;baked
in&#8217; to this closure&#8212;it&#8217;s not passed in directly, but it&#8217;s referenced
from the outside scope. We say that this closure (which has no name&#8212;it&#8217;s
anonymous) &#8216;closes over&#8217; <code class="docutils literal"><span class="pre">a</span></code>.</p>
<p>Then, in the second function (<code class="docutils literal"><span class="pre">test_xt_adder</span></code>) we call
<code class="docutils literal"><span class="pre">make_xt_adder</span></code> with an argument of 3, so this will return a function
closure with one argument which adds 3 to that argument. This (returned)
function then gets passed the argument <code class="docutils literal"><span class="pre">c</span></code> (in this example, it&#8217;s
called with an argument of 5), so the end result is 3 + 5 = 8. Whew!
That&#8217;s confusing to read in words, but if you stare at the code long
enough you&#8217;ll reach enlightenment. Or something.</p>
<p>There&#8217;s lots more to say about closures, but I&#8217;ll leave that for another
post.</p>
</div>
</div>
<div class="section" id="strings">
<span id="string-type-doc"></span><h2>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">¶</a></h2>
<p>One other gotcha for C programmers is that there&#8217;s no <code class="docutils literal"><span class="pre">char</span></code> type, or
at least it&#8217;s not called <code class="docutils literal"><span class="pre">char</span></code>, it&#8217;s called <code class="docutils literal"><span class="pre">i8</span></code>. So strings in
xtlang are pointers to null terminated int arrays just like in C but
instead have type <code class="docutils literal"><span class="pre">i8*</span></code>. String literals in xtlang have this type.</p>
<p>The usual <code class="docutils literal"><span class="pre">pref</span></code> and friends for pointers (described above) are
therefore your friends if you want to slice and dice strings around. A
few familiar string functions have made their way over from the C
standard library as well.</p>
<p>String literals in xtlang are bound globally (allocated on the heap). So
you can safely set and store pointers to them without worrying about
then disappearing on you.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">string_literals</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">str</span> <span class="s">&quot;Vive le tour!&quot;</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;%s\n&quot;</span> <span class="nv">str</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">string</span><span class="nv">_literals</span><span class="p">)</span> <span class="c1">;; prints &quot;Vive le tour!&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="named-types">
<span id="named-type-doc"></span><h2>Named types<a class="headerlink" href="#named-types" title="Permalink to this headline">¶</a></h2>
<p>To round it off, you can also define your own types. This is convenient:
it&#8217;s easier to type <code class="docutils literal"><span class="pre">my_type</span></code> than
<code class="docutils literal"><span class="pre">[double*,&lt;i64,i32&gt;,float,float]</span></code>, especially if it&#8217;s a type that
you&#8217;ll be using a lot in your code.</p>
<p>There are two ways to define a custom type: <code class="docutils literal"><span class="pre">bind-type</span></code> and
<code class="docutils literal"><span class="pre">bind-alias</span></code>.</p>
<p>Examples:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-alias</span> <span class="nf">my_type_1</span> <span class="kt">&lt;i64,double&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">bind-type</span> <span class="nf">my_type_2</span> <span class="kt">&lt;float,[i64,i32]*,|3,double|*&gt;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">bind-type</span></code> tells the xtlang compiler about your new type, which
provides some safety benefits: the more the compiler knows about the
types in your code, the more errors it can throw at compile time and
save messy runtime errors and tricky debugging.</p>
<p>As an example, let&#8217;s make a 2D &#8216;point&#8217; type, and a function for
calculating the euclidean distance between two points.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-type</span> <span class="nf">point</span> <span class="kt">&lt;double,double&gt;</span><span class="p">)</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">euclid_distance</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:point*</span> <span class="nv">b</span><span class="kt">:point*</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">sqrt</span> <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nv">pow</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">tref</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">tref</span> <span class="nv">b</span> <span class="mi">0</span><span class="p">))</span>
                <span class="mf">2.0</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">pow</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">tref</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">tref</span> <span class="nv">b</span> <span class="mi">1</span><span class="p">))</span>
                  <span class="mf">2.0</span><span class="p">)))))</span>
</pre></div>
</div>
<p>To test this out, we can check the diagonal length of the unit square,
which should be <code class="docutils literal"><span class="pre">sqrt(2)</span> <span class="pre">=</span> <span class="pre">1.41</span></code></p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">test_unit_square_diagonal</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">bot_left</span><span class="kt">:point*</span> <span class="p">(</span><span class="nf">alloc</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">top_right</span><span class="kt">:point*</span> <span class="p">(</span><span class="nf">alloc</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">tfill!</span> <span class="nv">bot_left</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">tfill!</span> <span class="nv">top_right</span> <span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The length of the unit square&#39;s diagonal is %f\n&quot;</span>
              <span class="p">(</span><span class="nv">euclid_distance</span> <span class="nv">bot_left</span>
                               <span class="nv">top_right</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">test_unit_square_diagonal</span><span class="p">)</span>

<span class="c1">;; prints &quot;The length of the unit square&#39;s diagonal is 1.414214&quot;</span>
</pre></div>
</div>
<p>Now, what happens if we change this testing example to make
<code class="docutils literal"><span class="pre">top_right</span></code> and <code class="docutils literal"><span class="pre">bot_left</span></code> just plain tuples of type
<code class="docutils literal"><span class="pre">&lt;double,double&gt;</span></code> instead of being our new <code class="docutils literal"><span class="pre">point</span></code> type.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">test_unit_square_diagonal_2</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">bot_left</span><span class="kt">:&lt;double,double&gt;*</span> <span class="p">(</span><span class="nf">alloc</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">top_right</span><span class="kt">:&lt;double,double&gt;*</span> <span class="p">(</span><span class="nf">alloc</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">tfill!</span> <span class="nv">bot_left</span> <span class="mf">0.0</span> <span class="mf">0.0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">tfill!</span> <span class="nv">top_right</span> <span class="mf">1.0</span> <span class="mf">1.0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;The length of the unit square&#39;s diagonal is %f\n&quot;</span>
              <span class="p">(</span><span class="nv">euclid_distance</span> <span class="nv">bot_left</span>
                               <span class="nv">top_right</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Now, instead of compiling nicely, we get the compiler error:</p>
<div class="code highlight-python"><div class="highlight"><pre>Compiler Error: Type Error: (euclid_distance bot_left top_right)
 function argument does not match. Expected &quot;%point*&quot; but got &quot;{double,double}*&quot;
</pre></div>
</div>
<p>Even though <code class="docutils literal"><span class="pre">point</span></code> <em>is</em> just a <code class="docutils literal"><span class="pre">&lt;double,double&gt;</span></code> (check the
<code class="docutils literal"><span class="pre">bind-type</span></code> definition above), the compiler won&#8217;t let us compile the
function. This is a good thing most of the time, because it makes us be
more explicit about what we actually mean in our code, and saves us from
the silly mistakes that can happen when we&#8217;re not clear about what we
want.</p>
<p>There are lots of possibilities for the use of custom types, and there&#8217;s
no problem with binding as many as you need to make your code and
intention clearer. Binding custom types could, for instance, allow for
the construction of a &#8216;data structures&#8217; library like the C++ STL
containers library or the Java collections framework.</p>
<p><code class="docutils literal"><span class="pre">bind-alias</span></code>, in contrast to <code class="docutils literal"><span class="pre">bind-type</span></code>, is just a simple alias for
the given type. The xtlang compiler, when it sees <code class="docutils literal"><span class="pre">my_alias</span></code> in the
code, will simply substitute in the appropriate type (in this case
<code class="docutils literal"><span class="pre">&lt;i64,|3,double|*&gt;*</span></code>) before it generates the LLVM IR to send to the
compiler. <code class="docutils literal"><span class="pre">bind-alias</span></code> doesn&#8217;t tell the compiler as much about the
code as <code class="docutils literal"><span class="pre">bind-type</span></code> does, which can lead to execution-time problems
which would otherwise have been caught by the compiler. So you should
almost always use <code class="docutils literal"><span class="pre">bind-type</span></code> over <code class="docutils literal"><span class="pre">bind-alias</span></code>.</p>
</div>
<div class="section" id="type-inferencing-in-the-xtlang-compiler">
<h2>Type inferencing in the xtlang compiler<a class="headerlink" href="#type-inferencing-in-the-xtlang-compiler" title="Permalink to this headline">¶</a></h2>
<p>When looking at the code, one of the first things you&#8217;ll notice as a key
difference between xtlang and Scheme is the addition of type annotations
for variables. Type annotations can be attached to the declaration of
any variable using a colon, e.g.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">int_var:i64</span></code> (64-bit integer)</li>
<li><code class="docutils literal"><span class="pre">double_ptr:double*</span></code> (pointer to a double precision float)</li>
<li><code class="docutils literal"><span class="pre">closure_ptr:[i64,i32,i32]*</span></code> (pointer to a closure with two
arguments)</li>
</ul>
<p>Now, most of the examples in this file have been fairly explicit about
the types of the variables. Look at the code for <code class="docutils literal"><span class="pre">xt_add</span></code> above&#8212;in the
argument list <code class="docutils literal"><span class="pre">(a:i64</span> <span class="pre">b:i64)</span></code> both arguments are identified as
<code class="docutils literal"><span class="pre">i64</span></code>. What happens, though, if we take out just one of these type
annotations?</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">xt_add2</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:i64</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="c1">;; log shows &quot;Compiled xt_add2 &gt;&gt;&gt; [i64,i64,i64]*&quot;</span>

<span class="p">(</span><span class="nv">xt_add2</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">;; returns 6</span>
</pre></div>
</div>
<p>Even though we didn&#8217;t specify the type of <code class="docutils literal"><span class="pre">b</span></code>, everything still
compiled fine and the closure returns the correct result. What&#8217;s the go
with that? Well, it&#8217;s because the xtlang compiler in Extempore is a
<a class="reference external" href="http://en.wikipedia.org/wiki/Type_inference">type inferencing</a> compiler. The addition function <code class="docutils literal"><span class="pre">+</span></code> in the body of
<code class="docutils literal"><span class="pre">xt_add2</span></code> can only add values of the <em>same</em> type. Since the compiler
knows the type of <code class="docutils literal"><span class="pre">a</span></code>, things will only work out if <code class="docutils literal"><span class="pre">b</span></code> is also an
<code class="docutils literal"><span class="pre">i64</span></code>. And since this guess doesn&#8217;t conflict with any other
information it has about <code class="docutils literal"><span class="pre">b</span></code> (because there isn&#8217;t any), then the
compiler can infer that the only acceptable type signature for the
closure pointer is <code class="docutils literal"><span class="pre">[i64,i64,i64]*</span></code>.</p>
<p>How about if we try removing <code class="docutils literal"><span class="pre">a</span></code>&#8216;s type annotation as well?</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">xt_add3</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</pre></div>
</div>
<p>This time, the compiler prints the message:</p>
<div class="code highlight-python"><div class="highlight"><pre>Compiler Error: could not resolve (&quot;a&quot; &quot;b&quot; &quot;xt_add3&quot;) you could try
forcing the type of one or more of these symbols
</pre></div>
</div>
<p>There just isn&#8217;t enough info to unambiguously determine the types of
<code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>. They could be both <code class="docutils literal"><span class="pre">i32</span></code>, or both <code class="docutils literal"><span class="pre">floats</span></code>&#8212;the
compiler can&#8217;t tell. And rather than guess, it throws a compile error.</p>
<p>It&#8217;s also worth mentioning that we could have specified the closure&#8217;s
type directly with the definition of the <code class="docutils literal"><span class="pre">xt_add3</span></code> symbol</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">xt_add4</span><span class="kt">:[i64,i64,i64]*</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">xt_add4</span> <span class="mi">2</span> <span class="mi">9</span><span class="p">)</span> <span class="c1">;; returns 11</span>
</pre></div>
</div>
</div>
<div class="section" id="scheme-and-xtlang-types">
<h2>Scheme and xtlang types<a class="headerlink" href="#scheme-and-xtlang-types" title="Permalink to this headline">¶</a></h2>
<p>Extempore can run both Scheme and xtlang code, but Scheme doesn&#8217;t know
anything about xtlang&#8217;s types&#8212;things like tuples, arrays, vectors,
closures, and user-defined types through <code class="docutils literal"><span class="pre">bind-type</span></code>. Scheme only
knows about <a class="reference external" href="https://groups.csail.mit.edu/mac/ftpdir/scheme-reports/r5rs-html/r5rs_8.html#SEC48">Scheme types</a> like symbols, integers, reals,
strings, c pointers, etc.</p>
<p>There is some (approximate) overlap in these type systems, for ints,
floats, strings and c pointers, although even in these cases there are
some caveats, e.g. Scheme only supports <em>double precision</em> floats, while
Extempore can work with both <code class="docutils literal"><span class="pre">floats</span></code> and <code class="docutils literal"><span class="pre">doubles</span></code> natively.
Similarly, xtlang&#8217;s pointers are typed, but Scheme only supports void
(opaque) c pointers. Where possible, Extempore will do the work to allow
xtlang code from Scheme (coercing argument types), but for any composite
types (e.g. list) you can&#8217;t call xtlang code from Scheme.</p>
<p>Here&#8217;s an example to make things a bit clearer:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; tuple-maker returns a pointer to a tuple and tuple-taker takes</span>
<span class="c1">;; a pointer to a tuple as an argument.</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">tuple-maker</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span><span class="kt">:&lt;i64,double&gt;*</span> <span class="p">(</span><span class="nf">alloc</span><span class="p">)))</span>
          <span class="p">(</span><span class="nf">tset!</span> <span class="nv">a</span> <span class="mi">0</span> <span class="mi">42</span><span class="p">)</span>
          <span class="nv">a</span><span class="p">)))</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">tuple-taker</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:&lt;i64,double&gt;*</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">tuple-ref</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">tuple-maker</span><span class="p">)</span>               <span class="c1">;; Returns a CPTR (to a tuple, but scheme doesn&#39;t know that)</span>
<span class="p">(</span><span class="nv">tref</span> <span class="p">(</span><span class="nv">tuple-maker</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">;; error, scheme doesn&#39;t know about xtlang types</span>
<span class="p">(</span><span class="nv">tuple-taker</span> <span class="p">(</span><span class="nv">tuple-maker</span><span class="p">))</span> <span class="c1">;; returns 42. scheme can pass *pointers* to tuples around</span>
                            <span class="c1">;; as void pointers, but you lose the type checking</span>
</pre></div>
</div>
<p>Have a look at <code class="docutils literal"><span class="pre">examples/core/extempore_lang.xtm</span></code> for more examples.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="generics.html" class="btn btn-neutral float-right" title="Generics" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="concurrency.html" class="btn btn-neutral" title="Concurrency" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Andrew Sorensen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.6.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>