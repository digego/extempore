

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Extempore philosophy &mdash; Extempore 0.7.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Extempore 0.7.0 documentation" href="index.html"/>
        <link rel="next" title="Interacting with the Extempore Compiler" href="caas.html"/>
        <link rel="prev" title="About this documentation" href="about-this-documentation.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Extempore
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="editor-support.html">Text editors</a></li>
<li class="toctree-l1"><a class="reference internal" href="about-this-documentation.html">About this documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Key concepts</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Extempore philosophy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-s-scheme-and-what-s-xtlang">What&#8217;s scheme, and what&#8217;s xtlang?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#so-why-two-languages">So why two languages?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#live-programming-interacting-with-the-extempore-compiler-runtime"><strong>Live</strong> programming: Interacting with the Extempore compiler/runtime</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="caas.html">Interacting with the Extempore Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="time.html">Time in Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-xtlang-interop.html">C-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheme-xtlang-interop.html">Scheme-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="concurrency.html">Concurrency</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management in Extempore</a></li>
</ul>
<p class="caption"><span class="caption-text">xtlang</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="types.html">xtlang types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#primitive-types">Primitive types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#aggregate-types">Aggregate types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#named-types">Named types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-inference.html">Type inferencing</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best practices</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials &amp; Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="audio-signal-processing.html">Audio signal processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="making-an-instrument.html">Making an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="note-level-music.html">Playing an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-lisp-music.html">&#8220;Common Lisp Music&#8221;-style example</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampler.html">Loading and using a sampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphics.html">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="impromptu-users.html">Extempore for Impromptu users</a></li>
</ul>
<p class="caption"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting-help.html">Getting Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Unit testing in Extempore</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Extempore</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>The Extempore philosophy</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/philosophy.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="the-extempore-philosophy">
<h1>The Extempore philosophy<a class="headerlink" href="#the-extempore-philosophy" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This was once a blog post&#8212;corrections/improvements
welcome.</p>
</div>
<p>Extempore is a programming language and runtime environment designed
with <em>live</em> programming in mind. It supports interactive programming
in a REPL style, compiling and binding code just-in-time. Although
Extempore has its roots in &#8216;live coding&#8217; of audiovisual media art, it
is suitable for any task domain where dynamic run-time modifiability
and good numerical performance are required. Extempore also has strong
timing and concurrency semantics, which are helpful when working in
problem spaces where timing is important (such as audio and video).</p>
<p>These two goals&#8212;dynamic flexibility and close-to-the-metal
control&#8212;seem at odds. Extempore tries to offer both by supporting
both a high-level dynamic language (Scheme) and a low-level &#8216;C like&#8217;
language (xtlang) simultaneously, with tight integration and
transparency between the two. A running Extempore process will compile
both valid scheme and xtlang forms. Scheme objects (lists, closures,
continuations, etc.) coexist with the <a class="reference internal" href="types.html"><span class="doc">xtlang&#8217;s types</span></a> and <a class="reference internal" href="memory.html#pointer-doc"><span class="std std-ref">pointers</span></a> to <a class="reference internal" href="memory.html"><span class="doc">allocated
memory</span></a>, and with a few &#8216;helper functions&#8217; data can even flow
through both languages fluidly.</p>
<div class="section" id="what-s-scheme-and-what-s-xtlang">
<h2>What&#8217;s scheme, and what&#8217;s xtlang?<a class="headerlink" href="#what-s-scheme-and-what-s-xtlang" title="Permalink to this headline">¶</a></h2>
<p>This is all a bit abstract, so let&#8217;s look at a couple of examples:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">scheme-closure</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">result</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">print</span> <span class="s">&quot;result = &quot;</span> <span class="nv">result</span><span class="p">)</span>
      <span class="nv">result</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">scheme-closure</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">;; prints &quot;result = 20&quot;, returns 20</span>
<span class="p">(</span><span class="nv">scheme-closure</span> <span class="mf">2.4</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; prints &quot;result = 4.8&quot;, returns 4.8</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">xtlang_closure</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="kt">:double</span> <span class="nv">d</span><span class="kt">:i64</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">result</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">i64tod</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;result = %f\n&quot;</span> <span class="nv">result</span><span class="p">)</span>
      <span class="nv">result</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">xtlang_closure</span> <span class="mf">4.5</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">;; prints &quot;result = 9.000000&quot;, returns 9.0</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">scheme-closure</span></code> is a Scheme <a class="reference external" href="http://en.wikipedia.org/wiki/Closure_(computer_science)">closure</a> (a closure is a function
along with its enclosing scope). It&#8217;s just a regular Scheme closure, it
takes two arguments (<code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>), which can be any number; anything
for which <code class="docutils literal"><span class="pre">number?</span></code> returns <code class="docutils literal"><span class="pre">#t</span></code>. Closures are first-class objects
in Scheme, and <code class="docutils literal"><span class="pre">scheme-closure</span></code> is no exception. It can be passed to
<code class="docutils literal"><span class="pre">map</span></code>, <code class="docutils literal"><span class="pre">apply</span></code>, and friends.</p>
<p><code class="docutils literal"><span class="pre">xtlang_closure</span></code>, on the other hand, is an xtlang closure. xtlang
(unlike Scheme) is a <em>new</em> language, and the Extempore executable
provides the xtlang compiler. Like Scheme, xtlang is has an
<a class="reference external" href="http://en.wikipedia.org/wiki/S-expression">s-expression</a> based syntax.</p>
<p><code class="docutils literal"><span class="pre">xtlang_closure</span></code> is also a closure which takes two arguments, and
xtlang uses the <code class="docutils literal"><span class="pre">lambda</span></code> form to build closures, just like Scheme. In
fact, <code class="docutils literal"><span class="pre">xtlang_closure</span></code> does the exact same thing as <code class="docutils literal"><span class="pre">scheme-closure</span></code>
does&#8212;it takes two arguments, multiplies them together, then both prints
and returns the result. One thing that&#8217;s different in the xtlang
version, though, is the presence of type annotations for the arguments:
they&#8217;re the (blue) parts of the symbol name following the colon. The
types should be familiar: <code class="docutils literal"><span class="pre">double</span></code> for a double-precision floating
point number, and <code class="docutils literal"><span class="pre">i64</span></code> for a 64-bit (signed) integer. Unlike
Scheme&#8212;which is dynamically typed, and will silently coerce floats into
ints and other things like that&#8212;xtlang is statically typed. Not every
type needs to be specified, the compiler will infer types when it is
<em>unambiguous</em>, but the compiler will never silently coerce types. This
is by design&#8212;the whole point of using xtlang in Extempore is to make
things explicit. If you want more dynamic typing, then there&#8217;s always
Scheme.</p>
<p>The xtlang compiler uses an <a class="reference external" href="http://llvm.org">LLVM</a> backend to generate high-performance
machine code. Basically, Extempore&#8217;s xtlang compiler generates the LLVM
IR, and this is then passed to LLVM for compiling and linking.</p>
</div>
<div class="section" id="so-why-two-languages">
<h2>So why two languages?<a class="headerlink" href="#so-why-two-languages" title="Permalink to this headline">¶</a></h2>
<p>Why introduce this confusion? Why not just pick one language or the
other (or design a new language which has aspects of both)? By way of
explanation, let&#8217;s do a bit of numerical processing. Say we want to
calculate the highest common factor of two integers <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code>
using a brute-force approach:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">hcf-scheme</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">letrec</span> <span class="p">((</span><span class="nv">hcf</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">i</span><span class="p">)</span>
                    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">modulo</span> <span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">modulo</span> <span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
                        <span class="nv">i</span>
                        <span class="p">(</span><span class="nv">hcf</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">))))))</span>
      <span class="p">(</span><span class="nv">hcf</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">hcf-scheme</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">)</span> <span class="c1">;; returns 5</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">hcf_xtlang</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="kt">:i64</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">hcf</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">i</span><span class="p">)</span>
                 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">modulo</span> <span class="nv">a</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                          <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">modulo</span> <span class="nv">b</span> <span class="nv">i</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
                     <span class="nv">i</span>
                     <span class="p">(</span><span class="nv">hcf</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">))))))</span>
      <span class="p">(</span><span class="nv">hcf</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">hcf_xtlang</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">)</span>  <span class="c1">;; returns 5</span>
</pre></div>
</div>
<p>The code for Scheme (<code class="docutils literal"><span class="pre">hcf-scheme</span></code>) and xtlang (<code class="docutils literal"><span class="pre">hcf_xtlang</span></code>) is
identical except for an <code class="docutils literal"><span class="pre">i64</span></code> type annotation on the first argument
<code class="docutils literal"><span class="pre">a</span></code> in <code class="docutils literal"><span class="pre">hcf_xtlang</span></code> and a <code class="docutils literal"><span class="pre">letrec</span></code> instead of a <code class="docutils literal"><span class="pre">let</span></code> in
<code class="docutils literal"><span class="pre">hcf-scheme</span></code>. Both functions use tail call recursion, and are
written in a fairly &#8216;scheme-like&#8217; way. Although there is only the one
type annotation, <code class="docutils literal"><span class="pre">hcf_xtlang</span></code> is strongly (and fully) typed. The
types of all the other variables and the return type of the closure
are all inferred by the compiler from the type of <code class="docutils literal"><span class="pre">a</span></code>: the function
<code class="docutils literal"><span class="pre">hcf_xtlang</span></code> takes two <code class="docutils literal"><span class="pre">i64</span></code> arguments and returns another
<code class="docutils literal"><span class="pre">i64</span></code>. In more complex functions there may be a greater need to
specify the types of the variables, but often just a few type
annonations can unambiguously determine everything in scope. The
<a class="reference internal" href="types.html"><span class="doc">xtlang type reference</span></a> has more info on how
type inferencing works in the xtlang compiler.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; first, figure out two large numbers with a common factor (133)</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="k">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="mi">133</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">125219</span> <span class="mi">123711</span><span class="p">)))</span> <span class="c1">;; prints (16654127 16453563)</span>

<span class="c1">;; profile the scheme version</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">t</span> <span class="p">(</span><span class="nv">clock:clock</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">println</span> <span class="ss">&#39;HCF</span> <span class="ss">&#39;=</span> <span class="p">(</span><span class="nv">hcf-scheme</span> <span class="mi">16654127</span> <span class="mi">16453563</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">println</span> <span class="ss">&#39;elapsed</span> <span class="ss">&#39;time</span> <span class="ss">&#39;=</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nv">clock:clock</span><span class="p">)</span> <span class="nv">t</span><span class="p">)</span> <span class="ss">&#39;seconds</span><span class="p">))</span>

<span class="c1">;; --result--</span>
<span class="c1">;; HCF = 133</span>
<span class="c1">;; elapsed time = 82.085036 seconds</span>

<span class="c1">;; profile the xtlang version</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">t</span> <span class="p">(</span><span class="nv">clock:clock</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">println</span> <span class="ss">&#39;HCF</span> <span class="ss">&#39;=</span> <span class="p">(</span><span class="nv">hcf_xtlang</span> <span class="mi">16654127</span> <span class="mi">16453563</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">println</span> <span class="ss">&#39;elapsed</span> <span class="ss">&#39;time</span> <span class="ss">&#39;=</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nv">clock:clock</span><span class="p">)</span> <span class="nv">t</span><span class="p">)</span> <span class="ss">&#39;seconds</span><span class="p">))</span>

<span class="c1">;; --result--</span>
<span class="c1">;; HCF = 133</span>
<span class="c1">;; elapsed time = 0.257790 seconds</span>
</pre></div>
</div>
<p>In a direct comparison, here I&#8217;ve calculate the HCF of the integers
<code class="docutils literal"><span class="pre">16654127</span></code> and <code class="docutils literal"><span class="pre">16453563</span></code>, which are (by design) known to have at
least one non-trivial factor (<code class="docutils literal"><span class="pre">133</span></code>). Both functions return <code class="docutils literal"><span class="pre">133</span></code>,
but the xtlang one finishes over 300 times faster. I tried to use even
bigger integers as input, but the Scheme version blew past the maximum
runtime timeout, while the xtlang one finished in about 2 seconds :)</p>
<p>Now, this comparison is one datapoint: it isn&#8217;t meant to start a flame
war about dynamic vs statically typed languages or anything like that.
It&#8217;s a brute-force algorithm for a problem with many more elegant
algorithms. What it does show, though, is that <em>Extempore&#8217;s</em> Scheme
interpreter is <em>slow</em>. There are some crazy fast and efficient Scheme
compilers, but Extempore&#8217;s isn&#8217;t one of them&#8212;it&#8217;s dog slow.</p>
<p>You may now be thinking that this pretty much rules Scheme out for
anything computationally intensive in Extempore, such as audio and
graphics. Well, late one night in about 2010 Andrew (Extempore&#8217;s
creator) had pretty much the same realisation. At the time he was
working on Impromptu, Extempore&#8217;s predecessor, which had the same Scheme
interpreter. And he realised that the Scheme interpreter would need some
<em>serious</em> work to bring it up to speed if it was going to be used for
any number-crunching. At that point, he figured that he might as well
write a new language, leveraging the LLVM compiler. And lo, xtlang was
born (although it wasn&#8217;t called that straight away).</p>
<p>After working on xtlang inside of Impromptu for a while, it became clear
that introducing a whole new language to a programming environment is
kindof a big change. So he decided to fork the project, give it a new
name, and also make a couple of other fundamental changes (open source
and cross-platform) as well. Impromptu is still supported, and some of
the improvements to Extempore are back-ported, but Extempore is the
future. And that&#8217;s the history of Extempore and the genesis of xtlang in
two paragraphs.</p>
<p>xtlang&#8217;s types include tuples (like C structs), arrays, SIMD vectors and
pointers in addition to the float and int primitives shown in these
examples. The upside of having to worry about these types is the
increased performance and low-level expressiveness, which is
particularly important in real-time and computationally intensive
settings such as digital audio, graphics and interfacing directly with
hardware. The other benefit of having a low-level type system (like C)
is that it&#8217;s easy to bind to shared libraries (<code class="docutils literal"><span class="pre">.dll</span></code>, <code class="docutils literal"><span class="pre">.so</span></code> or
<code class="docutils literal"><span class="pre">.dylib</span></code> depending on your platform) and then call into them in
xtlang. You can even bind and rebind these shared libraries dynamically,
switching the bindings around as you please. There&#8217;s more details about
binding to C shared libraries in the <code class="docutils literal"><span class="pre">examples/external</span></code> directory,
and in <a class="reference internal" href="c-xtlang-interop.html"><span class="doc">C-xtlang interop</span></a>.</p>
<p>There&#8217;s heaps more to say about the Scheme/xtlang interop in Extempore
(as well as the details of xtlang itself!), but the key point is that
it&#8217;s nice to have the choice. Scheme is a great control/scripting
language for triggering events, and xtlang is a nice &#8216;systems&#8217; language
for building infrastructure and for doing computational heavy lifting.
Extempore allows the programmer to live in both worlds, as long as they
have some understanding of what&#8217;s going on under the covers. And as I
work with Extempore (and as xtlang matures) I find myself using Scheme
less and less and xtlang more and more. The code I&#8217;m writing is almost
the same (since they&#8217;re syntactically so similar), but with the
performance benefits and bit-level control of working much closer to the
metal. It&#8217;s even nice (most of the time, at least!) to get the compile
errors, it&#8217;s better to catch type mismatches earlier rather than later.</p>
</div>
<div class="section" id="live-programming-interacting-with-the-extempore-compiler-runtime">
<h2><strong>Live</strong> programming: Interacting with the Extempore compiler/runtime<a class="headerlink" href="#live-programming-interacting-with-the-extempore-compiler-runtime" title="Permalink to this headline">¶</a></h2>
<p>Remember the claim in the opening paragraph that Extempore is a language
designed with &#8216;live programming&#8217; in mind? Now, &#8216;live programming&#8217; is a
pretty loaded term (is the insinuation that all other programming is
<em>dead?</em>) and as such needs some unpacking. Extempore is designed to
support (and indeed make it easy for) the programmer to interact with,
modify, and extend their program as it runs.</p>
<p>This is obviously possible in any REPL-based development environment,
but often this interaction is limited to the building and debugging
phase of software development, with the program being frozen (possibly
compiled) upon completion and then left to run unmolested. In Extempore,
on the other hand, this interactive development style is supported (and
encouraged) through the whole software lifecycle&#8212;up to and including the
deployment and running of the &#8216;final&#8217; code. An Extempore codebase is not
necessarily a static artefact: the behaviour of the system is determined
by the development of the code over the whole time the system is
running, and this behaviour may be differ substantially between the
commencement and completion of this process.</p>
<p>This human-in-the-loop programming approach is exemplified by the
practice of live coding or <a class="reference external" href="http://toplap.org">laptop performance</a>, a &#8220;new direction in
electronic music and video: live coders expose and rewire the innards of
software while it generates improvised music and/or visuals. All code
manipulation is projected for your pleasure.&#8221; In an artistic context
this idea of improvisational live programming makes sense, but there are
also many other contexts where having a human in the loop even at
program execution time (to catch unforseen bugs or add hitherto
unplanned functionality) is advantageous. This is a tough job for the
programmer&#8212;there&#8217;s no safety net when you&#8217;re modifying the program as
it&#8217;s being run&#8212;but that&#8217;s exactly why Extempore is being designed as it
is: to provide as much support as possible to the programmer as they
deal with this difficult (and exciting) challenge.</p>
<p>This &#8216;everything should be hot-swappable at runtime&#8217; philosophy has a
couple of implications for the architecture of the Extempore compiler
and programming environment:</p>
<ol class="arabic simple">
<li>Compilation/binding should happen as late as possible. Extempore has
a couple of static dependencies baked in at compile time, but the
rest of the functionality is loaded on-the-fly.</li>
<li>Compiler-as-a-service (CaaS): the Extempore compiler is a running
process, and compilation happens by interactively sending Scheme or
xtlang code to the appropriate address/port. The compiler need not be
running on the same machine as the programmer, and the code can also
be executed in any number of running Extempore processes. And because
it&#8217;s written in Scheme, even the compiler <em>itself</em> is reconfigurable
at runtime.</li>
</ol>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="caas.html" class="btn btn-neutral float-right" title="Interacting with the Extempore Compiler" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="about-this-documentation.html" class="btn btn-neutral" title="About this documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Andrew Sorensen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>