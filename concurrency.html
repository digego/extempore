

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Concurrency &mdash; Extempore 0.7.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Extempore 0.7.0 documentation" href="index.html"/>
        <link rel="next" title="Memory management in Extempore" href="memory.html"/>
        <link rel="prev" title="Scheme-xtlang interop" href="scheme-xtlang-interop.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Extempore
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="editor-support.html">Text editors</a></li>
<li class="toctree-l1"><a class="reference internal" href="about-this-documentation.html">About this documentation</a></li>
</ul>
<p class="caption"><span class="caption-text">Key concepts</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">The Extempore philosophy</a></li>
<li class="toctree-l1"><a class="reference internal" href="caas.html">Interacting with the Extempore Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="time.html">Time in Extempore</a></li>
<li class="toctree-l1"><a class="reference internal" href="c-xtlang-interop.html">C-xtlang interop</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheme-xtlang-interop.html">Scheme-xtlang interop</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Concurrency</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#concurrency-in-xtlang">Concurrency in xtlang</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="memory.html">Memory management in Extempore</a></li>
</ul>
<p class="caption"><span class="caption-text">xtlang</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="types.html">xtlang types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#primitive-types">Primitive types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#aggregate-types">Aggregate types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#named-types">Named types</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-inference.html">Type inferencing</a></li>
<li class="toctree-l1"><a class="reference internal" href="best-practices.html">Best practices</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials &amp; Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="audio-signal-processing.html">Audio signal processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="making-an-instrument.html">Making an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="note-level-music.html">Playing an instrument</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampler.html">Loading and using a sampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphics.html">Graphics</a></li>
<li class="toctree-l1"><a class="reference internal" href="impromptu-users.html">Extempore for Impromptu users</a></li>
</ul>
<p class="caption"><span class="caption-text">Community</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting-help.html">Getting Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Unit testing in Extempore</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Extempore</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Concurrency</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/concurrency.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="concurrency">
<h1>Concurrency<a class="headerlink" href="#concurrency" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Some of the threading stuff (particularly in xtlang) has
changed slightly since this was written, although as a
high-level overview it&#8217;s still accurate. It&#8217;ll be brought
up to date as soon as possible, but if you find anything
in here which isn&#8217;t clear or doesn&#8217;t work, <a class="reference internal" href="about-this-documentation.html"><span class="doc">let us
know</span></a></p>
</div>
<p>Every Extempore <em>process</em> (e.g. the &#8220;primary process&#8221; or &#8220;utility
process&#8221;) is a <em>Scheme process</em>, which is actually an operating-system
(OS) thread running in the main Extempore OS process (i.e. the
thing with the PID number). Each top level Scheme process runs its own
scheme interpreter with its own managed memory, own garbage collector
etc. Additionally, each Scheme process has its own network port. To
evaluate a Scheme expression you send it to a given scheme process
using this network port, i.e. over a TCP connection. Extempore
provides a nice inter-process communication (IPC) layer to make
communication between Scheme processes reasonably straightforward,
regardless of whether they are running locally or remotely.</p>
<p>To summarize, each <em>Scheme process</em> is an OS thread, but in reality
behaves more like an OS process because it has its own managed memory,
scheme process control, etc..</p>
<p>Here is a starting example of a Scheme function that mutates a Scheme
global variable. The function includes a <em>blocking</em> sleep&#8212;it will
<code class="docutils literal"><span class="pre">println</span></code> then sleep for one second, test conditional and repeat.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">global-val</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">my-scm-func</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">println</span> <span class="nv">name</span> <span class="p">(</span><span class="nv">ipc:get-process-name</span><span class="p">)</span> <span class="nv">global-val</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">sys:sleep</span> <span class="nv">*second*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">global-val</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">begin</span> <span class="p">(</span><span class="k">set!</span> <span class="nv">global-val</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">global-val</span> <span class="mi">1</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">my-scm-func</span> <span class="nv">name</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>It is important to note though that even though an Extempore process
(i.e. Scheme process) is a single OS thread, much of Extempore&#8217;s
day-to-day concurrency occurs within this context using cooperative
concurrency. So, for example, we can happily run this code
concurrently. Eval each of the following lines in turn using</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">set!</span> <span class="nv">global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nv">my-scm-func</span> <span class="ss">&#39;b</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">global-val</span></code> is shared memory, however access to that
shared memory is strictly ordered, i.e. is not pre-emptive. This type
of concurrency makes concurrent programming in Extempore safe and
straightforward. Many of Extempore&#8217;s libraries are built around this
type of cooperative concurrency (i.e. <code class="docutils literal"><span class="pre">sys:sleep</span></code> above, which makes this
example possible).</p>
<p>However, one downside to this approach is that it is only able to
utilizes a single CPU core. So, Extempore also supports <em>multiple</em>
Scheme processes. There are always two started by default (primary and
utility), but you can spawn as many as you like at runtime, although
these are relatively heavy-weight so generally you are not likely to
want any more processes than your total number of CPU cores.</p>
<p>You can spawn your own process with a name and a network port like this:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:new</span> <span class="s">&quot;myproc&quot;</span> <span class="mi">7090</span><span class="p">)</span>
</pre></div>
</div>
<p>or you can connect to a remote process like this:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; assuming a host at 192.168.1.1 is running Extempore</span>
<span class="p">(</span><span class="nv">ipc:connect</span> <span class="s">&quot;192.168.1.1&quot;</span> <span class="s">&quot;myproc&quot;</span> <span class="mi">7099</span><span class="p">)</span>
</pre></div>
</div>
<p>Either way, <em>myproc</em> is now a local name which defines a process
running <em>somewhere</em>. IPC calls work regardless of whether the process
is local or remote.</p>
<p>You can explicitly call into <code class="docutils literal"><span class="pre">my-scm-func</span></code> in the primary process like
so:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>which is essentially the same thing as calling <code class="docutils literal"><span class="pre">(my-scm-func</span> <span class="pre">'a</span> <span class="pre">5)</span></code>
while <em>connected</em> to the primary process. Being explicit though, means
that we can make this call into primary no matter what scheme
process we are currently <em>connected</em> to.</p>
<p>We can try to run <code class="docutils literal"><span class="pre">my-scm-func</span></code> in the <em>myproc</em> process as follows:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>but we will get an error, because <code class="docutils literal"><span class="pre">my-scm-func</span></code> (and <code class="docutils literal"><span class="pre">global-val</span></code>
for that matter) do not exist in the memory space of <em>myproc</em>. We can
fix that using Extempore&#8217;s IPC infrastructure simply enough by
defining both <code class="docutils literal"><span class="pre">global-val</span></code> and <code class="docutils literal"><span class="pre">my-scm-func</span></code> in <em>myproc</em>.</p>
<div class="highlight-extempore"><div class="highlight"><pre>(ipc:define &quot;myproc&quot; &#39;global-val global-val)
(ipc:define &quot;myproc &#39;my-scm-func my-scm-func)
</pre></div>
</div>
<p>now the <code class="docutils literal"><span class="pre">ipc:call</span></code> works as expected&#8212;i.e. executing
<code class="docutils literal"><span class="pre">my-scm-func</span></code> in the <em>myproc</em> process.</p>
<p>Note that we defined <code class="docutils literal"><span class="pre">global-val</span></code> in <em>myproc</em> to be whatever value
<code class="docutils literal"><span class="pre">global-val</span></code> was currently bound to in our <em>connected</em> process,
which in this instance was <em>primary</em> but could be whatever process our
text buffer was connected to. We could just as easily have defined a
different value into <em>myproc</em>, e.g.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;global-val</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>So, now try evaluating the next four lines one after the other</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>These are again executing concurrently but now also in parallel (i.e.
on different cores). Importantly, <code class="docutils literal"><span class="pre">global-val</span></code> is independent, not
shared. Anyway, so far so good, the main point being the independence
of the memory spaces, and Extempore&#8217;s IPC layer for communication
between Scheme processes.</p>
<div class="section" id="concurrency-in-xtlang">
<h2>Concurrency in xtlang<a class="headerlink" href="#concurrency-in-xtlang" title="Permalink to this headline">¶</a></h2>
<p>Things get more interesting when we introduce xtlang.</p>
<p>Firstly, all calls into xtlang code are always initiated at some point
by a top level scheme expression (see <a class="reference internal" href="scheme-xtlang-interop.html"><span class="doc">Scheme-xtlang interop</span></a> for
more detail). Under normal Extempore operating conditions, xtlang code
is always executing in some Scheme process or other. Generally this
xtlang code will behave as expected with regards to concurrency, i.e.
will generally behave as if it were just another Scheme call inside
the Scheme process. As a trivial example, consider the xtlang
function:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">times2</span>
   <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">*</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</div>
<p>Compiling this xtlang function automatically creates a Scheme binding
with exactly same name, which allows us to call it like any other
scheme call:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; try evaluating this line</span>
<span class="p">(</span><span class="nv">times2</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Of course, we can incorporate this Scheme wrapper call into our normal
Scheme code, for example we can modify the <code class="docutils literal"><span class="pre">my-scm-func</span></code> from above:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">my-scm-func</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">name</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">println</span> <span class="nv">name</span> <span class="p">(</span><span class="nv">ipc:get-process-name</span><span class="p">)</span> <span class="p">(</span><span class="nv">times2</span> <span class="nv">global-val</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">sys:sleep</span> <span class="nv">*second*</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">global-val</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">begin</span> <span class="p">(</span><span class="k">set!</span> <span class="nv">global-val</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">global-val</span> <span class="mi">1</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">my-scm-func</span> <span class="nv">name</span> <span class="nv">x</span><span class="p">)))))</span>
</pre></div>
</div>
<p>and all of our existing examples will work just fine. For example,
cooperative concurrency as before:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="nv">my-scm-func</span> <span class="ss">&#39;b</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>also using IPC, although we will need to re-define <code class="docutils literal"><span class="pre">my-scm-func</span></code> in
<em>myproc</em> because we have changed its definition. Also note that we
need to tell <em>myproc</em> about <code class="docutils literal"><span class="pre">times2</span></code> (note that <code class="docutils literal"><span class="pre">ipc:bind-func</span></code> has a
slightly different signature from <code class="docutils literal"><span class="pre">ipc:define</span></code>):</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:bind-func</span> <span class="s">&quot;myproc&quot;</span> <span class="nv">times2</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="nv">my-scm-func</span><span class="p">)</span>
</pre></div>
</div>
<p>now we can re-run the same ipc example as earlier (evaluating each
line one after the other)</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:define</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;global-val</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;my-scm-func</span> <span class="ss">&#39;a</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>OK, so far the behaviour of xtlang fits in with our existing
understanding of both Extempore&#8217;s cooperative concurrency and
Extempore&#8217;s Scheme process architecture. Now things will begin to
diverge somewhat.</p>
<p>Firstly, the <code class="docutils literal"><span class="pre">(ipc:bind-func</span> <span class="pre">&quot;myproc&quot;</span> <span class="pre">times2)</span></code> call from above is
needed to define the &#8220;scheme times2 wrapper&#8221; in <em>myproc</em>&#8212;<strong>not</strong> the
xtlang times2 function itself which is bound globally across the
entire Extempore OS process and so is automatically available to all
Scheme processes, and indeed potentially to <em>any</em> other OS thread
running in the Extempore OS process (the thing with the PID). In
practice this means that if an xtlang function closes over some value
at the top level, then that closed value is shared between all Scheme
processes (which is not the case with a Scheme closure which is unique
in every Scheme process).</p>
<p>For example:</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-func</span> <span class="nf">xtlang_inc</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">y</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">inc</span><span class="p">)</span>
      <span class="p">(</span><span class="k">set!</span> <span class="nv">y</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">y</span> <span class="nv">inc</span><span class="p">))</span>
      <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">ipc:bind-func</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;xtlang_inc</span><span class="p">)</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;xtlang_inc</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;xtlang_inc</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">xtlang_inc</span></code> is shared between primary and <em>myproc</em> and
therefore <code class="docutils literal"><span class="pre">y</span></code> is shared data, and is therefore subject to all of the
potential pitfalls associated with shared mutable memory (as well as
all of the potential performance optimizations etc.</p>
<p>This also goes for any globally bound xtlang variables. Consider this
code for example.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="p">(</span><span class="k">bind-val</span> <span class="nf">my_xtlang_global</span> <span class="nv">i64</span> <span class="mi">0</span><span class="p">)</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">get_global</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="nv">my_xtlang_global</span><span class="p">))</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">set_global</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">set!</span> <span class="nv">my_xtlang_global</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">ipc:bind-func</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;get_global</span><span class="p">)</span>
<span class="p">(</span><span class="nv">ipc:bind-func</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;set_global</span><span class="p">)</span>

<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;get_global</span><span class="p">))</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;get_global</span><span class="p">))</span>

<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;set_global</span> <span class="mi">55</span><span class="p">))</span>

<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;primary&quot;</span> <span class="ss">&#39;get_global</span><span class="p">))</span>
<span class="p">(</span><span class="nf">println</span> <span class="p">(</span><span class="nv">ipc:call</span> <span class="s">&quot;myproc&quot;</span> <span class="ss">&#39;get_global</span><span class="p">))</span>
</pre></div>
</div>
<p>So Scheme is all about message passing, and xtlang is all about shared
memory. This is by design, as xtlang is there to let you break all the
rules when performance matters. Now this does not mean that your
xtlang code is definitely <em>not</em> Scheme process (i.e. thread) safe.
xtlang code can be Scheme process (i.e. thread) safe if you stick to
the following three principles:</p>
<ol class="arabic simple">
<li>Don&#8217;t access global xtlang variables in your xtlang functions.</li>
<li>Don&#8217;t close over variables with top-level xtlang functions.</li>
<li>Don&#8217;t allocate heap <a class="reference internal" href="memory.html"><span class="doc">memory</span></a> in xtlang functions
(zone and stack memory is OK)</li>
</ol>
<p>If you stick to those three principles then your xtlang code should be
Scheme process safe, although obviously you also need to be careful
about what <strong>other</strong> xtlang and native code that you call into.</p>
<p>Having said that, xtlang is there to allow you to break the
rules&#8212;with great power comes great responsibility, and all that
rubbish. Indeed xtlang allows you to <em>completely</em> break the rules by
giving you direct access to native threads. Here&#8217;s an xtlang example
that completely breaks out of Extempore&#8217;s &#8220;normal environment&#8221; by
managing its own native OS threads using standard fork/join semantics.</p>
<div class="highlight-extempore"><div class="highlight"><pre><span class="c1">;; sleep for 0-3 seconds</span>
<span class="p">(</span><span class="k">bind-func</span> <span class="nf">my_os_thread</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
    <span class="p">(</span><span class="nv">thread_sleep</span> <span class="p">(</span><span class="nv">dtoi64</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">3</span><span class="nv">.</span> <span class="p">(</span><span class="nf">random</span><span class="p">)))</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;thread: %p\n&quot;</span> <span class="p">(</span><span class="nv">thread_self</span><span class="p">))))</span>

<span class="p">(</span><span class="k">bind-func</span> <span class="nf">native_threads</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">num</span><span class="kt">:i64</span><span class="p">)</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">i</span> <span class="mi">0</span><span class="p">)</span>
          <span class="p">(</span><span class="nv">threads</span><span class="kt">:i8**</span> <span class="p">(</span><span class="nf">salloc</span> <span class="nv">num</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">num</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">pset!</span> <span class="nv">threads</span> <span class="nv">i</span>
               <span class="p">(</span><span class="nv">thread_fork</span>
                <span class="p">(</span><span class="nv">llvm_get_function_ptr</span> <span class="s">&quot;my_os_thread_native&quot;</span><span class="p">)</span>
                <span class="nv">null</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">num</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">thread_join</span> <span class="p">(</span><span class="nf">pref</span> <span class="nv">threads</span> <span class="nv">i</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">printf</span> <span class="s">&quot;DONE!\n&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">native_threads</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Note the use of <code class="docutils literal"><span class="pre">(llvm_get_function_ptr</span> <span class="pre">&quot;my_os_thread_native&quot;)</span></code>.
This call returns a sanitized C wrapper function around our xtlang
closure <code class="docutils literal"><span class="pre">my_os_thread</span></code>. Like Scheme wrappers, C wrappers are also
automatically generated for toplevel xtlang closures, and are required
if you wish to call an xtlang closure from an external C
library&#8212;<a class="reference internal" href="c-xtlang-interop.html"><span class="doc">xtlang knows how to call C natively</span></a> but C cannot call an xtlang closure without an
appropriate C wrapper. C wrappers have the same name as the xtlang
closure with <code class="docutils literal"><span class="pre">_native</span></code> appended to the end. By passing a C wrapper
around we can have the OS callback into native xtlang code and still
enjoy full on-the-fly hot-swappability. In other words, once you have
passed the C wrapper as a callback you can re-compile (change the
behaviour) of the original xtlang closure on-the-fly, whenever you
like!</p>
<p>The same principle applies to any other C library code that you may
pass xtlang closure C wrappers to. These callbacks are then subject to
whatever threading context that library code implements, although all
obviously within the context of the global Extempore OS process.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="memory.html" class="btn btn-neutral float-right" title="Memory management in Extempore" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="scheme-xtlang-interop.html" class="btn btn-neutral" title="Scheme-xtlang interop" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Andrew Sorensen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>