;;;;;;;;;;;;;;;;;;;
;; extempore.xtm ;;
;;;;;;;;;;;;;;;;;;;

;; includes "comlist.xtm" Implementation of COMMON LISP list functions for Scheme
;; Copyright (C) 1991, 1993, 1995, 2001, 2003 Aubrey Jaffer.
;; Copyright (C) 2000 Colin Walters

;; also includes "sort.xtm" Defines: sorted?, merge, merge!, sort, sort!
;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;; this code is in the public domain

;; All other code Copyright (c) 2011, Andrew Sorensen
;;
;;  All rights reserved
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; 1. Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;;
;; 2. Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;;
;; Neither the name of the authors nor other contributors may be used to endorse
;; or promote products derived from this software without specific prior written
;; permission.
;;
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.

;; pretty printing

(define-macro (print-with-colors fg bg bold . body)
  `(let ((colors '((black . 0)
       (red . 1)
       (green . 2)
       (yellow . 3)
       (blue . 4)
       (magenta . 5)
       (cyan . 6)
       (white . 7)
       (default . 9)
       (none . 9))))
     (ascii-print-color (if ,bold 1 0)
      (cdr (assoc ,fg colors))
      (cdr (assoc ,bg colors)))
     ,@body
     ;; return colors to normal
     (ascii-print-color 0 7 9)))

(define log-info
  (lambda args
    (apply print-info args)))

(define log-warn
  (lambda args
    (apply print-warn args)))

(define log-error
  (lambda args
    (apply print-error args)
    (error "")))

;;
;; GENERAL UTILITY FUNCTIONS AND VARS
;;

(define remove-all
   (lambda (obj lst)
      (cond ((null? lst)
       '())
      ((list? (car lst))
       (cons (remove-all obj (car lst))
       (remove-all obj (cdr lst))))
      ((equal? obj (car lst))
       (remove-all obj (cdr lst)))
      (else (cons (car lst) (remove-all obj (cdr lst)))))))


(define (tree-copy tree)
  (let loop ((tree tree))
    (if (pair? tree)
  (cons (loop (car tree)) (loop (cdr tree)))
  tree)))

(define (tree-member mem tree)
  (if (member #t
              (flatten
               (let loop ((tree tree))
                 (if (pair? tree)
                     (cons (loop (car tree)) (loop (cdr tree)))
                     (if (null? tree) '()
                         (if (equal? tree mem) #t #f))))))
      #t #f))

(define remove-first
   (lambda (obj lst)
      (if (member obj lst)
    (let loop ((new '())
         (lstb lst))
       (if (equal? (car lstb) obj)
     (append new (cdr lstb))
     (loop (append new (list (car lstb))) (cdr lstb))))
    lst)))

(define get-named-arg
   (lambda (name args . default-value)
      (let ((value (member name args)))
   (if value
       (cadr value)
       (if (null? default-value)
           '()
         (car default-value))))))


(define replace-all
  (lambda (lst alst)
    (if (pair? lst)
        (let loop ((lsta lst) (lstb '()))
          (if (null? lsta)
              (reverse lstb)
              (let* ((v (car lsta))
                     (lstb2 (cond ((assoc v alst)
                                   (cons (cdr (assoc v alst)) lstb))
                                  ((list? v)
                                   (cons (loop v '()) lstb))
                                  ((pair? v)
                                   (cons (cons (car (loop (list (car v)) '()))
                                               (car (loop (list (cdr v)) '())))
                                         lstb))
                                  (#t (cons v lstb)))))
                (loop (cdr lsta) lstb2))))
        lst)))

(define replace-first
   (lambda (obj-a obj-b  lst)
      (if (member obj-a lst)
    (let loop ((new '())
         (lstb lst))
       (if (equal? (car lstb) obj-a)
     (append new (list obj-b) (cdr lstb))
     (loop (append new (list (car lstb))) (cdr lstb))))
    lst)))


(define-macro (dotimes init . body)
   `(if (<= ,(cadr init) 0)
  '()
  (let uri1834ck ((,(car init) 0))
     ,@body
     (if (< ,(car init) (- ,(cadr init) 1))
         (uri1834ck (+ ,(car init) 1))))))

;; Deprectateded because of symbol leak.  see above.
;;(define-macro (dotimes init . body)
;;  `(do (( ,(car init) 0 (+ 1 ,(car init))))
;;       ((= ,(car init) ,(cadr init)))
;;     ,@body))

(define-macro (dotill predicate expression . args)
   (let ((max-iterations (if (null? args) 100000000 (car args))))
      `(let impsym38479k ((cnt 0))
    (let ((value ,expression))
       (if ,predicate
     value
     (if (> cnt ,max-iterations)
         (begin (log-info "Dropping out after max-iterations")
          'failed)
         (impsym38479k (+ cnt 1))))))))

(define make-vector-with-proc
   (lambda (num func)
      (let ((new-vector (make-vector num)))
   (do ((i 0 (+ i 1)))
       ((= i num) new-vector)
      (vector-set! new-vector i (func i))))))

(define (make-list lth obj)
  (let loop ((i lth)
       (lst '()))
     (if (< i 1)
   lst
     (loop (- i 1) (cons obj lst)))))

(define (make-list-with-proc lth func)
   (if (< lth 1)
       '()
       (let loop ((i 0)
      (lst '()))
    (if (>= i lth)
        (reverse lst)
        (loop (+ i 1) (cons (func i) lst))))))

(define repeat
  (lambda (n val)
    (let loop ((i n) (out '()))
      (if (<= i 0)
          out
          (loop (- i 1) (cons val out))))))

(define (weighted-selection . args)
   (let ((rand (random)))
      (let loop ((lst args)
     (count 0))
   (if (< rand (+ count (caar lst)))
       (cdar lst)
       (loop (cdr lst) (+ count (caar lst)))))))

(define (random . args)
  (cond ((< (length args) 1)
         (random-real))
        ((list? (car args))
         (list-ref (car args) (random (length (car args)))))
        ((pair? (car args))
         (apply weighted-selection args))
        (else (let ((lower (if (> (length args) 1) (real->integer (car args)) 0))
                    (upper (if (> (length args) 1) (cadr args) (car args))))
                (+ lower (random-int (- upper lower)))))))

;;
;; EXTERNAL CPP STUFF AND CALLBACK FUNCTIONS
;;

(define impromptu_envs '())

(define (callback-adapter sym . args)
  (apply (eval sym) args))

;; send tasks for normal standard task execution
(define (call-cpp . args)
    (call-cpp-at-time (car args) 0 (cadr args) (cddr args) (current-environment)))

;; send tasks for execution in audio thread
;(define (call-render-cpp . args)
;    (call-cpp-at-time (car args) *au:audiounit-queue* (cadr args) (cddr args) (current-environment)))

;; send tasks for normal execution as callback tasks
(define (callback time func . args)
  (let ((payload (if (symbol? func)
         (cons callback-adapter (cons func args))
           (cons func args))))
  (call-cpp-at-time time 2 *callback* payload (current-environment))))

;; alias for callback
(define schedule callback)

;;(define (ipc-define proc sym)
;;  (if (symbol? sym)
;;      (if (closure? (eval sym))
;;          (ipc-def proc sym (get-closure-code (eval sym)))
;;          (ipc-def proc sym (eval sym)))
;;      "error: argument 2 must be a symbol"))

;;
;; TIME FUNCTIONS AND GLOBAL VARS
;;

(define *second* *au:samplerate*)
(define *samplerate* *au:samplerate*)
(define *blocksize* *au:block-size*)

(define *minute* (* *second* 60))

(define *hour* (* *minute* 60))

(define clock:offset-from-server
   (lambda (server-proc local-proc)
      (let* ((t1 (clock:clock))
       (t2 (ipc:call server-proc local-proc 'clock:clock))
       (t3 t2)
       (t4 (clock:clock))
       (msg-delay (- (- t4 t1) (- t2 t3)))
       (time-offset (/ (+ (- t2 t1) (- t3 t4)) 2)))
   time-offset)))

(define clock:sync-adjust
   (lambda (server-proc local-proc samples wait-time . args)
      (let loop ((i samples)
     (lst '()))
   (sys:sleep wait-time)
   (if (> i 0)
       (loop (- i 1)
       (cons (clock:offset-from-server server-proc local-proc) lst))
       (let* ((l1 (cddr (cl:sort lst <))) ;; remove bottom 2
        (l2 (cddr (reverse l1)))) ;; remote top 2
         ;; check tolerance of return
         (if (> (math:std-deviation l2)
          (if (null? args) 0.0005 (car args)))
       (begin (log-info "clock sync outside tolerance - making no time adjustment: " (math:std-deviation l2))
        (log-info "clock times: " lst))
       (begin (log-info 'clock 'successfully 'adjusted 'by (/ (apply + l2) (length l2)) 'seconds)
        (clock:adjust-offset (/ (apply + l2) (length l2))))))))))


(define -clock:metro-from-host-
   (lambda ()
      (let ((mark (*metro* 'get-mark)))
   (list (*metro* 'get-tempo)
         (car mark)
         (samples->clock (cdr mark))))))


(define clock:update-metro
   (lambda (server-process local-process)
      (let ((res (ipc:call server-process local-process '-clock:metro-from-host-)))
   (set! *metro* (make-metro (car res)
           (cons (cadr res)
           (clock->samples (caddr res))))))))



(define clock:update-metro
   (lambda (server-process local-process)
      (clock:sync-adjust server-process local-process 5 500 .005)
      (let ((res (ipc:call server-process local-process '-clock:metro-from-host-)))
   (set! *metro* (make-metro (car res)
           (cons (clock->samples (cadr res))
           (caddr res)))))))


(define -clock:metro-from-host-
   (lambda ()
      (let ((mark (*metro* 'get-mark)))
   (println 'mark-remote: mark 'time: (samples->clock (car mark)))
   (list (*metro* 'get-tempo)
         (samples->clock (car mark))
         (cdr mark)))))



;; convert from audio samples to clock
(define samples->clock
   (lambda (time)
      (let* ((c (clock:ad:clock))
       (t1 (car c))
       (t2 (cdr c)))
   (+ t2 (/ (- time t1) *samplerate*)))))


;; convert from clock to audio samples
(define clock->samples
   (lambda (time)
      (let* ((t1 (clock:clock))
       (t2 (clock:ad:clock))
       (t3 (round (+ (+ (car t2) (* (- time t1) *samplerate*))
         (* (- t1 (cdr t2)) *samplerate*)))))
   (real->integer t3))))


(define (io:osc:send time host-address osc-address . args)
   (call-cpp time *io:osc:send-msg* (car host-address) (cdr host-address) osc-address args))


(define math:mean
   (lambda (lst)
      (/ (apply + lst) (length lst))))

(define math:std-deviation
   (lambda (lst)
      (sqrt (math:variance lst))))

(define math:variance
   (lambda (lst)
      (let ((m (math:mean lst)))
   (let loop ((l lst)
        (v 0))
      (if (null? l)
    (/ v (length lst))
    (let ((var (- (car l) m)))
       (loop (cdr l) (+ v (* var var)))))))))

(define (string->sexpr str)
   (let* ((port (open-input-string str))
    (res (read port)))
      (close-port port)
      res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Metro and beat related stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (define pi 3.14159265358979323846)
;; (define 2pi (* 2.0 pi))

(define PI 3.14159265358979323846)
(define TWOPI (* 2.0 PI))

;; sinusoidal LFOs

(macro (cosr args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (cos (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (cos (* TWOPI beat ,(cadddr args)))))))

(macro (sinr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (sin (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (sin (* TWOPI beat ,(cadddr args)))))))

(macro (tanr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (tan (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (tan (* TWOPI beat ,(cadddr args)))))))

;; sawtooth wave LFO with period 2pi

(define-macro (ramp x)
  `(let* ((xx (+ ,x 0.000000001))
         (xmod2pi (- xx (* TWOPI (floor (/ xx TWOPI))))))
     (* (/ 1.0 TWOPI) xmod2pi)))


(macro (rampr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (ramp (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (ramp (* TWOPI beat ,(cadddr args)))))))

(define-macro (slide x)
  `(- 1.0 (ramp ,x)))

(macro (slider args)
       (if (> (length args) 4)
           `(+ ,(caddr args) (* ,(cadddr args) (slide (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
           `(+ ,(cadr args) (* ,(caddr args) (slide (* TWOPI beat ,(cadddr args)))))))


;; square wave LFO with period 2pi

(define-macro (rect x)
  `(let ((xmod2pi (- ,x (* TWOPI (floor (/ ,x TWOPI))))))
     (if (< xmod2pi PI) 1.0 0.0)))

(macro (rectr args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (rect (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (rect (* TWOPI beat ,(cadddr args)))))))

;; triangle wave LFO with period 2pi

(define-macro (tri-wave x)
  `(let* ((xx (+ ,x 0.000000001))
          (xmod2pi (- xx (* TWOPI (floor (/ xx TWOPI))))))
     (* (/ 1.0 PI)
        (if (< xmod2pi PI) xmod2pi (- TWOPI xmod2pi)))))

(macro (trir args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (tri-wave (* TWOPI (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (tri-wave (* TWOPI beat ,(cadddr args)))))))

;; creates a rhythm of a given length a tactus is provided and a
;; percentage of synconization (from 0 - 1) a rhythm-list defines
;; which rhythm values can be used
;;
;; (define rlst (make-rhythm 4 1 .2 '(1/3 1/2 1/4)))


(define make-rhythm
   (lambda (beats tactus syncopation rhythm-list)
      (define beats-divisible-by-rlst
   (lambda (dur)
      (member 0 (map (lambda (r) (modulo dur r)) rhythm-list))))
      (set! rhythm-list (cl:sort rhythm-list >))
      (if (not (= 0 (modulo beats tactus)))
    (begin (log-error "Tactus must be a subdivision of beats") '())
    (if #f ;(not (beats-divisible-by-rlst beats))
        (begin (println "Impossible rhythm-list selection") '())
        (let loop ((rl '())
       (cnt 0))
     (if (null? rl) (list (random rhythm-list)))
     (let ((sum (apply + rl)))
        (cond ((> cnt 500)
         (log-error "Could not make valid rhythm")
         '())
        ((> sum beats)
         (loop (cdr rl) (+ cnt 1)))
        ((not (beats-divisible-by-rlst (- beats sum)))
         (loop (cdr rl) (+ cnt 1)))
        ((>= (car rhythm-list) (- beats sum))
         (cond ((= sum beats)
          (reverse rl))
         ((member (- beats sum) rhythm-list)
          (reverse (cons (car (member (- beats sum) rhythm-list)) rl)))
         (else (loop (cons (random rhythm-list) rl) (+ cnt 1)))))
        (else (if (= 0 (modulo sum tactus))
            (loop (cons (random rhythm-list) rl) (+ cnt 1))
            (if (> (random) (+ .05 syncopation))
          (loop (cons (car rl) rl) (+ cnt 1))
          (loop (cons (random rhythm-list) rl) (+ cnt 1))))))))))))



; accepts an associative list as the timeline argument
; returns an event at a given time from the alist
;
; if a new pair is passed then add that pair to the end of timeline
(define make-timeline
   (lambda (timeline)
      (if (null? timeline)
    '()
    (lambda (time)
       (if (pair? time)
     (set! timeline (append timeline (list time)))
     (let loop ((lst (reverse timeline)))
        (cond ((null? lst) '())
        ((>= time (caar lst))
         (cdar lst))
        (else (loop (cdr lst))))))))))



; creates a meter where metre is a list of numerators
; and base is a shared denominator (relative to impromptu beats. i.e. 1 = crotchet,  0.5 = eighth etc.)
;
; e.g.  (define *metre* (make-metre '(2 3 2) 0.5)) = 2/8 3/8 2/8 rotating cycle.
;
; then call meter with time and beat
; if beat matches time then #t else #f
;
; e.g. give the above define
;      (*metre* 2.5 1.0) => #t because 0.0 = 1, 0.5 = 2, 1.0 = 1, 1.5 = 2, 2.0 = 3, 2.5 = 1, 3.0 = 2 and repeat.
(define make-metre
   (lambda (metre base)
      (let ((metre-length (apply + metre)))
   (lambda (time . beat)
      (let ((b (let loop ((qtime (modulo (/ time base) metre-length))
        (lst metre)
        (valuea (car metre))
        (valueb 0))
      (if (< qtime valuea)
          (+ 1.0 (- qtime valueb))
          (loop qtime (cdr lst) (+ valuea (cadr lst)) (+ valueb (car lst)))))))
         (if (null? beat)
       b
       (if (= (car beat) b) #t #f)))))))


;; creates a metronome object
;; metro is basically a linear function that returns
;; a time in absolute samples when given a time in beats.
;;
;; metro is instantiated with a starting tempo.
;; you can call the metro with the following symbols
;;
;; 'get-time ; which is also the default
;; 'get-beat
;; 'get-tempo
;; 'set-tempo
;; 'get-cycle
;; 'set-cycle
;; 'pos
;; 'dur
;
(define make-metro
  (lambda (start-tempo . args)
    (let* ((offset (if (null? args) (now) (caar args)))
           (cycle 4)
           (mark offset)
           (loffset 0.0)
           (total-beats (if (null? args) 0 (cdar args)))
           (cycle-beats total-beats)
           (g-tempo (/ 60 start-tempo))
           (beat-pos (lambda (x1 y1 x2 y2)
                       (let* ((m (if (= 0 (- x2 x1)) 0 (/ (- y2 y1) (- x2 x1))))
                              (c (- y1 (* m x1))))
                         (lambda (time)
                           (+ (* time m) c)))))
           (beat-env (beat-pos mark total-beats (+ mark (* g-tempo *au:samplerate*)) (+ total-beats 1)))
           (samp-env (beat-pos total-beats mark (+ total-beats 1) (+ mark (* g-tempo *au:samplerate*)))))
      (lambda (sym . args)
        (cond ((number? sym)
               (+ (samp-env sym) loffset))
              ((equal? sym 'get-mark)
               (cons mark total-beats))
              ((equal? sym 'get-time)
               (+ (samp-env (car args)) loffset)) ;mark))
              ((equal? sym 'get-cycle) cycle)
              ((equal? sym 'get-cycle-mark) cycle-beats)
              ((equal? sym 'set-cycle)
               (set! cycle-beats (cadr args))
               (set! cycle (car args)))
              ((equal? sym 'pos) (modulo (- (car args) cycle-beats) cycle))
              ((equal? sym 'beat-at-time) (rational->real (beat-env (car args))))
              ((equal? sym 'set-tempo)
               (let ((time (if (null? (cdr args)) (now) (cadr args))))
                 (if (or (null? (cdr args))
                         (null? (cddr args)))
                     (set! total-beats
                           (+ total-beats (/ (- time mark)
                                             (* *au:samplerate* g-tempo))))
                     (set! total-beats (caddr args)))
                 (set! g-tempo (/ 60 (car args)))
                 (set! mark time)
                 (set! samp-env (beat-pos total-beats
                                          mark
                                          (+ total-beats 1)
                                          (+ mark (* g-tempo *au:samplerate*))))
                 (set! beat-env (beat-pos mark
                                          total-beats
                                          (+ mark (* g-tempo *au:samplerate*))
                                          (+ total-beats 1)))
                 (car args)))
              ((equal? sym 'get-tempo) (* (/ 1 g-tempo) 60))
              ((equal? sym 'dur) (* *au:samplerate* g-tempo (car args)))
              ((equal? sym 'push) (set! loffset (+ loffset 256)))
              ((equal? sym 'pull) (set! loffset (- loffset 256)))
              ((equal? sym 'get-beat)
               (let ((val (+ total-beats
                             (/ (- (now) mark)
                                (* *au:samplerate* g-tempo))))
                     (quantize (if (null? args) 1.0 (car args))))
                 (real->rational (+ val (- quantize (modulo val quantize))))))
              (else 'bad-method-name))))))


(define *metro* (make-metro 120 '(0 . 0)))


;; define me first!
(define-macro (set-signal! variable value seconds . rate)
  (let ((r (if (null? rate) 1/30 (car rate))))
    (if (and (or (list? value)
                 (defined? value))
             (closure? (eval value)))
        `(let l1929 ((t (now))
                     (count (/ ,seconds ,r)))
           (if (equal? ,variable 'stop-signal)
               'done
               (begin (set! ,variable (apply ,value (list ,variable)))
                      (if (> count 1)
                          (callback (+ t (* *samplerate* ,r)) l1929 (+ t (* *samplerate* ,r)) (- count 1))))))
        `(let l1929 ((t (now))
                     (inc (/ (- ,value ,variable) (real->integer (/ ,seconds ,r))))
                     (count (real->integer (/ ,seconds ,r))))
           (if (equal? ,variable 'stop-signal)
               'done
               (begin (set! ,variable (+ ,variable inc))
                      (if (> count 1)
                          (callback (+ t (* *samplerate* ,r)) l1929 (+ t (* *samplerate* ,r)) inc (- count 1)))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sys:wait
;; synchronous concurrency

(define *sys:toplevel-continuation* '())
(call/cc (lambda (k) (set! *sys:toplevel-continuation* k)))

(define sys:wait
   (lambda (until-time)
      (call/cc (lambda (cont)
      (callback until-time cont #t)
      (*sys:toplevel-continuation* 0)
      #t))))

(define sys:sleep
   (lambda (duration)
      (call/cc (lambda (cont)
      (callback (+ (now) duration) cont #t)
      (*sys:toplevel-continuation* 0)
      #t))))


;; synchronous IPC


(define *ipc:remote-process-name-map* '())

(define ipc:set-local-remote-mapping
   (lambda (local-name remote-name)
     (let ((res (assoc *impc:remote-process-name-map* local-name)))
       (if res
     (set-cdr! res remote-name)
     (set! *impc:remote-process-name-map*
     (cons (cons local-name remote-name)
           *impc:remote-process-name-map*))))))

(define ipc:proc-name-with-mapping
   (lambda ()
     (let ((pair (assoc *impc:remote-process-name-map* (ipc:get-process-name))))
       (if pair
     (car pair)
     (ipc:get-process-name)))))

(define *ipc:active-label-buffer-size* 1000)
(define *ipc:active-labels* (make-vector *ipc:active-label-buffer-size* '()))
(define *ipc:active-label-cnt* 0)

(define ipc:run-active-label
   (lambda (id . args)
     (let ((k (vector-ref *ipc:active-labels* id)))
       (if (null? k)
     (println "Error: bad process? Have you given your local process a name on the remote host?"))
       (vector-set! *ipc:active-labels* id '())
       (apply k args))))


(define ipc:sync-receive
  (lambda (process id func . args)
    (let ((result (apply (eval func) args)))
      (ipc:call-async process 'ipc:run-active-label id result))))


;; (define ipc:call
;;   (lambda (process func . args)
;;     (let loop ((i *ipc:active-label-cnt*))
;;       (if (not (null? (vector-ref *ipc:active-labels* i)))
;;           (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
;;           (set! *ipc:active-label-cnt* i)))
;;     (apply ipc:call-async process 'ipc:sync-receive (ipc:proc-name-with-mapping)
;;            *ipc:active-label-cnt* func args)
;;     (let ((return-val (call/cc (lambda (k)
;;                                  (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
;;                                  (*sys:toplevel-continuation* 0)))))
;;       return-val)))


(define ipc:call
  (lambda (process . args)
    (let* ((callback-proc (ipc:get-process-name))
           (func (if (string? (car args))
                     (begin (set! callback-proc (car args))
                            (set! args (cdr args))
                            (car args))
                     (car args))))
      (let loop ((i *ipc:active-label-cnt*))
        (if (not (null? (vector-ref *ipc:active-labels* i)))
            (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
            (set! *ipc:active-label-cnt* i)))
      (apply ipc:call-async process 'ipc:sync-receive callback-proc
             *ipc:active-label-cnt* func (cdr args))
      (let ((return-val (call/cc (lambda (k)
                                   (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
                                   (*sys:toplevel-continuation* 0)))))
        return-val))))

(define ipc:map
  (lambda (process-lst func . args-list)
    (let* ((callback-proc (ipc:get-process-name))
           (results '())
           (loopK '()))
      (let ((pos (call/cc (lambda (kk) (set! loopK kk) 0))))
        (if (< pos (length process-lst))
            (let ((z (list-ref process-lst pos))
                  (ags (if (null? args-list) #f (list (list-ref (car args-list) pos)))))
              (let loop ((i *ipc:active-label-cnt*))
                (if (not (null? (vector-ref *ipc:active-labels* i)))
                    (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
                    (set! *ipc:active-label-cnt* i)))
              (apply ipc:call-async z 'ipc:sync-receive callback-proc
                     *ipc:active-label-cnt* func (if (null? args-list) '() ags))
              (let ((return-val (call/cc (lambda (k)
                                           (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
                                           (loopK (+ pos 1))))))
                (set! results (cons return-val results))
                (if (< (length results) (length process-lst))
                    (*sys:toplevel-continuation* 0)
                    results)))
            (*sys:toplevel-continuation*))))))

;; comptibility alias (deprecated)
(define ipc:mapcall ipc:map)

;; async map

;; syntax:

;; (ipc:for-each '("primary" "utility") 'fn-with-no-args)

;; both of these ok:
;; (ipc:for-each '("primary" "utility") 'fn-with-1-arg '(12 36))
;; (ipc:for-each '("primary" "utility") 'fn-with-1-arg '((12) (36)))

;; (ipc:for-each '("primary" "utility") 'fn-with-2-args '((12 436) (36 45)))
(define ipc:for-each
  (lambda (proc-list func . arg-lists)
    ;; poor man's destructuring(ish)
    (set! arg-lists
          (if (null? arg-lists)
              (make-list (length proc-list) '())
              (map (lambda (x) (if (list? x) x (list x)))
                   (car arg-lists))))
    (for-each (lambda (proc args)
                (apply ipc:call-async proc func args))
              proc-list
              arg-lists)))

(define-macro (ipc:eval proc expr)
  `(ipc:eval-string ,proc ,(sexpr->string expr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (io:osc:receive time address . args)
   (log-info 'override 'io:osc:receive 'to 'handle 'osc 'events:)
   (println time address args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; LIST HELPER FUNCTIONS

;;delete from list at index
(define delete-at-index
   (lambda (k lst)
      (cond ((or (null? lst)
     (< k 0))
       lst)
      ((= k 0)
       (cdr lst))
      ((>= k (length lst))
       lst)
      (else (set-cdr! (cl:nthcdr (- k 1) lst)
          (cl:nthcdr (+ k 1) lst))
      lst))))

; insert into list at index
(define insert-at-index
   (lambda (k lst obj)
      (cond ((or (null? lst)
     (< k 0))
       lst)
      ((= k 0)
       (cons obj lst))
      ((> k (length lst))
       lst)
      (else (set-cdr! (cl:nthcdr (- k 1) lst)
          (cons obj (cl:nthcdr k lst)))
      lst))))

; change list item at index
(define change-at-index
   (lambda (k lst obj)
      (cond ((or (null? lst)
     (< k 0))
       lst)
      ((>= k (length lst))
       lst)
      (else (set-car! (cl:nthcdr k lst) obj)
      lst))))

(define (foldr func end lst)
  (if (null? lst)
      end
      (func (car lst) (foldr func end (cdr lst)))))

(define (foldl func accum lst)
  (if (null? lst)
      accum
      (foldl func (func accum (car lst)) (cdr lst))))

(define (scan proc val lst)
    (if (null? lst)
        '()
        (cons (proc val (car lst)) (scan proc (proc val (car lst)) (cdr lst)))))

;; jumble returns a randomized version of lst
(define jumble
   (lambda (lst)
      (let loop ((lstb '())
     (lsta (map (lambda (val) val) lst)))
   (if (null? lsta)
       lstb
       (let* ((rand (random (length lsta)))
        (val (list-ref lsta rand)))
    (loop (cons val lstb) (delete-at-index rand lsta)))))))

;; rotate list
(define rotate
   (lambda (lst amt)
      (let loop ((l (if (> amt 0) (reverse lst) lst))
     (cnt (abs amt)))
   (if (<= cnt 0)
       (if (> amt 0) (reverse l) l)
       (loop (append (cdr l) (list (car l)))
       (- cnt 1))))))


(define make-bezier
   (lambda (x1 y1 x2 y2 cx1 cy1 cx2 cy2)
      (let* ((xc (* 3 (- cx1 x1)))
       (xb (- (* 3 (- cx2 cx1)) xc))
       (xa (- x2 x1 (* 3 (- cx2 cx1))))
       (yc (* 3 (- cy1 y1)))
       (yb (- (* 3 (- cy2 cy1)) yc))
       (ya (- y2 y1 (* 3 (- cy2 cy1)))))
   (lambda (t)
      (cons (+ (* xa t t t)
         (* xb t t)
         (* xc t)
         x1)
      (+ (* ya t t t)
         (* yb t t)
         (* yc t)
         y1))))))

(define list-head
   (lambda (lst k)
      (if (< k 1)
    '()
    (cons (car lst) (list-head (cdr lst) (- k 1))))))


;; flatten down to a list of lists
(define (flatten-1 list)
   (cond ((null? list) '())
   ((and (list? (car list))
         (list? (car (car list))))
    (append (flatten-1 (car list)) (flatten-1 (cdr list))))
   (else (cons (car list) (flatten-1 (cdr list))))))


;; flatten down to a list of atoms
(define (flatten list)
   (cond ((null? list) '())
   ((list? (car list)) (append (flatten (car list)) (flatten (cdr list))))
   (else (cons (car list) (flatten (cdr list))))))


;; return all permutations of set
;; of subsets (size) of set
(define permutations
   (lambda (set size)
      (if (null? set)
    '(())
    (letrec ((f1 (lambda (s)
        (map (lambda (e)
          (f2 (list e) (cl:remove e s)))
             s)))
       (f2 (lambda (e s)
        (if (= (length e) size)
            e
            (map (lambda (e2)
              (f2 (append e (list e2)) (cl:remove e2 s)))
           s)))))
       (flatten-1 (f1 set))))))



;; return all combinations of set
;; or subsets (size) of set
(define combinations
   (lambda (s size)
      (if (< (length s) size)
    '()
    (letrec ((f1 (lambda (h t)
        (if (= (length h) size)
            (reverse h)
            (let loop ((e (car t))
           (l (cdr t)))
         (if (null? l)
             (if (< (length h) (- size 1)) '()
           (reverse (list* e h)))
             (list (f1 (list* e h) l)
             (loop (car l) (cdr l)))))))))
       (cl:remove '() (flatten-1 (append (f1 (list (car s)) (cdr s))
                 (combinations (cdr s) size))))))))


;; return all combinations of set
;; of subsets (size of set)
(define combinations
  (lambda (s size)
     (if (= 0 size) '()
  (flatten-1 (map (lambda (x)
         (let ((res (combinations (list-tail s (+ 1 (cl:position x s))) (- size 1))))
            (if (null? res) (list x)
          (map (lambda (y)
            (if (list? y) (list* x y) (list x y)))
               (flatten-1 res)))))
      (list-head s (- (length s) ( - size 1))))))))


;; USE multi-set-combination (below) to access this function
(define multi-list-combination-2
  (lambda args
    (if (null? args)
  args
  (flatten-1 (map (lambda (k)
        (let ((r (apply multi-list-combination-2 (cdr args))))
          (if (null? r)
        k
        (map (lambda (j)
               (list k j))
             r))))
      (car args))))))


;; combine multiple ordered lists into combinations
;;
;; for example (multi-list-combination '(a b) '(c d)) -> ((a c) (a d) (b c) (b d))
;; or (multi-list-combination '(a b) '(c) '(d e)) -> ((a c d) (a c e) (b c d) (b c e))
;;
(define multi-list-combination
  (lambda args
    (map (lambda (k) (flatten k)) (apply multi-list-combination-2 args))))


(define factorial
   (lambda (x)
      (if (< x 0)
    (log-error 'Factorial 'does 'not 'accept 'negative 'numbers)
    (if (<= x 1) 1
        (* x (factorial (- x 1)))))))


(define range-limit
   (lambda (value min max)
      (cond ((< value min) min)
      ((> value max) max)
      (else value))))

(define limit-range range-limit)

;; string formatting macro, taken from SRFI-28 (see
;; http://srfi.schemers.org/srfi-28/srfi-28.html)

;; --Specification--
;; format format-string [obj ...] -> string

;;     Accepts a message template (a Scheme String), and processes it,
;;     replacing any escape sequences in order with one or more
;;     characters, the characters themselves dependent on the
;;     semantics of the escape sequence encountered.

;;     An escape sequence is a two character sequence in the string
;;     where the first character is a tilde '~'. Each escape code's
;;     meaning is as follows:

;;         ~a The corresponding value is inserted into the string as
;;            if printed with display.
;;         ~s The corresponding value is inserted into the string as
;;            if printed with write.
;;         ~% A newline is inserted.
;;         ~~ A tilde '~' is inserted.

;;     ~a and ~s, when encountered, require a corresponding Scheme
;;     value to be present after the format string. The values
;;     provided as operands are used by the escape sequences in order.
;;     It is an error if fewer values are provided than escape
;;     sequences that require them.

;;     ~% and ~~ require no corresponding value.
(define format
  (lambda (format-string . objects)
    (let ((buffer (open-output-string)))
      (let loop ((format-list (string->list format-string))
                 (objects objects))
        (cond ((null? format-list) (get-output-string buffer))
              ((char=? (car format-list) #\~)
               (if (null? (cdr format-list))
                   (error 'format "Incomplete escape sequence")
                   (case (cadr format-list)
                     ((#\a)
                      (if (null? objects)
                          (error 'format "No value for escape sequence")
                          (begin
                            (display (car objects) buffer)
                            (loop (cddr format-list) (cdr objects)))))
                     ((#\s)
                      (if (null? objects)
                          (error 'format "No value for escape sequence")
                          (begin
                            (write (car objects) buffer)
                            (loop (cddr format-list) (cdr objects)))))
                     ((#\%)
                      (newline buffer)
                      (loop (cddr format-list) objects))
                     ((#\~)
                      (write-char #\~ buffer)
                      (loop (cddr format-list) objects))
                     (else
                      (error 'format "Unrecognized escape sequence")))))
              (else (write-char (car format-list) buffer)
                    (loop (cdr format-list) objects)))))))

(define list-position
   (lambda (obj lst)
      (let loop ((i 0) (lst lst))
   (if (null? lst) #f
       (if (eqv? (car lst) obj) i
     (loop (+ i 1) (cdr lst)))))))



(define-macro (defstruct s . ff)
   (let ((ss (symbol->string s)) (n (length ff)))
      (let* ((n1 (+ n 1))
       (vv (make-vector n1)))
   (let loop ((i 1) (ff ff))
      (if (<= i n)
    (let ((f (car ff)))
       (vector-set! vv i (if (pair? f) (cadr f) '(if #f #f)))
       (loop (+ i 1) (cdr ff)))))
   (let ((ff (map (lambda (f) (if (pair? f) (car f) f)) ff)))
      `(begin (define ,(string->symbol (string-append "make" "-" ss))
           (lambda fvfv
        (let ((st (make-vector ,n1)) (ff ',ff))
           (vector-set! st 0 ',s)
           ,@(let loop ((i 1) (r '()))
          (if (>= i n1) r
              (loop (+ i 1)
              (cons `(vector-set! st ,i
                ,
                (vector-ref vv i))
              r))))
           (let loop ((fvfv fvfv))
        (if (not (null? fvfv))
            (begin  (vector-set! st
               (+ (list-position (car fvfv) ff)
                  1)
               (cadr fvfv))
              (loop (cddr fvfv)))))
           st)))
        ,@(let loop ((i 1) (procs '()))
       (if (>= i n1) procs
           (loop (+ i 1)
           (let ((f (symbol->string (list-ref ff (- i 1)))))
              (cons `(define ,(string->symbol (string-append ss "." f))
            (lambda (x) (vector-ref x ,i)))
              (cons `(define ,(string->symbol (string-append "set!" ss "." f))
                  (lambda (x v)
               (vector-set! x ,i v)))
              procs))))))
        (define ,(string->symbol (string-append ss "?"))
           (lambda (x)
        (and (vector? x)
             (eqv? (vector-ref x 0) ',s)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define bench
  (lambda (func . args)
    (let* ((t (clock:clock))
          (res (apply func args)))
      (- (clock:clock) t))))

(define-macro (benchmark expr)
  `(let* ((t (clock:clock))
          (res ,expr))
     (- (clock:clock) t)))

(define sys:livecoding-error-hook?
   (lambda (on?)
      (if on?
    (set! *error-hook* '())
    (set! *error-hook* throw))))

;; this for buffered version
(define _dsp:set!
  (lambda (zerolatency? name . args)
    (println 'zerolatency: zerolatency?)
    (let* ((nn (if (symbol? name) (symbol->string name) name))
           (ft (impc:ti:get-closure-arg-types nn))
           (ct (if ft
                   (map (lambda (x) (impc:ir:get-type-from-str x)) ft)
                   (log-error 'Function name 'does 'not 'exist 'or 'is 'not 'compiled))))
      (cond ((equal? ct (list *impc:ir:void*
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              (+ *impc:ir:si8* *impc:ir:pointer*)))
             (sys:set-dsp-wrapper-array (llvm:get-function-pointer "imp_dsp_wrapper_array"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:double*
                              *impc:ir:double*
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:double* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dsp-wrapper (llvm:get-function-pointer "imp_dsp_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:double*
                              (+ *impc:ir:double* *impc:ir:pointer*)
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:double* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dspmt-wrapper (llvm:get-function-pointer "imp_dsp_sum_wrapper")
                                    (llvm:get-function-pointer "imp_dsp_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio (length args) zerolatency?)
             )
            ((equal? ct (list *impc:ir:float*
                              *impc:ir:float*
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:float* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dsp-wrapper (llvm:get-function-pointer "imp_dspf_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:float*
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:float* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dspmt-wrapper (llvm:get-function-pointer "imp_dspf_sum_wrapper")
                                    (llvm:get-function-pointer "imp_dspf_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio (length args) zerolatency?)
             )
            ((equal? ct (list *impc:ir:void*
                              (+ *impc:ir:float* *impc:ir:pointer* *impc:ir:pointer*)
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              (+ *impc:ir:si8* *impc:ir:pointer*))) ;; buffer by buffer
             (sys:set-dspmt-wrapper-array (llvm:get-function-pointer "imp_dsp_sum_wrapper_array")
                                          (llvm:get-function-pointer "imp_dsp_wrapper_array"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio-buf (length args) zerolatency?)
             )
            (else (log-error 'Bad 'closure 'signature 'for 'dsp:set! ct))))))

(define-macro (dsp:set! . names)
  (let ((zerolatency (if (boolean? (car names))
                         (car names)
                         #t))
        (lst (map (lambda (n) (symbol->string (eval `(,n 'xtlang))))
                  (if (boolean? (car names))
                      (cdr names)
                      names))))
    `(_dsp:set! ,zerolatency ,@lst)))

;; filename wrangling

(define sys:file-path-components
  (lambda (file-path)
    (let ((base (regex:matched file-path "(.*)/(.*)\\.(.*)")))
      (and (not (null? base))
           (cdr base)))))

;;;;;;;;;;;;;;;;;
;; comlist.xtm ;;
;;;;;;;;;;;;;;;;;

;Permission to copy this software, to modify it, to redistribute it,
;to distribute modified versions, and to use it for any purpose is
;granted, subject to the following restrictions and understandings.
;
;1.  Any copy made of this software must include this copyright notice
;in full.
;
;2.  I have made no warranty or representation that the operation of
;this software will be error-free, and I am under no obligation to
;provide any services, by way of maintenance, update, or otherwise.
;
;3.  In conjunction with products arising from the use of this
;material, there shall be no use of my name in any advertising,
;promotional, or sales literature without prior written consent in
;each case.

;;; Some of these functions may be already defined in your Scheme.
;;; Comment out those definitions for functions which are already defined.

;;;; LIST FUNCTIONS FROM COMMON LISP

(define (cl:assoc-adjoin pair lst)
   (if (assoc (car pair) lst)
       lst
       (cons pair lst)))

;; with precedence to first lst
(define cl:assoc-union
  (letrec ((onion (lambda (lst1 lst2)
         (if (null? lst1)
       lst2
       (onion (cdr lst1) (cl:assoc-adjoin (car lst1) lst2))))))
     (lambda (lst1 lst2)
  (cond ((null? lst1) lst2)
        ((null? lst2) lst1)
        (else (onion (reverse lst2) lst1))))))


;;; Some tail-recursive optimizations made by
;;; Colin Walters <walters@cis.ohio-state.edu>
;;; AGJ restored order July 2001.

;;;@ From: hugh@ear.mit.edu (Hugh Secker-Walker)
(define (cl:make-list k . init)
  (set! init (if (pair? init) (car init)))
  (do ((k (+ -1 k) (+ -1 k))
       (result '() (cons init result)))
      ((negative? k) result)))



(define (cl:tree-copy tree)
  (let loop ((tree tree))
    (if (pair? tree)
  (cons (loop (car tree)) (loop (cdr tree)))
  tree)))

;@
(define (cl:copy-list lst) (append lst '()))
;@
(define (cl:adjoin obj lst) (if (member obj lst) lst (cons obj lst)))
;@
(define cl:union
  (letrec ((onion
      (lambda (lst1 lst2)
        (if (null? lst1)
      lst2
      (onion (cdr lst1) (cl:adjoin (car lst1) lst2))))))
    (lambda (lst1 lst2)
      (cond ((null? lst1) lst2)
      ((null? lst2) lst1)
      ((null? (cdr lst1)) (cl:adjoin (car lst1) lst2))
      ((null? (cdr lst2)) (cl:adjoin (car lst2) lst1))
      ((< (length lst2) (length lst1)) (onion (reverse lst2) lst1))
      (else (onion (reverse lst1) lst2))))))
;@
(define (cl:intersection lst1 lst2)
   (if (null? lst2)
       lst2
       (let build-intersection ((lst1 lst1)
        (result '()))
    (cond ((null? lst1)
     (if (null? result)
         '()
         (reverse result)))
    ((member (car lst1) lst2)
     (build-intersection (cdr lst1) (cons (car lst1) result)))
    (else (build-intersection (cdr lst1) result))))))
;@
(define (cl:set-difference lst1 lst2)
  (if (null? lst2)
      lst1
      (let build-difference ((lst1 lst1)
           (result '()))
  (cond ((null? lst1) (reverse result))
        ((member (car lst1) lst2) (build-difference (cdr lst1) result))
        (else (build-difference (cdr lst1) (cons (car lst1) result)))))))
;@
(define (cl:subset? lst1 lst2)
  (or (eq? lst1 lst2)
      (let loop ((lst1 lst1))
  (or (null? lst1)
      (and (member (car lst1) lst2)
     (loop (cdr lst1)))))))
;@
(define (cl:position obj lst)
  (define pos (lambda (n lst)
    (cond ((null? lst) #f)
          ((equal? obj (car lst)) n)
          (else (pos (+ 1 n) (cdr lst))))))
  (pos 0 lst))
;@
(define (cl:reduce-init pred? init lst)
  (if (null? lst)
      init
      (cl:reduce-init pred? (pred? init (car lst)) (cdr lst))))
;@
(define (cl:reduce pred? lst)
  (cond ((null? lst) lst)
  ((null? (cdr lst)) (car lst))
  (else (cl:reduce-init pred? (car lst) (cdr lst)))))
;@
(define (cl:some pred lst . rest)
  (cond ((null? rest)
   (let mapf ((lst lst))
     (and (not (null? lst))
    (or (pred (car lst)) (mapf (cdr lst))))))
  (else (let mapf ((lst lst) (rest rest))
    (and (not (null? lst))
         (or (apply pred (car lst) (map car rest))
       (mapf (cdr lst) (map cdr rest))))))))
;@
(define (cl:every pred lst . rest)
  (cond ((null? rest)
   (let mapf ((lst lst))
     (or (null? lst)
         (and (pred (car lst)) (mapf (cdr lst))))))
  (else (let mapf ((lst lst) (rest rest))
    (or (null? lst)
        (and (apply pred (car lst) (map car rest))
       (mapf (cdr lst) (map cdr rest))))))))
;@
(define (cl:notany pred . ls) (not (apply cl:some pred ls)))
;@
(define (cl:notevery pred . ls) (not (apply cl:every pred ls)))
;@
(define (cl:list-of?? predicate . bound)
  (define (errout) (apply slib:error 'list-of?? predicate bound))
  (case (length bound)
    ((0)
     (lambda (obj)
       (and (list? obj)
      (cl:every predicate obj))))
    ((1)
     (set! bound (car bound))
     (cond ((negative? bound)
      (set! bound (- bound))
      (lambda (obj)
        (and (list? obj)
       (<= bound (length obj))
       (cl:every predicate obj))))
     (else
      (lambda (obj)
        (and (list? obj)
       (<= (length obj) bound)
       (cl:every predicate obj))))))
    ((2)
     (let ((low (car bound))
     (high (cadr bound)))
       (cond ((or (negative? low) (negative? high)) (errout))
       ((< high low)
        (set! high (car bound))
        (set! low (cadr bound))))
       (lambda (obj)
   (and (list? obj)
        (<= low (length obj) high)
        (cl:every predicate obj)))))
    (else (errout))))
;@
(define (cl:find-if pred? lst)
  (cond ((null? lst) #f)
  ((pred? (car lst)) (car lst))
  (else (cl:find-if pred? (cdr lst)))))
;@
(define (cl:member-if pred? lst)
  (cond ((null? lst) #f)
  ((pred? (car lst)) lst)
  (else (cl:member-if pred? (cdr lst)))))
;@
(define (cl:remove obj lst)
  (define head (list '*head*))
  (let remove ((lst lst)
         (tail head))
    (cond ((null? lst))
    ((eqv? obj (car lst)) (remove (cdr lst) tail))
    (else
     (set-cdr! tail (list (car lst)))
     (remove (cdr lst) (cdr tail)))))
  (cdr head))
;@
(define (cl:remove-if pred? lst)
  (let remove-if ((lst lst)
      (result '()))
    (cond ((null? lst) (reverse result))
    ((pred? (car lst)) (remove-if (cdr lst) result))
    (else (remove-if (cdr lst) (cons (car lst) result))))))
;@
(define (cl:remove-if-not pred? lst)
  (let remove-if-not ((lst lst)
          (result '()))
    (cond ((null? lst) (reverse result))
    ((pred? (car lst)) (remove-if-not (cdr lst) (cons (car lst) result)))
    (else (remove-if-not (cdr lst) result)))))
;@
(define cl:nconc
      (lambda args
  (cond ((null? args) '())
        ((null? (cdr args)) (car args))
        ((null? (car args)) (apply cl:nconc (cdr args)))
        (else
         (set-cdr! (last-pair (car args))
       (apply cl:nconc (cdr args)))
         (car args)))))

;;;@ From: hugh@ear.mit.edu (Hugh Secker-Walker)
(define (cl:nreverse rev-it)
;;; Reverse order of elements of LIST by mutating cdrs.
  (cond ((null? rev-it) rev-it)
  ((not (list? rev-it))
   (slib:error "nreverse: Not a list in arg1" rev-it))
  (else (do ((reved '() rev-it)
       (rev-cdr (cdr rev-it) (cdr rev-cdr))
       (rev-it rev-it rev-cdr))
      ((begin (set-cdr! rev-it reved) (null? rev-cdr)) rev-it)))))
;@
(define (cl:last lst n)
  (cl:nthcdr (- (length lst) n) lst))
;@
(define (cl:butlast lst n)
  (cl:butnthcdr (- (length lst) n) lst))
;@
(define (cl:nthcdr n lst)
  (if (zero? n) lst (cl:nthcdr (+ -1 n) (cdr lst))))
;@
(define (cl:butnthcdr k lst)
  (cond ((negative? k) lst) ;(slib:error "negative argument to butnthcdr" k)
          ; SIMSYNCH FIFO8 uses negative k.
  ((or (zero? k) (null? lst)) '())
  (else (let ((ans (list (car lst))))
    (do ((lst (cdr lst) (cdr lst))
         (tail ans (cdr tail))
         (k (+ -2 k) (+ -1 k)))
        ((or (negative? k) (null? lst)) ans)
      (set-cdr! tail (list (car lst))))))))

;;;; CONDITIONALS
;@
(define (cl:and? . args)
  (cond ((null? args) #t)
  ((car args) (apply cl:and? (cdr args)))
  (else #f)))
;@
(define (cl:or? . args)
  (cond ((null? args) #f)
  ((car args) #t)
  (else (apply cl:or? (cdr args)))))

;;;@ Checks to see if a list has any duplicate MEMBERs.
(define (cl:has-duplicates? lst)
  (cond ((null? lst) #f)
  ((member (car lst) (cdr lst)) #t)
  (else (cl:has-duplicates? (cdr lst)))))


;;;@ remove duplicates of MEMBERs of a list
(define cl:remove-duplicates
   (letrec ((rem-dup  (lambda (lst nlst)
       (cond ((null? lst) (if (null? nlst) nlst (reverse nlst)))
             ((member (car lst) nlst) (rem-dup (cdr lst) nlst))
             (else (rem-dup (cdr lst) (cons (car lst) nlst)))))))
      (lambda (lst)
   (rem-dup lst '()))))

;;;@ keep only MEMBERs of a list which occur more than once
(define cl:duplicates
  (lambda (lst)
    (let loop ((rem lst)
               (dupes '()))
      (if (null? rem)
          (reverse dupes)
          (loop (cdr rem)
                (if (member (car rem) (cdr rem))
                    (cons (car rem) dupes)
                    dupes))))))

;@
(define cl:list*
  (letrec ((list*1 (lambda (obj)
         (if (null? (cdr obj))
       (car obj)
       (cons (car obj) (list*1 (cdr obj)))))))
    (lambda (obj1 . obj2)
      (if (null? obj2)
    obj1
    (cons obj1 (list*1 obj2))))))
;@
(define (cl:atom? obj)
  (not (pair? obj)))
;@
(define (cl:delete obj lst)
  (let delete ((lst lst))
    (cond ((null? lst) '())
    ((equal? obj (car lst)) (delete (cdr lst)))
    (else
     (set-cdr! lst (delete (cdr lst)))
     lst))))
;@
(define (cl:delete-if pred lst)
  (let delete-if ((lst lst))
    (cond ((null? lst) '())
    ((pred (car lst)) (delete-if (cdr lst)))
    (else
     (set-cdr! lst (delete-if (cdr lst)))
     lst))))
;@
(define (cl:delete-if-not pred lst)
  (let delete-if ((lst lst))
    (cond ((null? lst) '())
    ((not (pred (car lst))) (delete-if (cdr lst)))
    (else
     (set-cdr! lst (delete-if (cdr lst)))
     lst))))

;;;;;;;;;;;;;;
;; sort.xtm ;;
;;;;;;;;;;;;;;

;;; "sort.xtm" Defines: sorted?, merge, merge!, sort, sort!
;;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;;;
;;; This code is in the public domain.

;;; Updated: 11 June 1991
;;; Modified for scheme library: Aubrey Jaffer 19 Sept. 1991
;;; Updated: 19 June 1995
;;; (sort, sort!, sorted?): Generalized to strings by jaffer: 2003-09-09
;;; (sort, sort!, sorted?): Generalized to arrays by jaffer: 2003-10-04
;;; Modified by Andrew Sorensen for Impromptu 2006-05-10

;;; (cl:sorted? sequence less?)
;;; is true when sequence is a list (x0 x1 ... xm) or a vector #(x0 ... xm)
;;; such that for all 1 <= i <= m,
;;;	(not (less? (list-ref list i) (list-ref list (- i 1)))).
;@
(define (cl:sorted? seq less?)
  (cond ((null? seq) #t)
  (else (let loop ((last (car seq)) (next (cdr seq)))
     (or (null? next)
         (and (not (less? (car next) last))
        (loop (car next) (cdr next))))))))

;;; (cl:merge a b less?)
;;; takes two lists a and b such that (sorted? a less?) and (sorted? b less?)
;;; and returns a new list in which the elements of a and b have been stably
;;; interleaved so that (sorted? (merge a b less?) less?).
;;; Note:  this does _not_ accept arrays.  See below.
;@
(define (cl:merge a b less?)
  (cond ((null? a) b)
  ((null? b) a)
  (else (let loop ((x (car a)) (a (cdr a)) (y (car b)) (b (cdr b)))
    ;; The loop handles the merging of non-empty lists.  It has
    ;; been written this way to save testing and car/cdring.
    (if (less? y x)
        (if (null? b)
      (cons y (cons x a))
      (cons y (loop x a (car b) (cdr b))))
        ;; x <= y
        (if (null? a)
      (cons x (cons y b))
      (cons x (loop (car a) (cdr a) y b))))))))

;;; (cl:merge! a b less?)
;;; takes two sorted lists a and b and smashes their cdr fields to form a
;;; single sorted list including the elements of both.
;;; Note:  this does _not_ accept arrays.
;@
(define (cl:merge! a b less?)
  (define (loop r a b)
    (if (less? (car b) (car a))
  (begin (set-cdr! r b)
    (if (null? (cdr b))
        (set-cdr! b a)
        (loop b a (cdr b))))
  ;; (car a) <= (car b)
  (begin (set-cdr! r a)
    (if (null? (cdr a))
        (set-cdr! a b)
        (loop a (cdr a) b)))))
  (cond ((null? a) b)
  ((null? b) a)
  ((less? (car b) (car a))
   (if (null? (cdr b))
       (set-cdr! b a)
       (loop b a (cdr b)))
   b)
  (else (if (null? (cdr a))
       (set-cdr! a b)
       (loop a (cdr a) b))
   a)))

;;; (cl:sort! sequence less?)
;;; sorts the list, array, or string sequence destructively.  It uses
;;; a version of merge-sort invented, to the best of my knowledge, by
;;; David H. D.  Warren, and first used in the DEC-10 Prolog system.
;;; R. A. O'Keefe adapted it to work destructively in Scheme.
;@
(define (cl:sort! seq less?)
  (define (step n)
    (cond ((> n 2)
     (let* ((j (quotient n 2))
      (a (step j))
      (k (- n j))
      (b (step k)))
       (cl:merge! a b less?)))
    ((= n 2)
     (let ((x (car seq))
     (y (cadr seq))
     (p seq))
       (set! seq (cddr seq))
       (cond ((less? y x)
        (set-car! p y)
        (set-car! (cdr p) x)))
       (set-cdr! (cdr p) '())
       p))
    ((= n 1)
     (let ((p seq))
       (set! seq (cdr seq))
       (set-cdr! p '())
       p))
    (else '())))
   (step (length seq)))

;;; (cl:sort sequence less?)
;;; sorts a array, string, or list non-destructively.  It does this
;;; by sorting a copy of the sequence.  My understanding is that the
;;; Standard says that the result of append is always "newly
;;; allocated" except for sharing structure with "the last argument",
;;; so (append x '()) ought to be a standard way of copying a list x.
;@
(define (cl:sort seq less?)
  (cond ((vector? seq)
   (list->vector (cl:sort! (vector->list seq) less?)))
  ((string? seq)
   (list->string (cl:sort! (string->list seq) less?)))
  (else (cl:sort! (append seq '()) less?))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load which safely breaks on calling sys:load-escape
;;
(define *sys:load-escape-stack* (list *sys:toplevel-continuation*))

(define sys:load-escape
  (lambda (msg)
    (let ((k (car *sys:load-escape-stack*)))
      (if (not (equal? *sys:toplevel-continuation* k))
          (set! *sys:load-escape-stack* (cdr *sys:load-escape-stack*)))
      (k msg))))

(define sys:load-preload-check
  (lambda (libname)
    (if (not (or (symbol? libname) (string? libname)))
        (sys:load-escape "Error: lib-name must be symbol or string."))
    (if (not (string=? (ipc:get-process-name) "primary"))
        (sys:load-escape "Error: xtlang code must be compiled in the primary process."))
    (if (defined? (string->symbol (string-append "*xtmlib-" (atom->string libname) "-loaded*")))
        (sys:load-escape (string-append (atom->string libname) " already loaded")))))

(define file-exists?
  (lambda (path)
    (let ((in-port (open-input-file path)))
      (if in-port
          (begin (close-input-port in-port)
                 #t)
          #f))))

(define filename-from-path
  (lambda (path)
    (car (reverse (regex:split path "/")))))

(define filename-strip-extension
  (lambda (path)
    (car (regex:split path "[.]"))))

;; this is incredibly slow! use sys:slurp-file instead
(define file->string
  (lambda (path)
    (let ((in (open-input-file path))
          (out (make-string 0)))
      (if in
          (let loop ((char (read-char in)))
            (if (not (eof-object? char))
                (begin (emit (string char) out)
                       (loop (read-char in)))
                (begin (close-port in)
                       out)))
          (begin (print-with-colors 'red 'default #t
                                    (print "Error opening file: "))
                 (print path "\n")
                 #f)))))

;; sys:load and friends

(define *global-sysload-evals* (make-list-with-proc 10 (lambda (i) #f)))

(define sys:load
  (lambda (path . quiet?)
    (let ((file-string (or (sys:slurp-file path)
                           (sys:slurp-file (string-append (sys:share-dir) "/" path))))
          (cnt 0))
      (if (not file-string)
          (if (or (null? quiet?) (not (car quiet?)))
              (begin (print-with-colors 'red 'default #t (print "File Error"))
                     (print " couldn't find file ")
                     (print-with-colors 'blue 'default #f (print path "\n"))
                     #f)
              #f)
          (let ((input (open-input-string file-string))
                (msg (call/cc
                      (lambda (k)
                        (set! *sys:load-escape-stack* (cons k *sys:load-escape-stack*))
                        ""))))
            (if (string=? msg "")
                (begin
                  (let loop ((sexpr (read input)))
                    (if (not (eof-object? sexpr))
                        (begin
                          (set! *global-sysload-evals* (cons sexpr *global-sysload-evals*))
                          (set! *global-sysload-evals* (list-head *global-sysload-evals* 10))
                          (eval (car *global-sysload-evals*) (interaction-environment))
                          (loop (read input)))))
                  (close-input-port input)
                  (set! *sys:load-escape-stack* (cdr *sys:load-escape-stack*))
                  #t)
                (let ((words (regex:split msg " ")))
                  (if (or (null? quiet?) (not (car quiet?)))
                      (begin (print-with-colors 'yellow 'default #t (print "sys:load notification "))
                             (for-each (lambda (w) (print w "")) words)
                             (println)))
                  (close-port input)
                  #f)))))))

;; load, then wait 10s and quit
(define sys:load-then-quit
  (lambda (filename delay-in-sec)
    (begin
     (sys:load filename)
     (callback (+ (now) (* *second* delay-in-sec)) quit 0))))

(define range
  (lambda args
    (cond ((= (length args) 1)
     (make-list-with-proc (car args)  (lambda (i) i)))
    ((= (length args) 2)
     (make-list-with-proc (- (cadr args) (car args)) (lambda (i) (+ (car args) i))))
    ((= (length args) 3)
     (make-list-with-proc (/ (- (cadr args) (car args)) (caddr args))
        (lambda (i) (+ (car args) (* i (caddr args))))))
    (else (println 'bad 'range!) '()))))

;; (define-macro (inc x y)
;;   `(set! ,x (+ ,x ,y)))

;; (define-macro (dec x y)
;;   `(set! ,x (- ,x ,y)))

;; (define-macro (min x y)
;;   `(if (< ,x ,y) ,x ,y))

;; (define-macro (max x y)
;;   `(if (> ,x ,y) ,x ,y))

(define-macro (clamp x minval maxval)
  `(if (> ,x ,maxval) ,maxval
       (if (< ,x ,minval) ,minval
           ,x)))



;; load the test infrastructure on startup - it's so important to
;; minimise the friction for testing things (and adding new tests to
;; the test suite)
;; (load (string-append (sys:share-dir) "/libs/core/test.xtm"))

;; embed here instead of loading

;; These functions & macros provide a basic unit testing framework for
;; Extempore - load before running any of the other .xtm files in
;; tests/

;; To write a test, use the xtmtest macro. Usage examples:

;; (xtmtest '(bind-func compile_fn ; this is the function definition
;;             (lambda ()               ; this is the function definition
;;               (* 3 8)))         ; this is the function definition
;;          (compile_fn))          ; this is how to call it

;; (xtmtest '(bind-func no_compile_fn ; this is the function definition
;;             (lambda ()                  ; this is the function definition
;;               (* 3 8.0)))          ; this is the function definition
;;          (no_compile_fn))          ; this is how to call it

;; (xtmtest '(bind-func incorrect_fn ; this is the function definition
;;             (lambda ()                 ; this is the function definition
;;               (* 3 4)))           ; this is the function definition
;;          (incorrect_fn)           ; this is how to call it
;;          13)                      ; this is the expected return value

;; (xtmtest '(bind-func correct_fn ; this is the function definition
;;             (lambda ()               ; this is the function definition
;;               (* 3 4)))         ; this is the function definition
;;          (correct_fn)           ; this is how to call it
;;          12)                    ; this is the expected return value

;; ;; print the results
;; (xtmtest-print-results)

;; For more examples, see the test files in the tests/ subdirectory

;;; Code:

(define xtmtest-reset-results
  (lambda ()
    (set! *xtmtest-results*
          '((correct)
            (incorrect)
            (compile)
            (no-compile)))))

(define *xtmtest-results* '())

(xtmtest-reset-results)

(define xtmtest-update-test-result
  (lambda (func-sym label call expected got)
    (let ((tail (assoc label *xtmtest-results*))
          (reslist (list func-sym call expected got)))
      (set-cdr! tail
                (cons reslist
                      (cl:remove-if (lambda (res) (equal? res reslist))
                                    (cdr tail)))))
    (print "result: ")
    (print-with-colors (case label
                         ('correct 'green)
                         ('incorrect 'magenta)
                         ('compile 'yellow)
                         ('no-compile ' red))
                       'default #t (print label "\n"))))

;; some tests are supposed to fail compilation (type check catch for example)
;; by passing 'copmile-should-fail as expected-result the failure will be marked as success
(define-macro (xtmtest form call . expected-result)
  `(let ((func-sym (quote ,(car call)))
         (exp-res ,(if (null? expected-result)
                       #f
                       (car expected-result))))
     (print-with-colors 'cyan 'default #t (print "xtmtest "))
     (print-with-colors 'black 'cyan #t (print "" func-sym ""))
     (println)
     (catch (if (and (symbol? exp-res)
                     (equal? exp-res 'compile-should-fail))
                (xtmtest-update-test-result func-sym 'correct ',call #f #f)
                (xtmtest-update-test-result func-sym 'no-compile ',call #f #f))
            (eval ',form (interaction-environment))
            (catch (xtmtest-update-test-result func-sym 'compile ',call #f #f)
                   (let ((result (eval ',call (interaction-environment))))
                     (if (or (not exp-res) (equal? exp-res result))
                         (xtmtest-update-test-result func-sym 'correct ',call exp-res result)
                         (xtmtest-update-test-result func-sym 'incorrect ',call exp-res result)))))))

(define-macro (xtmtest-compile form)
  `(let ((func-sym (quote ,(cadr form))))
     (print-with-colors 'cyan 'default #t (print "xtmtest "))
     (print-with-colors 'black 'cyan #t (print "" func-sym ""))
     (println)
     (catch (xtmtest-update-test-result func-sym 'no-compile 'compile-only #f #f)
            (eval ',form (interaction-environment))
            (xtmtest-update-test-result func-sym 'correct 'compile-only #t #t))))

(define (xtmtest-result-body call expected-result extra)
  (let ((prefix (if (null? extra) "" (format "~a: " (car extra)))))
    `(let ((evaluation-environment (current-environment))
           (test-name (format "~a ~a" ,prefix ',(if (pair? call) (car call) call))))
       (print-with-colors 'cyan 'default #t (print "xtmtest "))
       (print-with-colors 'black 'cyan #t (print "" test-name ))
       (println)
       (catch (xtmtest-update-test-result test-name ',call 'compile #f #f)
              (let ((result (eval ',call evaluation-environment)))
                (if (equal? ,expected-result result)
                    (xtmtest-update-test-result ',prefix 'correct ',call ,expected-result result)
                    (xtmtest-update-test-result ',prefix 'incorrect ',call ,expected-result result))))))  )

(define-macro (xtmtest-result call expected-result . extra)
  (xtmtest-result-body call expected-result extra))


(define xtmtest-print-results
  (lambda ()
    (println)
    (print-with-colors 'black 'blue #t (print " Test results "))
    (print "\n\n")
    (for-each (lambda (label-list)
                (if (> (length label-list) 1)
                    (begin
                      (print-with-colors 'blue 'default #t (print (car label-list) "\n\n"))
                      (for-each (lambda (reslist)
                                  (print "  name: ")
                                  (print-with-colors (case (car label-list)
                                                       ('correct 'green)
                                                       ('incorrect 'magenta)
                                                       ('compile 'yellow)
                                                       ('no-compile ' red))
                                                     'default #f (print (car reslist)))
                                  (print " call: ")
                                  (print-with-colors 'blue 'default #f (print (cadr reslist)))
                                  (if (caddr reslist)
                                      (begin (print " result:" (caddr reslist))
                                             (if (not (equal? (car label-list) 'correct))
                                                 (print " expecting:" (cadddr reslist)))))
                                  (println))
                                (cdr label-list))))
                (println))
              *xtmtest-results*)))


;; a helper for running test files (in tests/)

(define xtmtest-run-tests
  (lambda (test-files print? quit-on-exit?)
    (let ((timeout (sys:get-default-timeout)))
      (sys:set-default-timeout (* 60 44100 60)) ;; 1 hour timeout
      (sys:load "libs/core/test.xtm" 'quiet)
      (xtmtest-reset-results)
      (if (string? test-files)
          (set! test-files (list test-files)))
      (let ((start (now)))
        (for-each (lambda (tf)
                    (sys:load tf))
                  test-files)
        (if print? (xtmtest-print-results))
        (print "\nCompleted ")
        (print-with-colors 'blue 'default #t
                           (print (apply + (map (lambda (lab) (- (length lab) 1))
                                                *xtmtest-results*))))
        (print " tests in ")
        (let ((dur-sec (/ (- (now) start) *au:samplerate* 1.0)))
          (print-with-colors 'yellow 'default #t
                             (print (if (> dur-sec 60) (/ dur-sec 60) dur-sec)))
          (print (if (> dur-sec 60)
                     " minutes.\n\n"
                     " seconds.\n\n"))))
      (if quit-on-exit?
          (quit (if (cl:some (lambda (label-list)
                               (and (not (equal? (car label-list) 'correct))
                                    (> (length label-list) 1)))
                             *xtmtest-results*)
                    (begin (print-with-colors 'red 'default #t
                                              (print "Some tests failed :(\n"))
                           1)
                    (begin (print-with-colors 'green 'default #t
                                              (print "All tests passed :)\n"))
                           0)))
          ;; if not quitting, set the timeout back
          (sys:set-default-timeout timeout)))))

;;; xmttest-with-fixture

(define (xtmtest-with-fixture-body name fixture tests)
  `(let ((fixture-environment ((lambda () (current-environment)))))
     (let ((suite-name ',name))
       (print-with-colors 'cyan 'default #t (print "xtmtest "))
       (print-with-colors 'black 'cyan #t (print "" suite-name))
       (println)
       (eval `(begin
                (define-macro (is? call expected-result . args)
                  (xtmtest-result-body call
                                       expected-result
                                       (list (if (not (null? args))
                                                 (format "~a.~a" ',suite-name (car args))
                                                 (format "~a.is?" ',suite-name))))))
             fixture-environment)
       (catch (xtmtest-update-test-result suite-name 'no-compile ',fixture #f #f)
              (eval ',fixture fixture-environment)
              (eval '(begin ,@tests) fixture-environment)))))


(define-macro (xtmtest-with-fixture name fixture . tests)
  (xtmtest-with-fixture-body name fixture tests))
