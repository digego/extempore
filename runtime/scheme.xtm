;;;;;;;;;;;;;;;;;;;
;; extempore.xtm ;;
;;;;;;;;;;;;;;;;;;;

;; includes "comlist.xtm" Implementation of COMMON LISP list functions for Scheme
;; Copyright (C) 1991, 1993, 1995, 2001, 2003 Aubrey Jaffer.
;; Copyright (C) 2000 Colin Walters

;; also includes "sort.xtm" Defines: sorted?, merge, merge!, sort, sort!
;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;; this code is in the public domain

;; All other code Copyright (c) 2011, Andrew Sorensen
;;
;;  All rights reserved
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; 1. Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;;
;; 2. Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;;
;; Neither the name of the authors nor other contributors may be used to endorse
;; or promote products derived from this software without specific prior written
;; permission.
;;
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLEXTD. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.

;; pretty printing

(define-macro (print-with-colors fg bg bold . body)
  `(let ((colors '((black . 0)
		   (red . 1)
		   (green . 2)
		   (yellow . 3)
		   (blue . 4)
		   (magenta . 5)
		   (cyan . 6)
		   (white . 7)
		   (default . 10)
		   (none . 10))))
     (ascii-print-color (if ,bold 1 0)
			(cdr (assoc ,fg colors))
			(cdr (assoc ,bg colors)))
     ,@body
     ;; return colors to normal
     (ascii-print-color 0 7 10)))

(define print-error
	(lambda args
		(apply pprint-error args)
		(error "")))

;;
;; GENERAL UTILITY FUNCTIONS AND VARS
;;

(define remove-all
   (lambda (obj lst)
      (cond ((null? lst)
	     '())
	    ((list? (car lst))
	     (cons (remove-all obj (car lst))
		   (remove-all obj (cdr lst))))
	    ((equal? obj (car lst))
	     (remove-all obj (cdr lst)))
	    (else (cons (car lst) (remove-all obj (cdr lst)))))))


(define (tree-copy tree)
  (let loop ((tree tree))
    (if (pair? tree)
	(cons (loop (car tree)) (loop (cdr tree)))
	tree)))

(define (tree-member mem tree)
  (if (member #t
              (flatten
               (let loop ((tree tree))
                 (if (pair? tree)
                     (cons (loop (car tree)) (loop (cdr tree)))
                     (if (null? tree) '()
                         (if (equal? tree mem) #t #f))))))
      #t #f))

(define remove-first
   (lambda (obj lst)
      (if (member obj lst)
	  (let loop ((new '())
		     (lstb lst))
	     (if (equal? (car lstb) obj)
		 (append new (cdr lstb))
		 (loop (append new (list (car lstb))) (cdr lstb))))
	  lst)))

(define get-named-arg
   (lambda (name args . default-value)
      (let ((value (member name args)))
	 (if value
	     (cadr value)
	     (if (null? default-value)
			     '()
				 (car default-value))))))


(define replace-all
   (lambda (lst alst)
      (if (pair? lst)
	  (let loop ((lsta lst) (lstb '()))
	     (if (null? lsta)
		 (reverse lstb)
		 (let* ((v (car lsta))
			(lstb2 (cond ((pair? v)
				     (cons (loop v '()) lstb))
				    ((assoc v alst)
				     (cons (cdr (assoc v alst)) lstb))
				    (#t (cons v lstb)))))
		    (loop (cdr lsta) lstb2))))
	  lst)))

(define replace-first
   (lambda (obj-a obj-b  lst)
      (if (member obj-a lst)
	  (let loop ((new '())
		     (lstb lst))
	     (if (equal? (car lstb) obj-a)
		 (append new (list obj-b) (cdr lstb))
		 (loop (append new (list (car lstb))) (cdr lstb))))
	  lst)))


(define-macro (dotimes init . body)
   `(if (<= ,(cadr init) 0)
	'()
	(let uri1834ck ((,(car init) 0))
	   ,@body
	   (if (< ,(car init) (- ,(cadr init) 1))
	       (uri1834ck (+ ,(car init) 1))))))

;; Deprectateded because of symbol leak.  see above.
;;(define-macro (dotimes init . body)
;;  `(do (( ,(car init) 0 (+ 1 ,(car init))))
;;       ((= ,(car init) ,(cadr init)))
;;     ,@body))

(define-macro (dotill predicate expression . args)
   (let ((max-iterations (if (null? args) 100000000 (car args))))
      `(let impsym38479k ((cnt 0))
	  (let ((value ,expression))
	     (if ,predicate
		 value
		 (if (> cnt ,max-iterations)
		     (begin (print-notification "Dropping out after max-iterations")
			    'failed)
		     (impsym38479k (+ cnt 1))))))))

(define make-vector-with-proc
   (lambda (num func)
      (let ((new-vector (make-vector num)))
	 (do ((i 0 (+ i 1)))
	     ((= i num) new-vector)
	    (vector-set! new-vector i (func i))))))

(define (make-list lth obj)
  (let loop ((i lth)
	     (lst '()))
     (if (< i 1)
	 lst
		 (loop (- i 1) (cons obj lst)))))

(define (make-list-with-proc lth func)
   (if (< lth 1)
       '()
       (let loop ((i 0)
		  (lst '()))
	  (if (>= i lth)
	      (reverse lst)
	      (loop (+ i 1) (cons (func i) lst))))))

(define (weighted-selection . args)
   (let ((rand (random)))
      (let loop ((lst args)
		 (count 0))
	 (if (< rand (+ count (caar lst)))
	     (cdar lst)
	     (loop (cdr lst) (+ count (caar lst)))))))

(define (random . args)
  (cond ((< (length args) 1)
         (random-real))
        ((list? (car args))
         (list-ref (car args) (random (length (car args)))))
        ((pair? (car args))
         (apply weighted-selection args))
        (else (let ((lower (if (> (length args) 1) (real->integer (car args)) 0))
                    (upper (if (> (length args) 1) (cadr args) (car args))))
                (+ lower (random-int (- upper lower)))))))

;;
;; EXTERNAL CPP STUFF AND CALLBACK FUNCTIONS
;;

(define impromptu_envs '())

(define (callback-adapter sym . args)
	(apply (eval sym) args))

;; send tasks for normal standard task execution
(define (call-cpp . args)
    (call-cpp-at-time (car args) 0 (cadr args) (cddr args) (current-environment)))

;; send tasks for execution in audio thread
;(define (call-render-cpp . args)
;    (call-cpp-at-time (car args) *au:audiounit-queue* (cadr args) (cddr args) (current-environment)))

;; send tasks for normal execution as callback tasks
(define (callback time func . args)
  (let ((payload (if (symbol? func)
		     (cons callback-adapter (cons func args))
					 (cons func args))))
	(call-cpp-at-time time 2 *callback* payload (current-environment))))

;; alias for callback
(define schedule callback)

;;(define (ipc-define proc sym)
;;  (if (symbol? sym)
;;      (if (closure? (eval sym))
;;          (ipc-def proc sym (get-closure-code (eval sym)))
;;          (ipc-def proc sym (eval sym)))
;;      "error: argument 2 must be a symbol"))

;;
;; TIME FUNCTIONS AND GLOBAL VARS
;;

(define *second* *au:samplerate*)
(define *samplerate* *au:samplerate*)
(define *blocksize* *au:block-size*)

(define *minute* (* *second* 60))

(define *hour* (* *minute* 60))

(define clock:offset-from-server
   (lambda (server-proc local-proc)
      (let* ((t1 (clock:clock))
	     (t2 (ipc:call server-proc local-proc 'clock:clock))
	     (t3 t2)
	     (t4 (clock:clock))
	     (msg-delay (- (- t4 t1) (- t2 t3)))
	     (time-offset (/ (+ (- t2 t1) (- t3 t4)) 2)))
	 time-offset)))

(define clock:sync-adjust
   (lambda (server-proc local-proc samples wait-time . args)
      (let loop ((i samples)
		 (lst '()))
	 (sys:sleep wait-time)
	 (if (> i 0)
	     (loop (- i 1)
		   (cons (clock:offset-from-server server-proc local-proc) lst))
	     (let* ((l1 (cddr (cl:sort lst <))) ;; remove bottom 2
		    (l2 (cddr (reverse l1)))) ;; remote top 2
	       ;; check tolerance of return
	       (if (> (math:std-deviation l2)
		      (if (null? args) 0.0005 (car args)))
		   (begin (print-notification "clock sync outside tolerance - making no time adjustment: " (math:std-deviation l2))
			  (print-notification "clock times: " lst))
		   (begin (print-notification 'clock 'successfully 'adjusted 'by (/ (apply + l2) (length l2)) 'seconds)
			  (clock:adjust-offset (/ (apply + l2) (length l2))))))))))


(define -clock:metro-from-host-
   (lambda ()
      (let ((mark (*metro* 'get-mark)))
	 (list (*metro* 'get-tempo)
	       (car mark)
	       (samples->clock (cdr mark))))))


(define clock:update-metro
   (lambda (server-process local-process)
      (let ((res (ipc:call server-process local-process '-clock:metro-from-host-)))
	 (set! *metro* (make-metro (car res)
				   (cons (cadr res)
					 (clock->samples (caddr res))))))))



(define clock:update-metro
   (lambda (server-process local-process)
      (clock:sync-adjust server-process local-process 5 500 .005)
      (let ((res (ipc:call server-process local-process '-clock:metro-from-host-)))
	 (set! *metro* (make-metro (car res)
				   (cons (clock->samples (cadr res))
					 (caddr res)))))))


(define -clock:metro-from-host-
   (lambda ()
      (let ((mark (*metro* 'get-mark)))
	 (println 'mark-remote: mark 'time: (samples->clock (car mark)))
	 (list (*metro* 'get-tempo)
	       (samples->clock (car mark))
	       (cdr mark)))))



;; convert from audio samples to clock
(define samples->clock
   (lambda (time)
      (let* ((c (clock:ad:clock))
	     (t1 (car c))
	     (t2 (cdr c)))
	 (+ t2 (/ (- time t1) *samplerate*)))))


;; convert from clock to audio samples
(define clock->samples
   (lambda (time)
      (let* ((t1 (clock:clock))
	     (t2 (clock:ad:clock))
	     (t3 (round (+ (+ (car t2) (* (- time t1) *samplerate*))
			   (* (- t1 (cdr t2)) *samplerate*)))))
	 (real->integer t3))))


(define (io:osc:send time host-address osc-address . args)
   (call-cpp time *io:osc:send-msg* (car host-address) (cdr host-address) osc-address args))


(define make-envelope
  (lambda (points . args)
     (if (vector? points)
	 (make-envelope-v points (if (null? args) #f (car args)))
	 (make-envelope-l points (if (null? args) #f (car args))))))

(define envelope-segments-l
   (lambda (points)
      (let loop ((lst points)
		 (lines '()))
	 (if (null? (cdr lst))
	     (reverse lines)
	     (let* ((x1 (caar lst))
		    (y1 (cdar lst))
		    (x2 (caadr lst))
		    (y2 (cdadr lst))
		    (m (if (= 0 (- x2 x1)) 0 (/ (- y2 y1) (- x2 x1))))
		    (c (- y2 (* m x2))))
		(loop (cdr lst) (cons (lambda (time) (+ (* m time) c)) lines)))))))

(define make-envelope-l
   (lambda (points whole-num?)
      (let ((lines (envelope-segments-l points)))
	 (lambda (time)
	    (let loop ((p-list (cdr points))
		       (l-list lines))
	       (if (or (<= time (caar p-list))
		       (null? (cdr p-list)))
		   (if whole-num?
		       (real->integer (round ((car  l-list) time)))
		       ((car l-list) time))
		   (loop (cdr p-list) (cdr l-list))))))))

(define envelope-segments-v
   (lambda (points)
      (let loop ((idx 0)
		 (lines '()))
	 (if (>= (+ idx 2) (vector-length points))
	     (reverse lines)
	     (let* ((x1 (vector-ref points idx))
		    (y1 (vector-ref points (+ idx 1)))
		    (x2 (vector-ref points (+ idx 2)))
		    (y2 (vector-ref points (+ idx 3)))
		    (m (if (= 0 (- x2 x1)) 0 (/ (- y2 y1) (- x2 x1))))
		    (c (- y2 (* m x2))))
		(loop (+ idx 2) (cons (lambda (time) (+ (* m time) c)) lines)))))))

(define make-envelope-v
   (lambda (points whole-num?)
      (let ((lines (envelope-segments-v points)))
	 (lambda (time)
	    (let loop ((idx 2)
		       (l-list lines))
	       (if (or (<= time (vector-ref points idx))
		       (null? (cdr l-list)))
		   (if whole-num?
		       (real->integer (round ((car l-list) time)))
		       ((car l-list) time))
		   (loop (+ idx 2) (cdr l-list))))))))

(define random-envelope
   (lambda (duration interval whole-numbers? . args)
      (let* ((lgth (real->integer (/ duration interval)))
	     (v1 (make-vector-with-proc lgth (lambda (i) (* i interval))))
	     (v2 (make-vector-with-proc lgth (lambda (i) (apply random args))))
	     (v3 (make-vector (* 2 lgth))))
	 (math:vector= v3 v1 (list 0 lgth 2))
	 (math:vector= v3 v2 (list 1 lgth 2))
	 (make-envelope-v v3 whole-numbers?))))


(define math:mean
   (lambda (lst)
      (/ (apply + lst) (length lst))))

(define math:std-deviation
   (lambda (lst)
      (sqrt (math:variance lst))))

(define math:variance
   (lambda (lst)
      (let ((m (math:mean lst)))
	 (let loop ((l lst)
		    (v 0))
	    (if (null? l)
		(/ v (length lst))
		(let ((var (- (car l) m)))
		   (loop (cdr l) (+ v (* var var)))))))))


;; function must take two arguments beat and duration
(define change-over-time
   (lambda (start duration rate from to function . args)
      (let* ((env (make-envelope (vector start from (+ start duration) to)))
	     (func (lambda (beat dur)
		      ;(callback (*metro* beat) function beat (env beat) args)
		      (function beat (env beat) args)
		      (if (> dur rate)
			  (callback (*metro* (+ beat rate)) func
				    (+ beat rate)
				    (- dur rate))))))
	 (callback (*metro* start) func start duration))))


(define (string->sexpr str)
   (let* ((port (open-input-string str))
	  (res (read port)))
      (close-port port)
      res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Metro and beat related stuff
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define pi 3.14159265358979323846)
(define 2pi (* 2.0 pi))

;; sinusoidal LFOs

(macro (cosr args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (cos (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (cos (* 2pi beat ,(cadddr args)))))))

(macro (sinr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (sin (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (sin (* 2pi beat ,(cadddr args)))))))

(macro (tanr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (tan (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (tan (* 2pi beat ,(cadddr args)))))))

;; sawtooth wave LFO with period 2pi

(define ramp
  (lambda (x)
    (let ((xmod2pi (- x (* 2pi (floor (/ x 2pi))))))
      (* (/ 1 pi) (if (< xmod2pi pi) xmod2pi (- xmod2pi 2pi))))))

(macro (rampr args)
       (if (> (length args) 4)
       `(+ ,(caddr args) (+ (* .5 ,(cadddr args)) (* .5 ,(cadddr args) (ramp (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args)))))))
       `(+ ,(cadr args) (+ (* .5 ,(caddr args)) (* .5 ,(caddr args) (ramp (* 2pi beat ,(cadddr args))))))))

(define slide
  (lambda (x)
    (- 1.0 (ramp x))))

(macro (slider args)
       (if (> (length args) 4)
           `(+ ,(caddr args) (+ (* .5 ,(cadddr args)) (* .5 ,(cadddr args) (slide (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args)))))))
           `(+ ,(cadr args) (+ (* .5 ,(caddr args)) (* .5 ,(caddr args) (slide (* 2pi beat ,(cadddr args))))))))


;; square wave LFO with period 2pi

(define rect
  (lambda (x)
    (let ((xmod2pi (- x (* 2pi (floor (/ x 2pi))))))
      (if (< xmod2pi pi) 1 0))))

(macro (rectr args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (rect (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (rect (* 2pi beat ,(cadddr args)))))))

;; triangle wave LFO with period 2pi

(define tri-wave
  (lambda (x)
    (let ((xmod2pi (- x (* 2pi (floor (/ x 2pi))))))
      (if (< xmod2pi pi)
	  (+ 1 (* (/ -1 pi) xmod2pi))
	  (- (* (/ 1 pi) xmod2pi) 1)))))

(macro (trir args)
   (if (> (length args) 4)
       `(+ ,(caddr args) (* ,(cadddr args) (tri-wave (* 2pi (+ beat ,(cadr args)) ,(car (cddddr args))))))
       `(+ ,(cadr args) (* ,(caddr args) (tri-wave (* 2pi beat ,(cadddr args)))))))


(define (clamp num low high)
  (if (< num low) low
      (if (> num high) high
          num)))

; creates a rhythm of a given length
; a tactus is provided and a percentage of synconization (from 0 - 1)
; a rhythm-list defines which rhythm values can be used
;
; (define rlst (make-rhythm 4 1 .2 '(1/3 1/2 1/4)))


(define make-rhythm
   (lambda (beats tactus syncopation rhythm-list)
      (define beats-divisible-by-rlst
	 (lambda (dur)
	    (member 0 (map (lambda (r) (modulo dur r)) rhythm-list))))
      (set! rhythm-list (cl:sort rhythm-list >))
      (if (not (= 0 (modulo beats tactus)))
	  (begin (print-error "Tactus must be a subdivision of beats") '())
	  (if #f ;(not (beats-divisible-by-rlst beats))
	      (begin (println "Impossible rhythm-list selection") '())
	      (let loop ((rl '())
			 (cnt 0))
		 (if (null? rl) (list (random rhythm-list)))
		 (let ((sum (apply + rl)))
		    (cond ((> cnt 500)
			   (print-error "Could not make valid rhythm")
			   '())
			  ((> sum beats)
			   (loop (cdr rl) (+ cnt 1)))
			  ((not (beats-divisible-by-rlst (- beats sum)))
			   (loop (cdr rl) (+ cnt 1)))
			  ((>= (car rhythm-list) (- beats sum))
			   (cond ((= sum beats)
				  (reverse rl))
				 ((member (- beats sum) rhythm-list)
				  (reverse (cons (car (member (- beats sum) rhythm-list)) rl)))
				 (else (loop (cons (random rhythm-list) rl) (+ cnt 1)))))
			  (else (if (= 0 (modulo sum tactus))
				    (loop (cons (random rhythm-list) rl) (+ cnt 1))
				    (if (> (random) (+ .05 syncopation))
					(loop (cons (car rl) rl) (+ cnt 1))
					(loop (cons (random rhythm-list) rl) (+ cnt 1))))))))))))



; accepts an associative list as the timeline argument
; returns an event at a given time from the alist
;
; if a new pair is passed then add that pair to the end of timeline
(define make-timeline
   (lambda (timeline)
      (if (null? timeline)
	  '()
	  (lambda (time)
	     (if (pair? time)
		 (set! timeline (append timeline (list time)))
		 (let loop ((lst (reverse timeline)))
		    (cond ((null? lst) '())
			  ((>= time (caar lst))
			   (cdar lst))
			  (else (loop (cdr lst))))))))))



; creates a meter where metre is a list of numerators
; and base is a shared denominator (relative to impromptu beats. i.e. 1 = crotchet,  0.5 = eighth etc.)
;
; e.g.  (define *metre* (make-metre '(2 3 2) 0.5)) = 2/8 3/8 2/8 rotating cycle.
;
; then call meter with time and beat
; if beat matches time then #t else #f
;
; e.g. give the above define
;      (*metre* 2.5 1.0) => #t because 0.0 = 1, 0.5 = 2, 1.0 = 1, 1.5 = 2, 2.0 = 3, 2.5 = 1, 3.0 = 2 and repeat.
(define make-metre
   (lambda (metre base)
      (let ((metre-length (apply + metre)))
	 (lambda (time . beat)
	    (let ((b (let loop ((qtime (modulo (/ time base) metre-length))
				(lst metre)
				(valuea (car metre))
				(valueb 0))
			(if (< qtime valuea)
			    (+ 1.0 (- qtime valueb))
			    (loop qtime (cdr lst) (+ valuea (cadr lst)) (+ valueb (car lst)))))))
	       (if (null? beat)
		   b
		   (if (= (car beat) b) #t #f)))))))


;; creates a metronome object
;; metro is basically a linear function that returns
;; a time in absolute samples when given a time in beats.
;;
;; metro is instantiated with a starting tempo.
;; you can call the metro with the following symbols
;;
;; 'get-time ; which is also the default
;; 'get-beat
;; 'get-tempo
;; 'set-tempo
;; 'get-cycle
;; 'set-cycle
;; 'pos
;; 'dur
;
(define make-metro
  (lambda (start-tempo . args)
    (let* ((offset (if (null? args) (now) (caar args)))
           (cycle 4)
           (mark offset)
           (loffset 0.0)
           (total-beats (if (null? args) 0 (cdar args)))
           (cycle-beats total-beats)
           (g-tempo (/ 60 start-tempo))
           (beat-pos (lambda (x1 y1 x2 y2)
                       (let* ((m (if (= 0 (- x2 x1)) 0 (/ (- y2 y1) (- x2 x1))))
                              (c (- y1 (* m x1))))
                         (lambda (time)
                           (+ (* time m) c)))))
           (beat-env (beat-pos mark total-beats (+ mark (* g-tempo *au:samplerate*)) (+ total-beats 1)))
           (samp-env (beat-pos total-beats mark (+ total-beats 1) (+ mark (* g-tempo *au:samplerate*)))))
      (lambda (sym . args)
        (cond ((number? sym)
               (+ (samp-env sym) loffset))
              ((equal? sym 'get-mark)
               (cons mark total-beats))
              ((equal? sym 'get-time)
               (+ (samp-env (car args)) loffset)) ;mark))
              ((equal? sym 'get-cycle) cycle)
              ((equal? sym 'get-cycle-mark) cycle-beats)
              ((equal? sym 'set-cycle)
               (set! cycle-beats (cadr args))
               (set! cycle (car args)))
              ((equal? sym 'pos) (modulo (- (car args) cycle-beats) cycle))
              ((equal? sym 'beat-at-time) (rational->real (beat-env (car args))))
              ((equal? sym 'set-tempo)
               (let ((time (if (null? (cdr args)) (now) (cadr args))))
                 (if (or (null? (cdr args))
                         (null? (cddr args)))
                     (set! total-beats
                           (+ total-beats (/ (- time mark)
                                             (* *au:samplerate* g-tempo))))
                     (set! total-beats (caddr args)))
                 (set! g-tempo (/ 60 (car args)))
                 (set! mark time)
                 (set! samp-env (beat-pos total-beats
                                          mark
                                          (+ total-beats 1)
                                          (+ mark (* g-tempo *au:samplerate*))))
                 (set! beat-env (beat-pos mark
                                          total-beats
                                          (+ mark (* g-tempo *au:samplerate*))
                                          (+ total-beats 1)))
                 (car args)))
              ((equal? sym 'get-tempo) (* (/ 1 g-tempo) 60))
              ((equal? sym 'dur) (* *au:samplerate* g-tempo (car args)))
              ((equal? sym 'push) (set! loffset (+ loffset 256)))
              ((equal? sym 'pull) (set! loffset (- loffset 256)))
              ((equal? sym 'get-beat)
               (let ((val (+ total-beats
                             (/ (- (now) mark)
                                (* *au:samplerate* g-tempo))))
                     (quantize (if (null? args) 1.0 (car args))))
                 (real->rational (+ val (- quantize (modulo val quantize))))))
              (else 'bad-method-name))))))


(define *metro* (make-metro 120 '(0 . 0)))


;; define me first!
(define-macro (set-signal! variable value seconds . rate)
  (let ((r (if (null? rate) 1/30 (car rate))))
    (if (and (or (list? value)
                 (defined? value))
             (closure? (eval value)))
        `(let l1929 ((t (now))
                     (count (/ ,seconds ,r)))
           (if (equal? ,variable 'stop-signal)
               'done
               (begin (set! ,variable (apply ,value (list ,variable)))
                      (if (> count 1)
                          (callback (+ t (* *samplerate* ,r)) l1929 (+ t (* *samplerate* ,r)) (- count 1))))))
        `(let l1929 ((t (now))
                     (inc (/ (- ,value ,variable) (real->integer (/ ,seconds ,r))))
                     (count (real->integer (/ ,seconds ,r))))
           (if (equal? ,variable 'stop-signal)
               'done
               (begin (set! ,variable (+ ,variable inc))
                      (if (> count 1)
                          (callback (+ t (* *samplerate* ,r)) l1929 (+ t (* *samplerate* ,r)) inc (- count 1)))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; sys:wait
;; synchronous concurrency

(define *sys:toplevel-continuation* '())
(call/cc (lambda (k) (set! *sys:toplevel-continuation* k)))

(define sys:wait
   (lambda (until-time)
      (call/cc (lambda (cont)
		  (callback until-time cont #t)
		  (*sys:toplevel-continuation* 0)
		  #t))))

(define sys:sleep
   (lambda (duration)
      (call/cc (lambda (cont)
		  (callback (+ (now) duration) cont #t)
		  (*sys:toplevel-continuation* 0)
		  #t))))


;; synchronous IPC


(define *ipc:remote-process-name-map* '()) ;(objc:make-dictionary))

(define ipc:set-local-remote-mapping
   (lambda (local-name remote-name)
     (let ((res (assoc *impc:remote-process-name-map* local-name)))
       (if res
	   (set-cdr! res remote-name)
	   (set! *impc:remote-process-name-map*
		 (cons (cons local-name remote-name)
		       *impc:remote-process-name-map*))))))

(define ipc:proc-name-with-mapping
   (lambda ()
     (let ((pair (assoc *impc:remote-process-name-map* (ipc:get-process-name))))
       (if pair
	   (car pair)
	   (ipc:get-process-name)))))

(define *ipc:active-label-buffer-size* 1000)
(define *ipc:active-labels* (make-vector *ipc:active-label-buffer-size* '()))
(define *ipc:active-label-cnt* 0)

(define ipc:run-active-label
   (lambda (id . args)
     (let ((k (vector-ref *ipc:active-labels* id)))
       (if (null? k)
	   (println "Error: bad process? Have you given your local process a name on the remote host?"))
       (vector-set! *ipc:active-labels* id '())
       (apply k args))))


(define ipc:sync-receive
  (lambda (process id func . args)
    (let ((result (apply (eval func) args)))
      (ipc:call-async process 'ipc:run-active-label id result))))


;; (define ipc:call
;;   (lambda (process func . args)
;;     (let loop ((i *ipc:active-label-cnt*))
;;       (if (not (null? (vector-ref *ipc:active-labels* i)))
;;           (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
;;           (set! *ipc:active-label-cnt* i)))
;;     (apply ipc:call-async process 'ipc:sync-receive (ipc:proc-name-with-mapping)
;;            *ipc:active-label-cnt* func args)
;;     (let ((return-val (call/cc (lambda (k)
;;                                  (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
;;                                  (*sys:toplevel-continuation* 0)))))
;;       return-val)))


(define ipc:call
  (lambda (process . args)
    (let* ((callback-proc (ipc:get-process-name))
           (func (if (string? (car args))
                     (begin (set! callback-proc (car args))
                            (set! args (cdr args))
                            (car args))
                     (car args))))
      (let loop ((i *ipc:active-label-cnt*))
        (if (not (null? (vector-ref *ipc:active-labels* i)))
            (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
            (set! *ipc:active-label-cnt* i)))
      (apply ipc:call-async process 'ipc:sync-receive callback-proc
             *ipc:active-label-cnt* func (cdr args))
      (let ((return-val (call/cc (lambda (k)
                                   (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
                                   (*sys:toplevel-continuation* 0)))))
        return-val))))

(define ipc:map
  (lambda (func process-lst . args-lists)
    (let* ((callback-proc (ipc:get-process-name))
           (results '())
           (loopK '()))
      (let ((pos (call/cc (lambda (kk) (set! loopK kk) 0))))
        (if (< pos (length process-lst))
            (let ((z (list-ref process-lst pos))
                  (ags (if (null? args-lists) #f (list-ref args-lists pos))))
              (let loop ((i *ipc:active-label-cnt*))
                (if (not (null? (vector-ref *ipc:active-labels* i)))
                    (loop (modulo (+ i 1) *ipc:active-label-buffer-size*))
                    (set! *ipc:active-label-cnt* i)))
              (apply ipc:call-async z 'ipc:sync-receive callback-proc
                     *ipc:active-label-cnt* func (if (null? args-lists) '() ags))
              (let ((return-val (call/cc (lambda (k)
                                           (vector-set! *ipc:active-labels* *ipc:active-label-cnt* k)
                                           (loopK (+ pos 1))))))
                (set! results (cons return-val results))
                (if (< (length results) (length process-lst))
                    (*sys:toplevel-continuation* 0)
                    results)))
            (*sys:toplevel-continuation*))))))

;; comptibility alias (deprecated)
(define ipc:mapcall ipc:map)

;; async map

;; syntax:

;; (ipc:for-each '("primary" "utility") 'fn-with-no-args)

;; both of these ok:
;; (ipc:for-each '("primary" "utility") 'fn-with-1-arg '(12 36))
;; (ipc:for-each '("primary" "utility") 'fn-with-1-arg '((12) (36)))

;; (ipc:for-each '("primary" "utility") 'fn-with-2-args '((12 436) (36 45)))
(define ipc:for-each
  (lambda (proc-list func . arg-lists)
    ;; poor man's destructuring(ish)
    (set! arg-lists
          (if (null? arg-lists)
              (make-list (length proc-list) '())
              (map (lambda (x) (if (list? x) x (list x)))
                   (car arg-lists))))
    (for-each (lambda (proc args)
                (apply ipc:call-async proc func args))
              proc-list
              arg-lists)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (io:osc:receive time address . args)
   (print-notification 'override 'io:osc:receive 'to 'handle 'osc 'events:)
   (println (objc:make-date time) address args))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; LIST HELPER FUNCTIONS

;;delete from list at index
(define delete-at-index
   (lambda (k lst)
      (cond ((or (null? lst)
		 (< k 0))
	     lst)
	    ((= k 0)
	     (cdr lst))
	    ((>= k (length lst))
	     lst)
	    (else (set-cdr! (cl:nthcdr (- k 1) lst)
			    (cl:nthcdr (+ k 1) lst))
		  lst))))

; insert into list at index
(define insert-at-index
   (lambda (k lst obj)
      (cond ((or (null? lst)
		 (< k 0))
	     lst)
	    ((= k 0)
	     (cons obj lst))
	    ((> k (length lst))
	     lst)
	    (else (set-cdr! (cl:nthcdr (- k 1) lst)
			    (cons obj (cl:nthcdr k lst)))
		  lst))))

; change list item at index
(define change-at-index
   (lambda (k lst obj)
      (cond ((or (null? lst)
		 (< k 0))
	     lst)
	    ((>= k (length lst))
	     lst)
	    (else (set-car! (cl:nthcdr k lst) obj)
		  lst))))

(define (foldr func end lst)
  (if (null? lst)
      end
      (func (car lst) (foldr func end (cdr lst)))))

(define (foldl func accum lst)
  (if (null? lst)
      accum
      (foldl func (func accum (car lst)) (cdr lst))))

(define (scan proc val lst)
    (if (null? lst)
        '()
        (cons (proc val (car lst)) (scan proc (proc val (car lst)) (cdr lst)))))

;; jumble returns a randomized version of lst
(define jumble
   (lambda (lst)
      (let loop ((lstb '())
		 (lsta (map (lambda (val) val) lst)))
	 (if (null? lsta)
	     lstb
	     (let* ((rand (random (length lsta)))
		    (val (list-ref lsta rand)))
		(loop (cons val lstb) (delete-at-index rand lsta)))))))

;; rotate list
(define rotate
   (lambda (lst amt)
      (let loop ((l (if (> amt 0) (reverse lst) lst))
		 (cnt (abs amt)))
	 (if (<= cnt 0)
	     (if (> amt 0) (reverse l) l)
	     (loop (append (cdr l) (list (car l)))
		   (- cnt 1))))))


(define make-bezier
   (lambda (x1 y1 x2 y2 cx1 cy1 cx2 cy2)
      (let* ((xc (* 3 (- cx1 x1)))
	     (xb (- (* 3 (- cx2 cx1)) xc))
	     (xa (- x2 x1 (* 3 (- cx2 cx1))))
	     (yc (* 3 (- cy1 y1)))
	     (yb (- (* 3 (- cy2 cy1)) yc))
	     (ya (- y2 y1 (* 3 (- cy2 cy1)))))
	 (lambda (t)
	    (cons (+ (* xa t t t)
		     (* xb t t)
		     (* xc t)
		     x1)
		  (+ (* ya t t t)
		     (* yb t t)
		     (* yc t)
		     y1))))))

(define list-head
   (lambda (lst k)
      (if (< k 1)
	  '()
	  (cons (car lst) (list-head (cdr lst) (- k 1))))))


;; flatten down to a list of lists
(define (flatten-1 list)
   (cond ((null? list) '())
	 ((and (list? (car list))
	       (list? (car (car list))))
	  (append (flatten-1 (car list)) (flatten-1 (cdr list))))
	 (else (cons (car list) (flatten-1 (cdr list))))))


;; flatten down to a list of atoms
(define (flatten list)
   (cond ((null? list) '())
	 ((list? (car list)) (append (flatten (car list)) (flatten (cdr list))))
	 (else (cons (car list) (flatten (cdr list))))))


;; return all permutations of set
;; of subsets (size) of set
(define permutations
   (lambda (set size)
      (if (null? set)
	  '(())
	  (letrec ((f1 (lambda (s)
			  (map (lambda (e)
				  (f2 (list e) (cl:remove e s)))
			       s)))
		   (f2 (lambda (e s)
			  (if (= (length e) size)
			      e
			      (map (lambda (e2)
				      (f2 (append e (list e2)) (cl:remove e2 s)))
				   s)))))
	     (flatten-1 (f1 set))))))



;; return all combinations of set
;; or subsets (size) of set
(define combinations
   (lambda (s size)
      (if (< (length s) size)
	  '()
	  (letrec ((f1 (lambda (h t)
			  (if (= (length h) size)
			      (reverse h)
			      (let loop ((e (car t))
					 (l (cdr t)))
				 (if (null? l)
				     (if (< (length h) (- size 1)) '()
					 (reverse (list* e h)))
				     (list (f1 (list* e h) l)
					   (loop (car l) (cdr l)))))))))
	     (cl:remove '() (flatten-1 (append (f1 (list (car s)) (cdr s))
					       (combinations (cdr s) size))))))))


;; return all combinations of set
;; of subsets (size of set)
(define combinations
  (lambda (s size)
     (if (= 0 size) '()
	(flatten-1 (map (lambda (x)
			   (let ((res (combinations (list-tail s (+ 1 (cl:position x s))) (- size 1))))
			      (if (null? res) (list x)
				  (map (lambda (y)
					  (if (list? y) (list* x y) (list x y)))
				       (flatten-1 res)))))
			(list-head s (- (length s) ( - size 1))))))))


;; USE multi-set-combination (below) to access this function
(define multi-list-combination-2
  (lambda args
    (if (null? args)
	args
	(flatten-1 (map (lambda (k)
			  (let ((r (apply multi-list-combination-2 (cdr args))))
			    (if (null? r)
				k
				(map (lambda (j)
				       (list k j))
				     r))))
			(car args))))))


;; combine multiple ordered lists into combinations
;;
;; for example (multi-list-combination '(a b) '(c d)) -> ((a c) (a d) (b c) (b d))
;; or (multi-list-combination '(a b) '(c) '(d e)) -> ((a c d) (a c e) (b c d) (b c e))
;;
(define multi-list-combination
  (lambda args
    (map (lambda (k) (flatten k)) (apply multi-list-combination-2 args))))


(define factorial
   (lambda (x)
      (if (< x 0)
	  (print-error 'Factorial 'does 'not 'accept 'negative 'numbers)
	  (if (<= x 1) 1
	      (* x (factorial (- x 1)))))))


(define range-limit
   (lambda (value min max)
      (cond ((< value min) min)
	    ((> value max) max)
	    (else value))))

(define limit-range range-limit)

(define printf
   (lambda (format . args)
      (let ((str (apply objc:string:with-format format args)))
	 (print (objc:nsstring->string str))
	 str)))


(define list-position
   (lambda (obj lst)
      (let loop ((i 0) (lst lst))
	 (if (null? lst) #f
	     (if (eqv? (car lst) obj) i
		 (loop (+ i 1) (cdr lst)))))))



(define-macro (defstruct s . ff)
   (let ((ss (symbol->string s)) (n (length ff)))
      (let* ((n1 (+ n 1))
	     (vv (make-vector n1)))
	 (let loop ((i 1) (ff ff))
	    (if (<= i n)
		(let ((f (car ff)))
		   (vector-set! vv i (if (pair? f) (cadr f) '(if #f #f)))
		   (loop (+ i 1) (cdr ff)))))
	 (let ((ff (map (lambda (f) (if (pair? f) (car f) f)) ff)))
	    `(begin (define ,(string->symbol (string-append "make" "-" ss))
		       (lambda fvfv
			  (let ((st (make-vector ,n1)) (ff ',ff))
			     (vector-set! st 0 ',s)
			     ,@(let loop ((i 1) (r '()))
				  (if (>= i n1) r
				      (loop (+ i 1)
					    (cons `(vector-set! st ,i
								,
								(vector-ref vv i))
						  r))))
			     (let loop ((fvfv fvfv))
				(if (not (null? fvfv))
				    (begin  (vector-set! st
							 (+ (list-position (car fvfv) ff)
							    1)
							 (cadr fvfv))
					    (loop (cddr fvfv)))))
			     st)))
		    ,@(let loop ((i 1) (procs '()))
			 (if (>= i n1) procs
			     (loop (+ i 1)
				   (let ((f (symbol->string (list-ref ff (- i 1)))))
				      (cons `(define ,(string->symbol (string-append ss "." f))
						(lambda (x) (vector-ref x ,i)))
					    (cons `(define ,(string->symbol (string-append "set!" ss "." f))
						      (lambda (x v)
							 (vector-set! x ,i v)))
						  procs))))))
		    (define ,(string->symbol (string-append ss "?"))
		       (lambda (x)
			  (and (vector? x)
			       (eqv? (vector-ref x 0) ',s)))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define bench
   (lambda (func . args)
      (let ((t (clock))
	    (res (apply func args)))
	 (println "benchmark time :" (- (clock) t))
	 res)))

(define-macro (benchmark expr)
   `(let ((t (clock))
	  (res ,expr))
       (println "benchmark time:" (- (clock) t))
       res))


(define sys:livecoding-error-hook?
   (lambda (on?)
      (if on?
	  (set! *error-hook* '())
	  (set! *error-hook* throw))))


;; this for buffered version
(define _dsp:set!
  (lambda (zerolatency? name . args)
    (println 'zerolatency: zerolatency?)
    (let* ((nn (if (symbol? name) (symbol->string name) name))
           (ft (llvm:get-function-args-withoutzone nn))
           (ct (if ft
                   (map (lambda (x) (impc:ir:get-type-from-str x)) ft)
                   (print-error 'Function name 'does 'not 'exist 'or 'is 'not 'compiled))))
      (cond ((equal? ct (list *impc:ir:void*
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              (+ *impc:ir:si8* *impc:ir:pointer*)))
             (sys:set-dsp-wrapper-array (llvm:get-function-pointer "imp_dsp_wrapper_array"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:double*
                              *impc:ir:double*
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:double* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dsp-wrapper (llvm:get-function-pointer "imp_dsp_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:double*
                              (+ *impc:ir:double* *impc:ir:pointer*)
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:double* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dspmt-wrapper (llvm:get-function-pointer "imp_dsp_sum_wrapper")
                                    (llvm:get-function-pointer "imp_dsp_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))                  
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio (length args) zerolatency?)
             )
            ((equal? ct (list *impc:ir:float*
                              *impc:ir:float*
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:float* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dsp-wrapper (llvm:get-function-pointer "imp_dspf_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))) ;; whole buffer
            ((equal? ct (list *impc:ir:float*
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              *impc:ir:si64*
                              (+ *impc:ir:float* *impc:ir:pointer*))) ;; sample by sample form FX
             (sys:set-dspmt-wrapper (llvm:get-function-pointer "imp_dspf_sum_wrapper")
                                    (llvm:get-function-pointer "imp_dspf_wrapper"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))                  
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio (length args) zerolatency?)
             )
            ((equal? ct (list *impc:ir:void*
                              (+ *impc:ir:float* *impc:ir:pointer* *impc:ir:pointer*)
                              (+ *impc:ir:float* *impc:ir:pointer*)
                              *impc:ir:si64*
                              (+ *impc:ir:si8* *impc:ir:pointer*))) ;; buffer by buffer
             (sys:set-dspmt-wrapper-array (llvm:get-function-pointer "imp_dsp_sum_wrapper_array")
                                          (llvm:get-function-pointer "imp_dsp_wrapper_array"))
             (sys:set-dsp-closure (llvm:get-function-pointer (string-append nn "_getter")))
             (dotimes (i (length args))                  
               (sys:set-dspmt-closure (llvm:get-function-pointer (string-append (list-ref args i) "_getter")) i))
             (sys:init-mt-audio-buf (length args) zerolatency?)
             )
            (else (print-error 'Bad 'closure 'signature 'for 'dsp:set! ct))))))

(define-macro (dsp:set! . names)
  (let ((zerolatency (if (boolean? (car names))
                         (car names)
                         #t))
        (lst (map (lambda (n) (symbol->string n))
                  (if (boolean? (car names))
                      (cdr names)
                      names))))
    `(_dsp:set! ,zerolatency ,@lst)))

;; filename wrangling

(define sys:file-path-components
  (lambda (file-path)
    (let ((base (regex:matched file-path "(.*)/(.*)\\.(.*)")))
      (and (not (null? base))
           (cdr base)))))

;; needed for precomp.

;; should be a cons pair e.g. '(libGLU .
;; "/System/Library/Frameworks/OpenGL.framework/OpenGL")
(define *sys:precomp:current-load-dylib-info* #f)

(define sys:precomp:set-dylib-name-info
  (lambda (symbol-name dylib-path)
    ;; is there a better way to check if a file exists?
    (set! *sys:precomp:current-load-dylib-info*
          (cons symbol-name dylib-path))))


;; Check if (prebuilt) lib exists in runtime/lib first, otherwise
;; search LDPATH as usual
(define sys:load-dylib
  (lambda (dylib-path)
    (let ((dylib (sys:open-dylib dylib-path)))
      (if dylib
          (begin (impc:compiler:print-dylib-loading-details-to-log dylib-path)
                 dylib)
          (begin (print-with-colors 'red 'default #t
                                    (print "Error"))
                 (print ": could not load " dylib-path " dynamic library\n")
                 #f)))))

;;;;;;;;;;;;;;;;;
;; comlist.xtm ;;
;;;;;;;;;;;;;;;;;

;Permission to copy this software, to modify it, to redistribute it,
;to distribute modified versions, and to use it for any purpose is
;granted, subject to the following restrictions and understandings.
;
;1.  Any copy made of this software must include this copyright notice
;in full.
;
;2.  I have made no warranty or representation that the operation of
;this software will be error-free, and I am under no obligation to
;provide any services, by way of maintenance, update, or otherwise.
;
;3.  In conjunction with products arising from the use of this
;material, there shall be no use of my name in any advertising,
;promotional, or sales literature without prior written consent in
;each case.

;;; Some of these functions may be already defined in your Scheme.
;;; Comment out those definitions for functions which are already defined.

;;;; LIST FUNCTIONS FROM COMMON LISP

(define (cl:assoc-adjoin pair lst)
   (if (assoc (car pair) lst)
       lst
       (cons pair lst)))

;; with precedence to first lst
(define cl:assoc-union
  (letrec ((onion (lambda (lst1 lst2)
		     (if (null? lst1)
			 lst2
			 (onion (cdr lst1) (cl:assoc-adjoin (car lst1) lst2))))))
     (lambda (lst1 lst2)
	(cond ((null? lst1) lst2)
	      ((null? lst2) lst1)
	      (else (onion (reverse lst2) lst1))))))


;;; Some tail-recursive optimizations made by
;;; Colin Walters <walters@cis.ohio-state.edu>
;;; AGJ restored order July 2001.

;;;@ From: hugh@ear.mit.edu (Hugh Secker-Walker)
(define (cl:make-list k . init)
  (set! init (if (pair? init) (car init)))
  (do ((k (+ -1 k) (+ -1 k))
       (result '() (cons init result)))
      ((negative? k) result)))



(define (cl:tree-copy tree)
  (let loop ((tree tree))
    (if (pair? tree)
	(cons (loop (car tree)) (loop (cdr tree)))
	tree)))

;@
(define (cl:copy-list lst) (append lst '()))
;@
(define (cl:adjoin obj lst) (if (member obj lst) lst (cons obj lst)))
;@
(define cl:union
  (letrec ((onion
	    (lambda (lst1 lst2)
	      (if (null? lst1)
		  lst2
		  (onion (cdr lst1) (cl:adjoin (car lst1) lst2))))))
    (lambda (lst1 lst2)
      (cond ((null? lst1) lst2)
	    ((null? lst2) lst1)
	    ((null? (cdr lst1)) (cl:adjoin (car lst1) lst2))
	    ((null? (cdr lst2)) (cl:adjoin (car lst2) lst1))
	    ((< (length lst2) (length lst1)) (onion (reverse lst2) lst1))
	    (else (onion (reverse lst1) lst2))))))
;@
(define (cl:intersection lst1 lst2)
   (if (null? lst2)
       lst2
       (let build-intersection ((lst1 lst1)
				(result '()))
	  (cond ((null? lst1)
		 (if (null? result)
		     '()
		     (reverse result)))
		((member (car lst1) lst2)
		 (build-intersection (cdr lst1) (cons (car lst1) result)))
		(else (build-intersection (cdr lst1) result))))))
;@
(define (cl:set-difference lst1 lst2)
  (if (null? lst2)
      lst1
      (let build-difference ((lst1 lst1)
			     (result '()))
	(cond ((null? lst1) (reverse result))
	      ((member (car lst1) lst2) (build-difference (cdr lst1) result))
	      (else (build-difference (cdr lst1) (cons (car lst1) result)))))))
;@
(define (cl:subset? lst1 lst2)
  (or (eq? lst1 lst2)
      (let loop ((lst1 lst1))
	(or (null? lst1)
	    (and (member (car lst1) lst2)
		 (loop (cdr lst1)))))))
;@
(define (cl:position obj lst)
  (define pos (lambda (n lst)
		(cond ((null? lst) #f)
		      ((equal? obj (car lst)) n)
		      (else (pos (+ 1 n) (cdr lst))))))
  (pos 0 lst))
;@
(define (cl:reduce-init pred? init lst)
  (if (null? lst)
      init
      (cl:reduce-init pred? (pred? init (car lst)) (cdr lst))))
;@
(define (cl:reduce pred? lst)
  (cond ((null? lst) lst)
	((null? (cdr lst)) (car lst))
	(else (cl:reduce-init pred? (car lst) (cdr lst)))))
;@
(define (cl:some pred lst . rest)
  (cond ((null? rest)
	 (let mapf ((lst lst))
	   (and (not (null? lst))
		(or (pred (car lst)) (mapf (cdr lst))))))
	(else (let mapf ((lst lst) (rest rest))
		(and (not (null? lst))
		     (or (apply pred (car lst) (map car rest))
			 (mapf (cdr lst) (map cdr rest))))))))
;@
(define (cl:every pred lst . rest)
  (cond ((null? rest)
	 (let mapf ((lst lst))
	   (or (null? lst)
	       (and (pred (car lst)) (mapf (cdr lst))))))
	(else (let mapf ((lst lst) (rest rest))
		(or (null? lst)
		    (and (apply pred (car lst) (map car rest))
			 (mapf (cdr lst) (map cdr rest))))))))
;@
(define (cl:notany pred . ls) (not (apply cl:some pred ls)))
;@
(define (cl:notevery pred . ls) (not (apply cl:every pred ls)))
;@
(define (cl:list-of?? predicate . bound)
  (define (errout) (apply slib:error 'list-of?? predicate bound))
  (case (length bound)
    ((0)
     (lambda (obj)
       (and (list? obj)
	    (cl:every predicate obj))))
    ((1)
     (set! bound (car bound))
     (cond ((negative? bound)
	    (set! bound (- bound))
	    (lambda (obj)
	      (and (list? obj)
		   (<= bound (length obj))
		   (cl:every predicate obj))))
	   (else
	    (lambda (obj)
	      (and (list? obj)
		   (<= (length obj) bound)
		   (cl:every predicate obj))))))
    ((2)
     (let ((low (car bound))
	   (high (cadr bound)))
       (cond ((or (negative? low) (negative? high)) (errout))
	     ((< high low)
	      (set! high (car bound))
	      (set! low (cadr bound))))
       (lambda (obj)
	 (and (list? obj)
	      (<= low (length obj) high)
	      (cl:every predicate obj)))))
    (else (errout))))
;@
(define (cl:find-if pred? lst)
  (cond ((null? lst) #f)
	((pred? (car lst)) (car lst))
	(else (cl:find-if pred? (cdr lst)))))
;@
(define (cl:member-if pred? lst)
  (cond ((null? lst) #f)
	((pred? (car lst)) lst)
	(else (cl:member-if pred? (cdr lst)))))
;@
(define (cl:remove obj lst)
  (define head (list '*head*))
  (let remove ((lst lst)
	       (tail head))
    (cond ((null? lst))
	  ((eqv? obj (car lst)) (remove (cdr lst) tail))
	  (else
	   (set-cdr! tail (list (car lst)))
	   (remove (cdr lst) (cdr tail)))))
  (cdr head))
;@
(define (cl:remove-if pred? lst)
  (let remove-if ((lst lst)
		  (result '()))
    (cond ((null? lst) (reverse result))
	  ((pred? (car lst)) (remove-if (cdr lst) result))
	  (else (remove-if (cdr lst) (cons (car lst) result))))))
;@
(define (cl:remove-if-not pred? lst)
  (let remove-if-not ((lst lst)
		      (result '()))
    (cond ((null? lst) (reverse result))
	  ((pred? (car lst)) (remove-if-not (cdr lst) (cons (car lst) result)))
	  (else (remove-if-not (cdr lst) result)))))
;@
(define cl:nconc
      (lambda args
	(cond ((null? args) '())
	      ((null? (cdr args)) (car args))
	      ((null? (car args)) (apply cl:nconc (cdr args)))
	      (else
	       (set-cdr! (last-pair (car args))
			 (apply cl:nconc (cdr args)))
	       (car args)))))

;;;@ From: hugh@ear.mit.edu (Hugh Secker-Walker)
(define (cl:nreverse rev-it)
;;; Reverse order of elements of LIST by mutating cdrs.
  (cond ((null? rev-it) rev-it)
	((not (list? rev-it))
	 (slib:error "nreverse: Not a list in arg1" rev-it))
	(else (do ((reved '() rev-it)
		   (rev-cdr (cdr rev-it) (cdr rev-cdr))
		   (rev-it rev-it rev-cdr))
		  ((begin (set-cdr! rev-it reved) (null? rev-cdr)) rev-it)))))
;@
(define (cl:last lst n)
  (cl:nthcdr (- (length lst) n) lst))
;@
(define (cl:butlast lst n)
  (cl:butnthcdr (- (length lst) n) lst))
;@
(define (cl:nthcdr n lst)
  (if (zero? n) lst (cl:nthcdr (+ -1 n) (cdr lst))))
;@
(define (cl:butnthcdr k lst)
  (cond ((negative? k) lst) ;(slib:error "negative argument to butnthcdr" k)
					; SIMSYNCH FIFO8 uses negative k.
	((or (zero? k) (null? lst)) '())
	(else (let ((ans (list (car lst))))
		(do ((lst (cdr lst) (cdr lst))
		     (tail ans (cdr tail))
		     (k (+ -2 k) (+ -1 k)))
		    ((or (negative? k) (null? lst)) ans)
		  (set-cdr! tail (list (car lst))))))))

;;;; CONDITIONALS
;@
(define (cl:and? . args)
  (cond ((null? args) #t)
	((car args) (apply cl:and? (cdr args)))
	(else #f)))
;@
(define (cl:or? . args)
  (cond ((null? args) #f)
	((car args) #t)
	(else (apply cl:or? (cdr args)))))

;;;@ Checks to see if a list has any duplicate MEMBERs.
(define (cl:has-duplicates? lst)
  (cond ((null? lst) #f)
	((member (car lst) (cdr lst)) #t)
	(else (cl:has-duplicates? (cdr lst)))))


;;;@ remove duplicates of MEMBERs of a list
(define cl:remove-duplicates
   (letrec ((rem-dup  (lambda (lst nlst)
			 (cond ((null? lst) (if (null? nlst) nlst (reverse nlst)))
			       ((member (car lst) nlst) (rem-dup (cdr lst) nlst))
			       (else (rem-dup (cdr lst) (cons (car lst) nlst)))))))
      (lambda (lst)
	 (rem-dup lst '()))))

;@
(define cl:list*
  (letrec ((list*1 (lambda (obj)
		     (if (null? (cdr obj))
			 (car obj)
			 (cons (car obj) (list*1 (cdr obj)))))))
    (lambda (obj1 . obj2)
      (if (null? obj2)
	  obj1
	  (cons obj1 (list*1 obj2))))))
;@
(define (cl:atom? obj)
  (not (pair? obj)))
;@
(define (cl:delete obj lst)
  (let delete ((lst lst))
    (cond ((null? lst) '())
	  ((equal? obj (car lst)) (delete (cdr lst)))
	  (else
	   (set-cdr! lst (delete (cdr lst)))
	   lst))))
;@
(define (cl:delete-if pred lst)
  (let delete-if ((lst lst))
    (cond ((null? lst) '())
	  ((pred (car lst)) (delete-if (cdr lst)))
	  (else
	   (set-cdr! lst (delete-if (cdr lst)))
	   lst))))
;@
(define (cl:delete-if-not pred lst)
  (let delete-if ((lst lst))
    (cond ((null? lst) '())
	  ((not (pred (car lst))) (delete-if (cdr lst)))
	  (else
	   (set-cdr! lst (delete-if (cdr lst)))
	   lst))))

;;;;;;;;;;;;;;
;; sort.xtm ;;
;;;;;;;;;;;;;;

;;; "sort.xtm" Defines: sorted?, merge, merge!, sort, sort!
;;; Author : Richard A. O'Keefe (based on Prolog code by D.H.D.Warren)
;;;
;;; This code is in the public domain.

;;; Updated: 11 June 1991
;;; Modified for scheme library: Aubrey Jaffer 19 Sept. 1991
;;; Updated: 19 June 1995
;;; (sort, sort!, sorted?): Generalized to strings by jaffer: 2003-09-09
;;; (sort, sort!, sorted?): Generalized to arrays by jaffer: 2003-10-04
;;; Modified by Andrew Sorensen for Impromptu 2006-05-10

;;; (cl:sorted? sequence less?)
;;; is true when sequence is a list (x0 x1 ... xm) or a vector #(x0 ... xm)
;;; such that for all 1 <= i <= m,
;;;	(not (less? (list-ref list i) (list-ref list (- i 1)))).
;@
(define (cl:sorted? seq less?)
  (cond ((null? seq) #t)
	(else (let loop ((last (car seq)) (next (cdr seq)))
	   (or (null? next)
	       (and (not (less? (car next) last))
		    (loop (car next) (cdr next))))))))

;;; (cl:merge a b less?)
;;; takes two lists a and b such that (sorted? a less?) and (sorted? b less?)
;;; and returns a new list in which the elements of a and b have been stably
;;; interleaved so that (sorted? (merge a b less?) less?).
;;; Note:  this does _not_ accept arrays.  See below.
;@
(define (cl:merge a b less?)
  (cond ((null? a) b)
	((null? b) a)
	(else (let loop ((x (car a)) (a (cdr a)) (y (car b)) (b (cdr b)))
		;; The loop handles the merging of non-empty lists.  It has
		;; been written this way to save testing and car/cdring.
		(if (less? y x)
		    (if (null? b)
			(cons y (cons x a))
			(cons y (loop x a (car b) (cdr b))))
		    ;; x <= y
		    (if (null? a)
			(cons x (cons y b))
			(cons x (loop (car a) (cdr a) y b))))))))

;;; (cl:merge! a b less?)
;;; takes two sorted lists a and b and smashes their cdr fields to form a
;;; single sorted list including the elements of both.
;;; Note:  this does _not_ accept arrays.
;@
(define (cl:merge! a b less?)
  (define (loop r a b)
    (if (less? (car b) (car a))
	(begin (set-cdr! r b)
	  (if (null? (cdr b))
	      (set-cdr! b a)
	      (loop b a (cdr b))))
	;; (car a) <= (car b)
	(begin (set-cdr! r a)
	  (if (null? (cdr a))
	      (set-cdr! a b)
	      (loop a (cdr a) b)))))
  (cond ((null? a) b)
	((null? b) a)
	((less? (car b) (car a))
	 (if (null? (cdr b))
	     (set-cdr! b a)
	     (loop b a (cdr b)))
	 b)
	(else (if (null? (cdr a))
	     (set-cdr! a b)
	     (loop a (cdr a) b))
	 a)))

;;; (cl:sort! sequence less?)
;;; sorts the list, array, or string sequence destructively.  It uses
;;; a version of merge-sort invented, to the best of my knowledge, by
;;; David H. D.  Warren, and first used in the DEC-10 Prolog system.
;;; R. A. O'Keefe adapted it to work destructively in Scheme.
;@
(define (cl:sort! seq less?)
  (define (step n)
    (cond ((> n 2)
	   (let* ((j (quotient n 2))
		  (a (step j))
		  (k (- n j))
		  (b (step k)))
	     (cl:merge! a b less?)))
	  ((= n 2)
	   (let ((x (car seq))
		 (y (cadr seq))
		 (p seq))
	     (set! seq (cddr seq))
	     (cond ((less? y x)
		    (set-car! p y)
		    (set-car! (cdr p) x)))
	     (set-cdr! (cdr p) '())
	     p))
	  ((= n 1)
	   (let ((p seq))
	     (set! seq (cdr seq))
	     (set-cdr! p '())
	     p))
	  (else '())))
   (step (length seq)))

;;; (cl:sort sequence less?)
;;; sorts a array, string, or list non-destructively.  It does this
;;; by sorting a copy of the sequence.  My understanding is that the
;;; Standard says that the result of append is always "newly
;;; allocated" except for sharing structure with "the last argument",
;;; so (append x '()) ought to be a standard way of copying a list x.
;@
(define (cl:sort seq less?)
  (cond ((vector? seq)
	 (list->vector (cl:sort! (vector->list seq) less?)))
	((string? seq)
	 (list->string (cl:sort! (string->list seq) less?)))
	(else (cl:sort! (append seq '()) less?))))

;; for eldoc integration

(define get-eldoc-string
  (lambda (name)
    (let* ((sym (string->symbol name))
           (docstring (assoc-strcmp sym *impc:docstrings*))
           (types (assoc-strcmp sym *impc:closuretypes*))
           (form (assoc-strcmp sym *impc:closurebodies*)))
      ;; xtlang function
      (if (or docstring types form)
          (list 'docstring
                '(lang . xtlang)
                (cons 'name name)
                (cons 'args (if form (sexpr->string (cadadr form)) '()))
                (cons 'type (if types (cdr types) '()))
                (cons 'docstring (if docstring (cdr docstring) '())))
          (if (and (defined? sym)
                   (not (macro? (eval sym))))
              ;; scheme function
              (let ((form (get-closure-code (eval sym))))
                (list 'docstring
                      '(lang . scheme)
                      (cons 'name name)
                      (cons 'args (if form (sexpr->string (cadr form)) '()))
                      ;; no types for scheme
                      (cons 'type '())
                      ;; no docstrings for scheme at the moment
                      (cons 'docstring '())))
              (list 'docstring))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Load which safely breaks on calling sys:load-escape
;;
(define *sys:load-escape-stack* (list *sys:toplevel-continuation*))

(define sys:load-escape
  (lambda (msg)
    (let ((k (car *sys:load-escape-stack*)))
      (if (not (equal? *sys:toplevel-continuation* k))
          (set! *sys:load-escape-stack* (cdr *sys:load-escape-stack*)))
      (k msg))))

(define sys:load-preload-check
  (lambda (libname)
    (if (not (or (symbol? libname) (string? libname)))
        (sys:load-escape "Error: lib-name must be symbol or string."))
    (if (not (string=? (ipc:get-process-name) "primary"))
        (sys:load-escape "Error: xtlang code must be compiled in the primary process."))
    (if (defined? (string->symbol (string-append "*xtmlib-" (atom->string libname) "-loaded*")))
        (sys:load-escape (string-append (atom->string libname) " already loaded")))))

(define file-exists?
  (lambda (path)
    (let ((in-port (open-input-file path)))
      (if in-port
          (begin (close-input-port in-port)
                 #t)
          #f))))

(define filename-from-path
  (lambda (path)
    (car (reverse (regex:split path "/")))))

(define filename-strip-extension
  (lambda (path)
    (car (regex:split path "[.]"))))

(define file->string
  (lambda (path)
    (let ((in (open-input-file path))
          (out (make-string 0)))
      (if in
          (let loop ((char (read-char in)))
            (if (not (eof-object? char))
                (begin (emit (string char) out)
                       (loop (read-char in)))
                (begin (close-port in)
                       out)))
          (begin (print-with-colors 'red 'default #t
                                    (print "Error opening file: "))
                 (print path "\n")
                 #f)))))

;; sys:load and friends

(define *global-sysload-evals* (make-list-with-proc 10 (lambda (i) #f)))

(define sys:load
  (lambda (path . quiet?)
    (let ((in (open-input-file path))
          (cnt 0))
      (if (not in)
          (if (or (null? quiet?) (not (car quiet?)))
              (begin (print-with-colors 'red 'default #t (print "File Error"))
                     (print " couldn't find file ")
                     (print-with-colors 'blue 'default #f (print path "\n"))
                     #f)
              #f)
          (let ((msg (call/cc
                      (lambda (k)
                        (set! *sys:load-escape-stack* (cons k *sys:load-escape-stack*))
                        ""))))
            (if (string=? msg "")
                (begin                  
                  (let loop ((sexpr (read in)))
                    (if (not (eof-object? sexpr))
                        (begin
                          (set! *global-sysload-evals* (cons sexpr *global-sysload-evals*))
                          (set! *global-sysload-evals* (list-head *global-sysload-evals* 10))
                          (eval (car *global-sysload-evals*) (interaction-environment))
                          (loop (read in)))))
                  (close-input-port in)
                  (set! *sys:load-escape-stack* (cdr *sys:load-escape-stack*))
                  #t)
                (let ((words (regex:split msg " ")))
                  (if (or (null? quiet?) (not (car quiet?)))
                      (begin (print-with-colors 'yellow 'default #t (print "sys:load notification "))
                             (for-each (lambda (w) (print w "")) words)
                             (println)))
                  (close-port in)
                  #f)))))))

(define range
  (lambda args
    (cond ((= (length args) 1)
	   (make-list-with-proc (car args)  (lambda (i) i)))
	  ((= (length args) 2)
	   (make-list-with-proc (- (cadr args) (car args)) (lambda (i) (+ (car args) i))))
	  ((= (length args) 3)
	   (make-list-with-proc (/ (- (cadr args) (car args)) (caddr args))
				(lambda (i) (+ (car args) (* i (caddr args))))))
	  (else (println 'bad 'range!) '()))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PRECOMP STUFF ;;;;;;;;;;;;;;;;;;;;;;;

;; this can be moved elsewhere, but should be loaded on startup

(define-macro (sys:precomp:suppress-precomp-do . forms)
       `(let ((precomp-port *sys:precomp:current-output-port*))
          (set! *sys:precomp:current-output-port* #t)
          ,@forms
          ;; whatever happens, set the port back to the original value
          (set! *sys:precomp:current-output-port* precomp-port)))

(define sys:precomp:compile-current-module
  (lambda (module-name move-into-place? exit-on-error?)
    (let ((ext-llvm-dir (cptr->string (get_llvm_path))))
      (if (string=? "" ext-llvm-dir)
          (begin (print-with-colors 'red 'default #t (print "Error"))
                 (print ": you must set the environment variable ")
                 (print-with-colors 'green 'default #f (print "EXT_LLVM_DIR"))
                 (print " to point to your LLVM directory before you can precompile xtlang code.\n")
                 (error "")))
      (let* ((platform (sys:platform))
             (bitcode-path (if (string=? platform "Windows")
                               (string-append ".\\msvc\\tmp\\" module-name ".ll")
                               (string-append "/tmp/" module-name ".bc")))
             (asm-path (if (string=? platform "Windows")
                           (string-append ".\\msvc\\tmp\\" module-name ".obj")
                           (string-append "/tmp/" module-name ".s")))
             (win-libs (if (string=? platform "Windows")
                           (let* ((dirlist (sys:directory-list "./msvc/tmp/"))
                                  (liblist (cl:remove-if-not (lambda (s) (regex:match? s "\\.lib$")) dirlist))
                                  (linklist (cl:remove-if (lambda (s)
                                                            (regex:match? s (string-append module-name ".lib$")))
                                                          liblist))
                                  (strlist (string-append " " (string-join linklist " ") " ")))
                             strlist)
                           ""))
             (shlib-path
              (cond ((string=? platform "Linux")
                     (string-append "/tmp/" module-name ".so"))
                    ((string=? platform "OSX")
                     (string-append "/tmp/" module-name ".dylib"))
                    ((string=? platform "Windows")
                     (string-append ".\\msvc\\tmp\\" module-name ".dll"))
                    (else "")))
             (compilation-command-a
              (if (string=? platform "Windows")
                  (string-append
                   ext-llvm-dir
                   "/bin/Release/llc -O3 -tailcallopt -filetype obj "
                   bitcode-path)
                  (string-append
                   ext-llvm-dir
                   "/bin/llc -O3 -relocation-model=pic -tailcallopt "
                   bitcode-path)))
             (compilation-command-b
              (if (string=? platform "Windows")
                  (string-append "link "
                                 ;; " /FORCE:UNRESOLVED "
                                 " /MACHINE:x64 /DLL /OUT:"
                                 shlib-path
                                 win-libs
                                 " opengl32.lib "
                                 " Glu32.lib "
                                 " .\\msvc\\x64\\Release\\extempore.lib"                                 
                                 " .\\msvcrt.lib "                                 
                                 asm-path "\n")
                  (string-append
                   (cond ((string=? platform "Linux")
                          "gcc -O3 --shared -fPIC -g ")
                         ((string=? platform "OSX")
                          (string-append "clang -O3 -dynamiclib -undefined dynamic_lookup ")))
                   asm-path
                   " -o " shlib-path "\n"))))
        ;; (if (string=? platform "Windows")
        ;;     (print-error 'Sorry, 'this 'function 'is 'not 'available 'on 'your 'platform))
        (begin (print "Looking for ")
               (print-with-colors 'magenta 'default #t (print "llc"))
               (print " in " ext-llvm-dir "\n"))
        ;; print further instructions
        (command (string-append "rm " bitcode-path " " asm-path " " shlib-path))
        (llvm:export-module bitcode-path)

        (let ((res1 0)
              (res2 0))
          (print "LLC command:\n " compilation-command-a "\n\n")
          (set! res1 (command compilation-command-a))
          (if (<> res1 0)
              (begin (print-with-colors 'red 'default #t
                                        (println "LLC Failed!. exit code" res1))
                     (if exit-on-error? (quit 1))))
          (print "CC command:\n " compilation-command-b "\n\n")          
          (set! res2 (command compilation-command-b))
          (if (<> res2 0)
              (begin (print-with-colors 'red 'default #t
                                        (println "CC Failed!. exit code" res2))
                     (if exit-on-error? (quit 1)))                                        
              (begin (print "Succesfully compiled ")
                     (print-with-colors 'blue 'default #t (print shlib-path))
                     (print "\n\n")
                     (if move-into-place?
                         (if (= (command (string-append "mv " shlib-path " libs")) 0)
                             (begin (print "Moved ")
                                    (print-with-colors 'blue 'default #t (print shlib-path)) (print " into libs/ directory.\n\n"))
                             (print-with-colors 'red 'default #t
                                                (print "Error moving " shlib-path " into libs/ directory.")))))))))))

(define sys:precomp:insert-header
  (lambda (libname)
    (if (output-port? *sys:precomp:current-output-port*)
        (begin
          (display (string-append "(sys:load-preload-check '" (substring libname 3) ")\n")
                   *sys:precomp:current-output-port*)
          (display (string-append "(define *xtmlib-" (substring libname 3) "-loaded* (now))\n")
                   *sys:precomp:current-output-port*)
          (display "(set! *sys:precomp:prev-compiler-message-level* *impc:compiler:message:level*)\n(set! *impc:compiler:message:level* 'low)\n"
                   *sys:precomp:current-output-port*)
          (display (string-append "(define " libname " (sys:open-dylib \"libs/" libname
                                  (cond ((string=? (sys:platform) "Linux") ".so\"))\n")
                                        ((string=? (sys:platform) "Windows") ".dll\"))\n")
                                        ((string=? (sys:platform) "OSX") ".dylib\"))\n")))
                   *sys:precomp:current-output-port*)
          (display (string-append "(if (not " libname ") (begin (print-with-colors 'red 'default #t (print \"Error\")) (print \": could not load " libname " dynamic library\\n\") (error \"\")))\n")
                   *sys:precomp:current-output-port*)
          (display (string-append "(print \"Loading \")\n(print-with-colors 'magenta 'default #t (print \""
                                  libname "\"))\n(print \" library...\\n\")\n")
                   *sys:precomp:current-output-port*)))))

(define sys:precomp:insert-footer
  (lambda (libname)
    (if (output-port? *sys:precomp:current-output-port*)
        (begin
          (display (string-append "(print-with-colors 'green 'default #t (print \"Loaded \"))\n(print-with-colors 'blue 'default #t (print \"" libname "\"))\n")
                   *sys:precomp:current-output-port*)
          (display (string-append "(print \" library in\" (* 1.0 (/ (- (now) *xtmlib-" (substring libname 3) "-loaded*) *second*)) \"seconds\\n\")\n")
                   *sys:precomp:current-output-port*)
          (display (string-append "(define *xtmlib-" (substring libname 3) "-loaded* (now))\n")
                   *sys:precomp:current-output-port*)
          (display "(set! *impc:compiler:message:level* *sys:precomp:prev-compiler-message-level*)\n"
                   *sys:precomp:current-output-port*)))))

;; if precompiling, insert arbitrary sexp (remember to quote!) into
;; the precomp .xtm file, otherwise do nothing
(define sys:precomp:insert-sexp
  (lambda (sexp)
    (if (output-port? *sys:precomp:current-output-port*)
        (display (string-append (sexpr->string sexp) "\n")
                 *sys:precomp:current-output-port*))))

(define sys:precomp:print-compilation-details
  (lambda (start-time)
    (print-with-colors 'yellow 'default #t
                       (print "Total compile time: "))
    (print (* 1.0 (/ (- (now) start-time) *minute*)) "minutes\n\n")
    
    ;; (println 'sym-name-stack-size: (length *impc:ir:sym-name-stack*))
    (print-with-colors 'cyan 'default #f (print " type-aliases: "))
    (println (length *impc:ir:type-aliases*))
    (print-with-colors 'cyan 'default #f (print "   gpolytypes: "))
    (println (length *impc:ir:gpolytypes*))
    (print-with-colors 'cyan 'default #f (print "    polytypes: "))
    (println (length *impc:ir:polytypes*))
    (print-with-colors 'cyan 'default #f (print "       gpolys: "))
    (println (length *impc:ir:gpolys*))
    (print-with-colors 'cyan 'default #f (print "        polys: "))
    (println (length *impc:ir:polys*))
    (print-with-colors 'cyan 'default #f (print "       vtypes: "))
    (println (length *impc:ti:vtypes*))
    (print-with-colors 'cyan 'default #f (print "gtypemappings: "))
    (println (length *impc:ti:generic-type-mappings*))))

(define sys:precomp:compile-xtm-file
  (lambda (lib-path move-into-place? exit-when-done? exit-on-error?)
    ;; is there a better way to check if a file exists?
    (let ((start-time (now))
          (in-file-port (open-input-file lib-path)))
      (if (not in-file-port)
          (begin (print-with-colors 'red 'default #t
                                    (print "Error:"))
                 (print " no .xtm file at" lib-path "\n"))
          (let* ((res (close-port in-file-port))
                 (libname (filename-from-path lib-path))
                 (libname-no-extension (string-append "xtm" (filename-strip-extension libname)))
                 (precomp-file-path (string-append "" "libs/" libname)))
            (if (not (sys:load-preload-check (string->symbol libname-no-extension)))
                (begin (print "Precomp file not written ")
                       (close-port *sys:precomp:current-output-port*)
                       (set! *sys:precomp:current-output-port* #f))
                (begin
                  ;; if the preload check passes
                  (set! *sys:precomp:current-output-port* (open-output-file precomp-file-path))
                  (set! *sys:precomp:func-defs-in-mod* '())
                  (if (sys:precomp:currently-compiling?)
                      (begin
                        ;; this is the 'success' branch
                        (set! *sys:precomp:current-lib-name* libname-no-extension)
                        ;; (sys:precomp:insert-header libname-no-extension)
                        (sys:load lib-path)
                        (sys:precomp:compile-current-module libname-no-extension move-into-place? exit-on-error?)
                        ;; (sys:precomp:insert-footer libname-no-extension)
                        (close-port *sys:precomp:current-output-port*)
                        (set! *sys:precomp:current-lib-name* "xtmdylib")
                        (if  *sys:precomp:current-output-port*
                             (begin (set! *sys:precomp:current-output-port* #f)
                                    (print "Successfully wrote precomp file to ")
                                    (print-with-colors 'green 'default #f (print precomp-file-path "\n"))
                                    (sys:precomp:print-compilation-details start-time)
                                    (if exit-when-done? (quit 0)))
                             (begin (print-with-colors 'red 'default #t (print "Error:"))
                                    (print " something went wrong in writing the output file ")
                                    (print-with-colors 'red 'default #t (print precomp-file-path "\n"))
                                    (if exit-when-done? (quit 1)))))
                      (begin (print-with-colors 'red 'default #t
                                                (print "Error:"))
                             (print " cannot write precomp file at " precomp-file-path "\n")
                             (if exit-when-done? (quit 2)))))))))))

(define sys:run-tests
  (lambda (test-files print? quit-on-exit?)
    (sys:load "libs/core/test.xtm" 'quiet)
    (xtmtest-reset-results)
    (if (string? test-files)
        (set! test-files (list test-files)))
    (let ((start (now)))
      (for-each (lambda (tf)
                  (sys:load tf))
                test-files)
      
      (if print? (xtmtest-print-results))
      (print "\nCompleted ")
      (print-with-colors 'blue 'default #t
                         (print (apply + (map (lambda (lab) (- (length lab) 1))
                                              *xtmtest-results*))))
      (print " tests in ")
      (let ((dur-sec (/ (- (now) start) *au:samplerate* 1.0)))
        (print-with-colors 'yellow 'default #t
                           (print (if (> dur-sec 60) (/ dur-sec 60) dur-sec)))
        (print (if (> dur-sec 60)
                   " minutes.\n\n"
                   " seconds.\n\n"))))
    (if quit-on-exit?
        (quit (if (cl:some (lambda (label-list)
                             (and (not (equal? (car label-list) 'correct))
                                  (> (length label-list) 1)))
                           *xtmtest-results*)
                  (begin (print-with-colors 'red 'default #t
                                            (print "Some tests failed :(\n"))
                         1)
                  (begin (print-with-colors 'green 'default #t
                                            (print "All tests passed :)\n"))
                         0))))))
