;;
;; Copyright (c) 2011, Andrew Sorensen
;;
;; All rights reserved.
;;
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; 1. Redistributions of source code must retain the above copyright notice,
;;    this list of conditions and the following disclaimer.
;;
;; 2. Redistributions in binary form must reproduce the above copyright notice,
;;    this list of conditions and the following disclaimer in the documentation
;;    and/or other materials provided with the distribution.
;;
;; Neither the name of the authors nor other contributors may be used to endorse
;; or promote products derived from this software without specific prior written
;; permission.
;;
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;

;;;;;;;;;;;;;;;;;;;;;
;; JIT-compilation ;;
;;;;;;;;;;;;;;;;;;;;;

;; this is the "queue" where IR is cached as we go (NB: not actually a
;; queue)
(define *impc:compiler:queued-llvm-ir-string* (make-string 0))

(define impc:compiler:reset-jit-compilation-queue
  (lambda ()
    (set! *impc:compiler:queued-llvm-ir-string* (make-string 0))))

(define impc:compiler:queue-ir-for-compilation
  (lambda (ir-string)
    (set! *impc:compiler:queued-llvm-ir-string*
          (emit ir-string "\n" *impc:compiler:queued-llvm-ir-string*))))

(define impc:compiler:flush-jit-compilation-queue
  (lambda ()
    (if *impc:compiler:print-raw-llvm*
        (print-full-nq *impc:compiler:queued-llvm-ir-string*))
    (if (not (string=? *impc:compiler:queued-llvm-ir-string* ""))
        (let ((res (llvm:jit-compile-ir-string *impc:compiler:queued-llvm-ir-string*)))
          (impc:compiler:reset-jit-compilation-queue)
          ;; (print "Flushed IR compilation queue with result: " res "\n")
          res))))

;; JIT-compile the IR string, or queue it for AOT-compilation
(define llvm:compile-ir
  (lambda (ir-string)
    (if (impc:aot:currently-compiling?)
        (impc:compiler:queue-ir-for-compilation ir-string)
        (begin
          (if *impc:compiler:print-raw-llvm* (print-full-nq ir-string))
          (llvm:jit-compile-ir-string ir-string)))))

(define llvm:compile-ir-and-print
  (lambda (ir-string)
    (print-full-nq ir-string)
    (llvm:compile-ir ir-string)))

;; to compile the special init.ll file (which needs to be done on most
;; startups)
(define sys:compile-ll
  (lambda (name)
    (let ((print? #f))
      (if (string=? (ipc:get-process-name) *impc:compiler:process*)
          (let ((init-ll-string (sys:slurp-file (string-append (sys:share-dir) "/runtime/" name))))
            (if (and init-ll-string (llvm:compile-ir init-ll-string))
                (if print?
                    (begin
                      (print "\nCompiling ")
                      (print-with-colors 'blue 'default #t (print name))
                      (print "... ")
                      (print-with-colors 'green 'default #t (print "done"))
                      (print "\n\n"))
                    #t)
                (begin
                  (print-with-colors 'red 'default #t (print "\n\nError compiling " name " IR\n\n"))
                  (print "This is pretty bad.  Exiting...\n")
                  (quit 1))))))))

(define sys:compile-init-ll
  (lambda ()
    (sys:compile-ll "init.ll")))

;; GCHANGE
;; removes %b when returning base types (i.e. !head%b returns !head)
(define impc:ir:get-base-type-g
  (lambda (str)
    (let* ((r1 (car (regex:split str "##")))
           (r2 (impc:ir:get-ptr-depth r1))
           (r3 (string-append "^([^%]*)%*[a-z]*" (apply string-append (make-list r2 "\\*")) "$")))
      ;; (println str r2 "$1")
      (regex:replace r1 r3 "$1"))))


;; GCHANGE
;; does not remove %b when returning base types (i.e. !head%b returns !head%b
(define impc:ir:get-base-type
  (lambda (str)
    (let* ((r1 (car (regex:split str "##")))
           (r2 (impc:ir:get-ptr-depth r1))
           (r3 (string-append "^(.*)" (apply string-append (make-list r2 "\\*")) "$")))
      ;; (println str r2 "$1")
      (regex:replace r1 r3 "$1"))))


(define impc:ir:get-ptr-depth
  (lambda (t)
    (if (string? t)
        (string-length (cadr (regex:matched t "([*]*)($|#)")))
        (let ((slc (impc:ir:str-list-check t)))
                                        ;(println 't: t 'slc: slc)
          (if (string? slc)
              (impc:ir:get-ptr-depth slc)
              (real->integer (floor (/ (impc:ir:str-list-check slc) *impc:ir:pointer*))))))))

(define impc:ir:clean-named-type
  (lambda (str)
    (if (and (char=? (string-ref str 0) #\%))
        (set! str (substring str 1 (string-length str))))
    (impc:ir:get-base-type str)))

;;  PCRE regex for parsing pretty type strings
(define impc:ir:regex-tc-or-a (string-append "((\\[|\\<)(?<struct>[^<>\\[\\]]|(\\[|\\<)\\g<struct>*(\\]|\\>)\\**)*(\\]|\\>)\\**)"
                                             "|([0-9A-Za-z_]*{(?<tvar>[^{}]|{\\g<tvar>*}\\**)*}\\**)"
                                             "|(\\|[0-9](?<array>[^\\|]|\\|[0-9]\\g<array>*\\|\\**)*\\|\\**)"
                                             "|(/[0-9](?<vector>[^/]|/[0-9]\\g<vector>*/\\**)*/\\**)"
                                             ;; "|(?:([:%#!0-9a-zA-Z_-]({.*?}\\**\)?\\**)+)"))
                                             "|(?:([:%#!0-9a-zA-Z_-]\\**)+)"))

;; this just here for adding back together broken
;; pretty complex types
(define impc:ir:get-type-joiner
  (lambda (lst)
    (let loop ((tmp "")
               (nlst lst)
               (dlst '()))
      (if (null? nlst)
          (reverse dlst)
          (if (regex:match? (car nlst) ":$")
              (loop (car nlst) (cdr nlst) dlst)
              (if (string=? tmp "")
                  (loop "" (cdr nlst) (cons (car nlst) dlst))
                  (loop "" (cdr nlst) (cons (string-append tmp (car nlst)) dlst))))))))


(define impc:ir:get-type-from-pretty-array
  (lambda (string-type . args)
    (let* ((s1 (regex:replace string-type "\\|(.+)\\|?.*" "$1"))
           (t1 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all s1 impc:ir:regex-tc-or-a)))
           (num? (if (regex:match? (car t1) "[a-zA-Z]") ;; (car t1) should be numbers only!
                     (impc:compiler:print-bad-type-error string-type "first element must be a number")))
           (t2 (list (string->number (car t1))
                     (apply impc:ir:get-type-from-pretty-str (cadr t1) args))))
      t2)))

(define impc:ir:get-type-from-pretty-vector
  (lambda (string-type . args)
    (let* ((s1 (regex:replace string-type "/(.+)/?.*" "$1"))
           (t1 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all s1 impc:ir:regex-tc-or-a)))
           (num? (if (regex:match? (car t1) "[a-zA-Z]") ;; (car t1) should be numbers only!
                     (impc:compiler:print-bad-type-error string-type "first element must be a number")))
           (t2 (list (string->number (car t1))
                     (apply impc:ir:get-type-from-pretty-str (cadr t1) args))))
      t2)))

(define impc:ir:get-pretty-tuple-arg-strings
  (lambda (string-type . args)
    (if (not (char=? (string-ref string-type 0) #\<))
        (impc:compiler:print-bad-type-error string-type "tuple type should start with '<'")
        (let* ((s1 (regex:replace string-type "\\<(.*)\\>?.*" "$1"))
               (t1 (impc:ir:get-type-joiner
                    (cl:remove-if (lambda (x) (string=? x ""))
                                  (regex:match-all s1 impc:ir:regex-tc-or-a)))))
          t1))))

(define impc:ir:get-type-from-pretty-tuple
  (lambda (string-type . args)
    (if (not (char=? (string-ref string-type 0) #\<))
        (impc:compiler:print-bad-type-error string-type "tuple type should start with '<'")
        (let* ((s1 (regex:replace string-type "\\<(.*)\\>?.*" "$1"))
               (t1 (impc:ir:get-type-joiner
                    (cl:remove-if (lambda (x) (string=? x ""))
                                  (regex:match-all s1 impc:ir:regex-tc-or-a))))
               (t2 (map (lambda (x) (apply impc:ir:get-type-from-pretty-str x args)) t1)))
          t2))))

(define impc:ir:get-pretty-closure-arg-strings
  (lambda (string-type . args)
    (if (not (char=? (string-ref string-type 0) #\[))
        (impc:compiler:print-bad-type-error string-type "closure type should start with '['")
        (let* ((s1 (regex:replace string-type "\\[(.*)\\]?.*" "$1"))
               (t1 (impc:ir:get-type-joiner
                    (cl:remove-if (lambda (x)
                                    (string=? x ""))
                                  (regex:match-all s1 impc:ir:regex-tc-or-a)))))
          t1))))

(define impc:ir:get-arity-from-pretty-closure
  (lambda (pretty-str)
    (let ((arg-strings (impc:ir:get-pretty-closure-arg-strings pretty-str)))
      (if (list? arg-strings)
          (- (length arg-strings) 1)
          #f))))

(define impc:ir:get-type-from-pretty-closure
  (lambda (string-type . args)
    (let* ((s1 (regex:replace string-type "\\[(.*)\\]?.*" "$1"))
           (t1 (impc:ir:get-type-joiner
                (cl:remove-if (lambda (x)
                                (string=? x ""))
                              (regex:match-all s1 impc:ir:regex-tc-or-a))))
           (t2 (map (lambda (x) (apply impc:ir:get-type-from-pretty-str x args)) t1)))
      t2)))

(define impc:ir:get-generic-tuple-typevars
  (lambda (t)
    (if (impc:ti:namedtype-exists? (impc:ir:get-base-type t))
        (if (string-contains? t "_poly_")
            (let* ((base (impc:ir:get-base-type t))
                   (ptrs (impc:ir:get-ptr-depth t))
                   (p (regex:split base "_poly_"))
                   (name (substring (car p) 1 (string-length (car p))))
                   (l1 (cl:remove-duplicates (regex:match-all
                                              (symbol->string (impc:ti:get-generictype-candidate-types name))
                                              "![A-Za-z_0-9]*")))
                   ;; (l1 (cl:remove-duplicates
                   ;;      (cl:remove-if (lambda (x)
                   ;;                      (and (not (regex:match? x "^!"))            ;; typevar
                   ;;                           (not (and (regex:match? x "^[A-Za-z]") ;; or generic type
                   ;;                                     (impc:ti:generictype-exists?
                   ;;                                      (car (regex:type-split x ":")))))
                   ;;                           (not (and (regex:match? x "^\\[")
                   ;;                                     (regex:match? x "!")))))
                   ;;                    (impc:ir:get-pretty-tuple-arg-strings
                   ;;                     (symbol->string (impc:ti:get-generictype-candidate-types name))))))
                   (l2 (impc:ir:get-pretty-tuple-arg-strings (cname-decode (cadr p))))
                   ;; (llllll (println 'l1 l1 'l2 l2))
                   (typevars (cl:remove-duplicates (map (lambda (x y) (cons x y)) l1 l2))))
              typevars)
            #f)
        #f)))

(define impc:ir:pretty-print-type
  (lambda (t)
    (if (null? t)
        (impc:compiler:print-compiler-error "impc:ir:pretty-print-type cannot print null type")
        (if (string? t)
            (if (impc:ti:namedtype-exists? (impc:ir:get-base-type t))
                (if (regex:match? t "_poly_")
                    (let* ((base (impc:ir:get-base-type t))
                           (ptrs (impc:ir:get-ptr-depth t))
                           (p (regex:split base "_poly_"))
                           (typevars (impc:ir:get-generic-tuple-typevars t))
                           ;; (lllllll (println 'typevars typevars))
                           (res (string-append (substring (car p) 1 (string-length (car p)))
                                               "{"
                                               (string-join (map (lambda (x) (impc:ir:pretty-print-type (cdr x))) typevars) ",")
                                               "}"
                                               (make-string ptrs #\*))))
                      res)
                    (if (char=? (string-ref t 0) #\%)
                        (substring t 1 (string-length t))
                        t))
                (impc:ir:pretty-print-type (impc:ir:get-type-from-pretty-str t)))
            (if (or (null? t) (not (impc:ir:type? t))) '()
                (cond ((atom? t) (impc:ir:get-type-str t))
                      ((impc:ir:tuple? t)
                       (string-append "<" (string-join (map (lambda (k) (impc:ir:pretty-print-type k)) (cdr t)) ",")
                                      ">" (make-string (impc:ir:get-ptr-depth t) #\*)))
                      ((impc:ir:array? t)
                       (string-append "|" (number->string (cadr t)) "," (impc:ir:pretty-print-type (caddr t))
                                      "|" (make-string (impc:ir:get-ptr-depth t) #\*)))
                      ((impc:ir:vector? t)
                       (string-append "/" (number->string (cadr t)) "," (impc:ir:pretty-print-type (caddr t))
                                      "/" (make-string (impc:ir:get-ptr-depth t) #\*)))
                      ((impc:ir:closure? t)
                       (string-append "[" (string-join (map (lambda (k) (impc:ir:pretty-print-type k)) (cdr t)) ",")
                                      "]" (make-string (- (impc:ir:get-ptr-depth t) 1) #\*)))))))))


(define impc:ir:pptype impc:ir:pretty-print-type)
(define impc:ir:get-type-expand-poly #f)
(define *impc:ir:get-type-callback-off* #f)

;; helpful for generics and adhoc polys

(define impc:ir:poly-or-adhoc?
  (lambda (name)
    (regex:match? name "(_adhoc_|_poly_)")))

(define impc:ir:split-and-decode-poly-adhoc-name
  (lambda (name)
    (if (impc:ir:poly-or-adhoc? name)
        (let ((split-name (regex:type-split name "(_adhoc_|_poly_)")))
          (list (car split-name) (cname-decode (cadr split-name))))
        #f)))

(define impc:ir:get-type-from-pretty-str
  (lambda (string-type . args)
    ;; (println 'pretty-string-type-in string-type)
    (let ((res (apply impc:ir:get-type-from-pretty-str-rec string-type args)))
      ;; (println 'pretty-string-type string-type 'to res)
      res)))

;; now with pretty print support
(define impc:ir:get-type-from-pretty-str-rec
  (lambda (string-type . args)
    ;; (println 'ir:get-type-from-pretty-str-rec 'stype: string-type 'args: args)
    (if (or (not (string? string-type))
            (string=? "" string-type))
        (impc:compiler:print-compiler-error (string-append "impc:ir:get-type-from-pretty-str must take a string, not " (sexpr->string string-type))))
    (let* ((ptr-depth (impc:ir:get-ptr-depth string-type))
           (offset (* ptr-depth *impc:ir:pointer*))
                                        ;(expand-closures? (if (null? args) #f (car args)))
                                        ;(base (regex:split (impc:ir:get-base-type string-type) "%")))
           (base (impc:ir:get-base-type string-type)))
      ;; (println 'base: base 'ptr-depth: ptr-depth (string? base))
      (if (< (string-length base) 1)
          (impc:compiler:print-bad-type-error string-type "Illegal type"))
      (cond ((string=? base "void") *impc:ir:void*)
            ((string=? base "notype") *impc:ir:notype*)
            ((string=? base "@") (+ -2 (* *impc:ir:pointer* ptr-depth)))
            ((string=? base "closure") (+ *impc:ir:closure* offset))
            ((string=? base "tuple") (+ *impc:ir:tuple* offset))
            ((string=? base "array") (+ *impc:ir:array* offset))
            ((string=? base "vector") (+ *impc:ir:vector* offset))
            ((regex:match? base "^\\[.*\\]$")
             (cons (+ offset *impc:ir:pointer* *impc:ir:closure*) (apply impc:ir:get-type-from-pretty-closure string-type args)))
            ((regex:match? base "^\\{\\s?i8\\*,\\s?i8\\*.*")
             (cons (+ offset *impc:ir:closure*) (impc:ir:get-closure-type-from-str string-type)))
            ((regex:match? base "^\\<[^{].*[^}]\\>$")
             (cons (+ offset *impc:ir:tuple*) (apply impc:ir:get-type-from-pretty-tuple string-type args)))
            ((regex:match? base "^\\<?\\{.*\\}\\>?\\**")
             (cons (+ offset *impc:ir:tuple*) (impc:ir:get-tuple-type-from-str string-type)))
            ((regex:match? base "^/.*/\\**")
             (cons (+ offset *impc:ir:vector*) (apply impc:ir:get-type-from-pretty-vector string-type args)))
            ((regex:match? base "^\\|.*\\|\\**") ;; |3,double| is an array
             (cons (+ offset *impc:ir:array*) (apply impc:ir:get-type-from-pretty-array string-type args)))
            ((regex:match? base "^[_A-Za-z0-9]*:")
             ;; (println "bingo: " base)
             (let* ((p (regex:type-split base ":"))
                    (ags (impc:ir:get-pretty-tuple-arg-strings (cadr p)))
                    (ags2 (map (lambda (name) ;; check for aliases!
                                 (let ((res (impc:ti:get-typealias-type name)))
                                   (or res name)))
                               ags))
                    (anypolys (cl:find-if
                               (lambda (x) (not (equal? x #f)))
                               (map (lambda (k)
                                      (if (equal? (impc:ir:get-base-type k) (car p)) ;; strip recursives
                                          #f
                                          (impc:ti:get-generictype-candidate-types (impc:ir:get-base-type k))))
                                    ags2))))
               ;; (println 'prealias-p: p)
               ;; set p in case we have aliased types in args that need unaliasing!
               (set! p (list (car p) (string-append "<" (string-join ags2 ",") ">")))

               ;; (println 'postalias-p: p)
               ;; (println 'kit: base 'P: p)
               ;; (println 't (cadr p))
               ;; (println 'ags: ags2)
               ;; (println 'anypolys anypolys)
               (if (string=? (car p) "")
                   (impc:compiler:print-compiler-error "Cannot get type from pretty string" string-type))
               (if (and (impc:ti:get-generictype-candidate-types (car p)) ;; if still generic
                        (or (impc:ti:bang-type? (cadr p)) ;; any gvars
                            anypolys))
                   (let* ((gtype (impc:ti:get-generictype-candidate-types (car p)))
                          ;; (gtype-all (regex:match-all (symbol->string gtype) "(![a-zA-Z0-9-_]*)"))
                          ;; (type-all (regex:match-all (cadr p) "(![a-zA-Z0-9-_]*)")))
                          (gtype-all (impc:ir:get-pretty-tuple-arg-strings (symbol->string gtype)))
                          (type-all (impc:ir:get-pretty-tuple-arg-strings (cadr p))))

                     ;; (if (and (not (null? args))
                     ;;          (string? (car args))
                     ;;          (string=? (car p) (car args)))
                     ;;     (println 'return 'this:
                     ;;              (cons (+ *impc:ir:tuple* (* *impc:ir:pointer* ptr-depth))
                     ;;                    (map string->symbol (impc:ir:get-pretty-tuple-arg-strings (cadr p))))))

                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                     ;; just here as a print check
                     ;; (if (not (and (not (null? args))
                     ;;               (string? (car args))
                     ;;               (string=? (car p) (car args))))
                     ;;     (println "I *think* I'm a reified type!" (car p) " with:" p " and: " args))
                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                     ;; (println '------ 'p p 'gtype-all gtype-all)
                     ;; (println 'type-all type-all)
                     ;; (println 'hitmarck gtype-all type-all)
                     ;; (println 'actuals gtype (cadr p))
                     ;; (println 'pingo: (impc:ir:pointer++ (car p) ptr-depth))
                     (if (<> (length gtype-all) (length type-all))
                         (impc:compiler:print-type-mismatch-error (cadr p) gtype))
                     (if (and (not (null? args))
                              (string? (car args))
                              (string=? (car p) (car args)))
                         (cons (+ *impc:ir:tuple* (* *impc:ir:pointer* ptr-depth))
                               (map string->symbol (impc:ir:get-pretty-tuple-arg-strings (cadr p))))
                         (apply impc:ir:get-type-from-pretty-str-rec
                                (impc:ir:pointer++ (car p) ptr-depth)
                                (list (car p) (cons
                                               (cons (car p) base)
                                               (map (lambda (a b)
                                                      ;; (println 'a a 'b b)
                                                      (let ((aa (apply impc:ir:get-type-from-pretty-str-rec a args))
                                                            (bb (apply impc:ir:get-type-from-pretty-str-rec b args)))
                                                        ;; (println 'a a 'b b)
                                                        ;; (println 'aa aa 'bb bb)
                                                        ;; (println (impc:ir:type? aa) '- (impc:ir:type? bb))
                                                        (if (impc:ir:type? aa) (set! a aa))
                                                        (if (impc:ir:type? bb) (set! b bb))
                                                        (cons a b)))
                                                    gtype-all type-all))))))
                   ;; (string-append "%" (car p) "_poly_"
                   ;;                       (if (impc:ti:generictype-exists? (car p))
                   ;;                           (impc:ti:generate-generic-type-cname
                   ;;                            (cadr p)
                   ;;                            (symbol->string (impc:ti:get-generictype-candidate-types (car p))))
                   ;;                           (if (= (length p) 2)
                   ;;                               (cname-encode (cadr p))
                   ;;                               (cname-encode (apply string-append (cadr p)
                   ;;                                                    (map (lambda (x) (string-append ":" x))
                   ;;                                                         (cddr p))))))
                   ;;                       (make-string ptr-depth #\*)))))
                   (apply impc:ir:get-type-from-pretty-str-rec ;; otherwise fully typed
                          (string-append "%" (car p) "_poly_"
                                         (if (impc:ti:generictype-exists? (car p))
                                             (impc:ti:generate-generic-type-cname
                                              (cadr p)
                                              (symbol->string (impc:ti:get-generictype-candidate-types (car p))))
                                             (if (= (length p) 2)
                                                 (cname-encode (cadr p))
                                                 (cname-encode (apply string-append (cadr p)
                                                                      (map (lambda (x) (string-append ":" x))
                                                                           (cddr p))))))
                                         (make-string ptr-depth #\*))
                          args))))
            ((regex:match? base "^[A-Za-z0-9_]*\\{")
             (let* ((p (impc:ti:split-namedtype base)) ;; (regex:type-split base "{"))
                    (argstr (cadr p)) ;;(string-append "<" (substring (cadr p) 0 (- (string-length (cadr p)) 1)) ">"))
                    (res "")
                    (tup (impc:ir:get-pretty-tuple-arg-strings argstr))
                    (max (impc:ti:maximize-generic-type base)))
               ;; if base does not exist as a
               ;; (println 'base base 'p p 'argstr argstr 'args args)
               (if (not (or (impc:ti:namedtype-exists? (car p))
                            (impc:ti:generictype-exists? (car p))
                            (and (not (null? args))
                                 (string=? (car p) (car args)))))
                   (impc:compiler:print-compiler-error "Bad type in context" base))
               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               ;; just here as a print check
               ;; (if (not (string-contains? argstr "!")) ;; if no bangs present we can reify
               ;;     (println "I *think* I'm a reified type!" p " with:" argstr " tup:" tup 'max: max 'st: string-type))
               ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
               ;; (println 'bingo----> p)
               ;; I want the follow two lines but ... :(
               (if (not (string-contains? argstr "!")) ;; I don't what this one :( I want the next two :)
               ;; (if (and (not (string-contains? argstr "!")) ;; if no bangs present we can reify
               ;;          (not (regex:match? argstr "[A-Za-z0-9]*(\\}|\\>)")))
                   (set! res (apply string-append "%" (car p) "_poly_"
                                    (cname-encode argstr)
                                    ; (string-append "<" argstr ">"))
                                    (make-list ptr-depth "*")))
                   (let ((max (impc:ti:maximize-generic-type base)))
                     ;; (println 'MAX: max '-> base)
                     (set! max (apply string-append max (make-list ptr-depth "*")))
                     (set! res (apply impc:ir:get-type-from-pretty-str-rec max (cons (car p) args)))))
               ;; (println 'res: res 'base: base)
               (if (string? res)
                   (apply impc:ir:get-type-from-pretty-str-rec res (cons (car p) args))
                   res)))
            ((or (and (char=? (string-ref base 0) #\%)
                      (impc:ti:namedtype-exists? base))
                 (and (char=? (string-ref base 0) #\%)
                      (not (null? args))
                      (string=? (car args) base)))
             string-type)
            ((char=? (string-ref base 0) #\%)
             ;; (println 'doingit! base 'args: args)
             ;; (if (not (impc:ti:namedtype-exists? base))
             ;;     (begin (println 'adding 'base base 'as 'opaque)
             ;;            (llvm:compile-ir (string-append base " = type opaque"))))
             (let* ((name1 (substring base 1 (string-length base)))
                    (p1 (regex:type-split name1 "_poly_"))
                    (name (car p1))
                    (encoding (cadr p1))
                    (t1aa (cname-decode encoding))
                    (t1a (string-append
                           "<" (string-join
                                (map (lambda (x)
                                       ;; (println 'testx: x (string-append "^" (car p1) "\\{"))
                                       (if (regex:match? x (string-append "^" (car p1) "\\{"))
                                           (impc:ir:get-type-from-pretty-str x)
                                           x))
                                     (impc:ir:get-pretty-tuple-arg-strings t1aa))
                                ",")
                           ">"))
                    ;; (ll (println 't1aa: t1aa))
                    (t1b (if (impc:ti:generictype-exists? name)
                             (cadr (impc:ti:split-namedtype
                                    (impc:ti:maximize-generic-type
                                     (string-append name "{" (substring t1a 1 (- (string-length t1a) 1)) "}"))))
                             t1a))
                    ;; (t1 (regex:replace-all t1b (string-append name "(?!_)") base))
                    (t1 (regex:replace-all t1b (string-append name "([*\\]>,])") (string-append base "$1")))
                    ;; (llllllll (println 'encoding encoding 't1a t1a 't1aa t1aa 't1b t1b 't1 t1))
                    (t2 (impc:ir:get-pretty-tuple-arg-strings t1))
                    ;; (llllllllll (println 't2 t2))
                    (t3 (map (lambda (k)
                               ;; (println 'k: k (impc:ir:get-base-type k) 'name name 'name1 name1)
                               (if (string=? (impc:ir:get-base-type k) name)
                                   (string-append "%" name1
                                                  (make-string (impc:ir:get-ptr-depth k) #\*))
                                   (impc:ir:get-type-str (apply impc:ir:get-type-from-pretty-str-rec k (cons base args)))))
                             t2))
                    (t4 (string-append "{ " (string-join t3 ", ") " }"))
                    ;; (t5 (map (lambda (k) (impc:ir:get-type-from-str k)) t3))
                    (type t4))
               ;; (println 'name1 name1 't1 t1 't2 t2 't3 t3 't4 t4 'type type)
                     ;; (println 'make-new-type: (string-append "%" name1 " = type " type))
                     ;; (llvm:compile-ir (string-append "%" name1 " = type " type))
                     (if (llvm:compile-ir (string-append "%" name1 " = type " type))
                         (impc:ti:register-new-namedtype name1 (impc:ir:get-type-from-str type) "")
                         (impc:compiler:print-compiler-error "could not compile new type" (cons name type)))
                     (if *impc:ir:get-type-callback-off*
                         (impc:ti:compile-type-dataconstructors (string->symbol name1) type #f #t #t)
                         (callback (now) 'impc:ti:compile-type-dataconstructors (string->symbol name1) type #f #t #t))
                     string-type))
                   ;; (error ""))))
            ((impc:ti:bang-type? base) (string->symbol base))
            ((or (impc:ti:get-generictype-candidate-types base)
                 (impc:ti:get-generictype-candidate-types (car (regex:split base "%"))))
             ;; (println 'gen_chk_with_args: args)
             (let* ((recursive-type (if (and (not (null? args)) (atom? (car args))) (car args) #f))
                    (type-pairs (if (and (not (null? args)) (pair? (car args)))
                                    args
                                    (cl:find-if list? args)))
                                        ;(is_args_assoc_list (if (null? args) #t (if (pair? (car args)) #t #f)))
                    (sb (regex:split base "%"))
                    (base2 (car sb))
                    (extended (if (> (length sb) 1) (cadr sb) #f)))
               ;; (println 'recursive-type recursive-type 'base2 base2 'type-pairs type-pairs)
               ;; (println 'args: args 'base2: base2 'st: string-type)
               ;; (println 'base2: (impc:ti:get-generictype-candidate-types base2))
               (if (and recursive-type (string=? recursive-type base2) (not type-pairs))
                   ;(and (not (null? args))
                   ;     (atom? (car args))
                   ;     (string=? (car args) base2))
                   (string->symbol string-type)
                   (let* (;(type (apply impc:ir:get-type-from-pretty-str-rec
                          ;       (impc:ir:pointer++ (symbol->string (impc:ti:get-generictype-candidate-types base2))
                          ;                          ptr-depth)
                          ;       '())) ;(list base2 (if type-pairs type-pairs #f))))
                          (type (impc:ir:pointer++ (cons *impc:ir:tuple*
                                                         (map string->symbol
                                                              (impc:ir:get-pretty-tuple-arg-strings (symbol->string (impc:ti:get-generictype-candidate-types base2)))))
                                                   ptr-depth)))

                                 ;; (cons base2 args))))
                     ;; (println 'type__: type) ; 't2: t2)
                     ;; if we have come from a defined generic type
                     ;; i.e. List:<!a,List*>
                     ;; then do a replace all on gvars
                     ;; (println 'type-pre: type)
                     (if (and type-pairs (string=? (caar type-pairs) base2))
                         ;; (and (not (null? args))
                         ;;      (or (list? (car args))
                         ;;          (pair? (car args)))
                         ;;      (string=? (caar args) base2))
                         (let ((ptrs (map (lambda (k)
                                            (if (atom? k)
                                                (impc:ir:get-ptr-depth (atom->string k))
                                                (impc:ir:get-ptr-depth k)))
                                          type))
                               (bases (map (lambda (k)
                                             (if (symbol? k)
                                                 (impc:ir:get-base-type (atom->string k))
                                                 k))
                                           type)))
                           ;; (println '%%%%%%%%%%%%%%%%%%: args)
                           ;; (println 'bases bases 'ptrs ptrs)
                           ;; (println 'typea type)
                              (let ((replacements
                                     (map (lambda (x)
                                            (let* ((a (car x))
                                                   (b (cdr x))
                                                   (ap (if (not (string? a)) (list a)
                                                           (regex:type-split a ":")))
                                                   (bp (if (not (string? b)) (list b)
                                                           (regex:type-split b ":")))
                                                   ;; (lll (println 'ap ap 'bp bp))
                                                   (aa (if (= (length ap) 1)
                                                           (car ap)
                                                           (impc:ir:get-type-from-pretty-str-rec (cadr ap))))
                                                   (bb (if (= (length bp) 1)
                                                           (car bp)
                                                           (impc:ir:get-type-from-pretty-str-rec (cadr bp)))))
                                              (cons aa bb)))
                                          (if type-pairs type-pairs '())))) ;(cdr args)))) ;(cdr args))))
                                          ;(cadar args))))
                                (set! type (replace-all bases replacements))) ;;(cadar args)))
                              ;; (set! type (replace-all bases (cadar args)))
                           ;; (println 'typeb type)
                           (set! extended #f)
                           (set! type (map (lambda (k p)
                                             ;; (println 'k: k 'p: p)
                                             (if (string? k)
                                                 (if (char=? (string-ref k 0) #\%)
                                                     (impc:ir:pointer++ k p)
                                                     (string->symbol (impc:ir:pointer++ k p)))
                                                 k))
                                           type ptrs))))
                     ;; (println 'type: type 'extended: extended)
                     (if extended
                         (map (lambda (k)
                                (if (and (symbol? k)
                                         (impc:ti:bang-type? k))
                                    (string->symbol (string-append (symbol->string k) "%" extended))
                                    (if (and (symbol? k)
                                             (string=? (impc:ir:get-base-type (symbol->string k)) base2))
                                        (string->symbol string-type)
                                        k)))
                              type)
                         type)))))
            ((or (impc:ti:namedtype-exists? base)
                 (and (not (null? args))
                      (equal? string-type (car args))))
             (string-append "%" string-type))
            ;; recursive types
            ((and (not (null? args))
                  (string=? base (car args)))
             (if (char=? (string-ref base 0) #\%)
                 string-type
                 (string-append "%" string-type)))
            (else (let loop ((i -1))
                    (if (string=? base (impc:ir:get-type-str i string-type))
                        (+ i offset)
                        (if (< i *impc:ir:lowest-base-type*)
                            (loop (+ i 1))
                            ;; if everything else fails try type aliases
                            (let ((res (impc:ti:get-typealias-type base)))
                              (if res
                                  (impc:ir:pointer++ res ptr-depth)
                                  (impc:compiler:print-could-not-resolve-type-error string-type)))))))))))


(define impc:ir:convert-from-pretty-types
  (lambda (t)
    ;;(print 't: t)
    (if (null? t) '()
        (if (atom? t)
            (impc:ir:get-type-from-pretty-str (sexpr->string t))
            (map (lambda (t)
                   (impc:ir:convert-from-pretty-types t))
                 t)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define impc:ir:regex-structs-or-atoms (string-append
                                        ;;"(\\<?\\{(?<struct>[^{}]|\\<?\\{\\g<struct>*\\}\\>?\\**)*\\}\\>?\\**)"
                                        "(\\<?\\{(?<struct>(?!\\{|\\}|\\<\\{|\\}\\>).|\\<?\\{\\g<struct>*\\}\\>?\\**)*\\}\\>?\\**)"
                                        ;;"|(\\[(?<array>[^\\[\\]]|\\[\\g<array>*\\]\\**)*\\]\\**)"
                                        "|(\\[(?<array>(?!\\[|\\]).|\\[\\g<array>*\\]\\**)*\\]\\**)"
                                        ;;"|(\\<(?<vector>[^<>]|\\<\\g<vector>*\\>\\**)*\\>\\**)"
                                        "|(\\<(?<vector>(?!\\<|\\>).|\\<\\g<vector>*\\>\\**)*\\>\\**)"
                                        "|(?:([%#0-9a-zA-Z_-]\\**)+)"))


(define impc:ir:get-tuple-type-from-str
  (lambda (string-type)
    (let* ((s1 (regex:replace string-type "\\<?\\{(.*)\\}\\>?.*" "$1"))
           (t1 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all s1 impc:ir:regex-structs-or-atoms)))
           (t2 (map (lambda (x) (impc:ir:get-type-from-str x)) t1)))
      t2)))

(define impc:ir:get-array-type-from-str
  (lambda (string-type)
    (let* ((s1 (regex:replace string-type "\\[(.*)\\].*" "$1"))
           (t1 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all s1 impc:ir:regex-structs-or-atoms)))
           (t2 (list (string->number (car t1)) (impc:ir:get-type-from-str (caddr t1)))))
      t2)))

(define impc:ir:get-vector-type-from-str
  (lambda (string-type)
    (let* ((s1 (regex:replace string-type "\\<(.*)\\>.*" "$1"))
           (t1 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all s1 impc:ir:regex-structs-or-atoms)))
           (t2 (list (string->number (car t1)) (impc:ir:get-type-from-str (caddr t1)))))
      t2)))

(define impc:ir:get-closure-type-from-str
  (lambda (string-type)
    (impc:ir:get-function-type-from-str (regex:replace string-type "^\\{\\s?i8\\*,\\s?i8\\*,(.*)\\}.*$" "$1"))))


(define impc:ir:get-function-type-from-str
  (lambda (string-type)
    (let* ((sk (regex:match-all string-type impc:ir:regex-structs-or-atoms))
           (ss (string-append "(" (car sk) " " (string-join (cdddr sk) " ")))
           (s2 (cl:remove-if (lambda (x) (string=? x ""))
                             (regex:match-all ss impc:ir:regex-structs-or-atoms)))
           (s3 (map (lambda (x)
                      (impc:ir:get-type-from-str x))
                    s2)))
      s3)))

(define impc:ir:get-type-from-str
  (lambda (string-type . args)
    ;; (println 'ir:get-type-from-str 'string-type: string-type 'args: args)
    (if (or (not (string? string-type))
            (string=? "" string-type))
        (impc:compiler:print-compiler-error (string-append "impc:ir:get-type-from-str must take a string, not " (sexpr->string string-type))))
    (let* ((ptr-depth (impc:ir:get-ptr-depth string-type))
           (offset (* ptr-depth *impc:ir:pointer*))
           ;;(expand-closures? (if (null? args) #f (car args)))
           (base (impc:ir:get-base-type string-type)))
      (if (= 92 (char->integer (string-ref base 0)))
          (string-set! base 0 (integer->char 48)))
      (cond ((string=? base "void") *impc:ir:void*)
            ((string=? base "notype") *impc:ir:notype*)
            ;; this here just for recursive named types from LLVM IR
            ((string=? base "@") -2)
            ((regex:match? base "^[0-9]*$")
             (- (* -1 ptr-depth *impc:ir:pointer*) (string->number base)))
            ((string=? base "closure") (+ *impc:ir:closure* offset))
            ((string=? base "tuple") (+ *impc:ir:tuple* offset))
            ((string=? base "array") (+ *impc:ir:array* offset))
            ((string=? base "vector") (+ *impc:ir:vector* offset))
                                        ;((regex:match? base "\\<\\{\\s?i8\\*,\\s?i8\\*.*")
            ((and (regex:match? base "^\\<.* x .*\\>\\**$")
                  (not (string-contains? base ",")))
             (cons (+ offset *impc:ir:vector*) (impc:ir:get-vector-type-from-str string-type)))
            ((regex:match? base "^\\{\\s?i8\\*,\\s?i8\\*.*\\)\\**}$")
             (cons (+ offset *impc:ir:closure*) (impc:ir:get-closure-type-from-str string-type)))
                                        ;((regex:match? base "\\<?\\{.*\\}\\>?\\**")
            ((regex:match? base "^\\<?\\{.*\\}\\>?\\**$")
             (cons (+ offset *impc:ir:tuple*) (impc:ir:get-tuple-type-from-str string-type)))
                                        ;((regex:match? base "\\[[^x]*x.*\\]\\**")
            ((regex:match? base "^\\[.*x.*\\]\\**$")
             (cons (+ offset *impc:ir:array*) (impc:ir:get-array-type-from-str string-type)))
            ((char=? (string-ref base 0) #\%)
             string-type)
             ;; (if (impc:ti:namedtype-exists? (substring base 1 (string-length base)))
             ;;     string-type
             ;;     (if (string-contains? string-type "_poly_")
             ;;         (if (impc:ti:spec-new-type? string-type)
             ;;             string-type
             ;;             (impc:compiler:print-bad-type-error string-type "Poly type not yet instantiated??"))
             ;;         (impc:compiler:print-bad-type-error string-type "Named Type Does not EXisT!"))))
            ((assoc-strcmp (string->symbol string-type) *impc:ti:generic-type-mappings*)
             (impc:ir:get-type-from-str (cdr (assoc-strcmp (string->symbol string-type) *impc:ti:generic-type-mappings*))))
            ;; ((regex:match? string-type "##") string-type)
            (else (let loop ((i -1))
                    (if (string=? base (impc:ir:get-type-str i string-type))
                        (+ i offset)
                        (if (< i *impc:ir:lowest-base-type*)
                            (loop (+ i 1))
                            (impc:compiler:print-bad-type-error string-type)))))))))


(define impc:ir:get-type-str
  (lambda (type . args)
    ;; (println 'ir:get-type-str 'type: type 'args: args)
    (if (null? args) (set! args (list type)))
    (if (or (string? type)
            (symbol? type))
        (if (symbol? type) (symbol->string type) type)
        (cond ((list? type) ;; must be a complex type
               (cond ((impc:ir:closure? (car type))
                      (string-append "{i8*, i8*, " (impc:ir:make-function-str (cdr type) #t) "*}"
                                     (make-string (impc:ir:get-ptr-depth (car type)) #\*)))
                     ((impc:ir:tuple? (car type))
                      (string-append "{" (string-join (map (lambda (x) (apply impc:ir:get-type-str x args)) (cdr type)) ",") "}"
                                     (make-string (impc:ir:get-ptr-depth (car type)) #\*)))
                     ((impc:ir:array? (car type))
                      (string-append "[" (number->string (cadr type)) " x " (apply impc:ir:get-type-str (caddr type) args) "]"
                                     (make-string (impc:ir:get-ptr-depth (car type)) #\*)))
                     ((impc:ir:vector? (car type))
                      (string-append "<" (number->string (cadr type)) " x " (apply impc:ir:get-type-str (caddr type) args) ">"
                                     (make-string (impc:ir:get-ptr-depth (car type)) #\*)))
                     (else (impc:compiler:print-bad-type-error type "bad complex type"))))
              ((= type *impc:ir:void*) "void")
              ((= type *impc:ir:notype*) "notype")
              ((< type 0) ;; this here for recursive llvm ir type defs only!
               (let ((base (* -1 (modulo type (* -1 *impc:ir:pointer*))))
                     (ptr-depth (real->integer (floor (/ type (* -1 *impc:ir:pointer*))))))
                 (string-append "\\" (number->string base) (make-string ptr-depth #\*))))
              (else (let ((base (modulo type *impc:ir:pointer*))
                          (ptr-depth (real->integer (floor (/ type *impc:ir:pointer*)))))
                      (string-append (cond ((= base *impc:ir:fp64*) "double")
                                           ((= base *impc:ir:fp32*) "float")
                                           ((member base (list *impc:ir:si64* *impc:ir:ui64*)) "i64")
                                           ((member base (list *impc:ir:si32* *impc:ir:ui32*)) "i32")
                                           ((member base (list *impc:ir:si16* *impc:ir:ui16*)) "i16")
                                           ((member base (list *impc:ir:si8* *impc:ir:ui8* *impc:ir:char*)) "i8")
                                           ((= base *impc:ir:i1*) "i1")
                                           ((string? (car args))
                                            (string-append "%" (car args)))
                                           (else (impc:compiler:print-bad-type-error (if (null? args) type (car args)))))
                                     (make-string ptr-depth #\*))))))))


(define impc:ir:convert-types
  (lambda (t)
                                        ;(print 't: t)
    (if (null? t) '()
        (if (atom? t)
            (impc:ir:get-type-from-str (sexpr->string t))
            (map (lambda (t)
                   (impc:ir:convert-types t))
                 t)))))


(define impc:ir:str-list-check
  (lambda (type)
    ;; (println 'ir:str-list-check type)
    (cond ((string? type)
           (if (impc:ti:namedtype-exists? (impc:ir:get-base-type type))
               type
               (impc:ir:str-list-check (impc:ir:get-type-from-str type))))
          ((symbol? type)
           (set! type (symbol->string type))
           (if (impc:ti:namedtype-exists? (impc:ir:get-base-type type))
               type
               (if (and (char=? (string-ref type 0) #\!))
                   type
                   ;; (impc:ir:str-list-check (impc:ir:get-type-from-str type)))
                   (if (assoc-strcmp type *impc:ti:generic-type-mappings*)
                       (cdr (assoc-strcmp type *impc:ti:generic-type-mappings*))
                       type))))
          ((list? type) ; complex type
           (cond ((impc:ir:closure? (car type)) (car type))
                 ((impc:ir:tuple? (car type)) (car type))
                 ((impc:ir:array? (car type)) (car type))
                 ((impc:ir:vector? (car type)) (car type))
                 (else *impc:ir:badtype*)))
          (else type))))


(define impc:ir:get-alignment
  (lambda (t)
    (let  ((nt (impc:ti:get-namedtype-type t)))
      (if nt (set! t nt)))
    (cond ((impc:ir:pointer? t) (/ (sys:pointer-size) 8))
          ((impc:ir:array? t) (impc:ir:get-type-size (caddr t))) ;; align to array element type
          ((impc:ir:vector? t) (impc:ir:get-type-size t)) ;; align to full size of vector
          ((or  ;; tuples align to their largest internal aligment
            (impc:ir:closure? t)
            (impc:ir:tuple? t))
           (apply max (map (lambda (tt)
                             (impc:ir:get-alignment tt))
                           (cdr t))))
          ;; (else (impc:ir:get-type-size t)))))
          (else ;; under MCJIT i64 appears to be 4-byte aligned, not
           ;; 8-byte aligned. WTF?
           (if (= t 2) 4 (impc:ir:get-type-size t))))))


(define impc:ir:get-tuple-type-size
  (lambda (type)
    (let ((t (cons *impc:ir:tuple* (impc:ir:get-tuple-type-from-str (impc:ir:get-type-str type)))))
      ;; if tuple is pointer return pointer-size
      (if (> (car t) *impc:ir:pointer*) (/ (sys:pointer-size) 8)
          ;; otherwise
          (let ((et '()) ;; element type
                (size 0)
                (largest 0)
                (align 0)
                (offset 0)
                (this_size 0)
                (elmts (- (length t) 1)))
            (dotimes (i elmts)
              (set! et (list-ref t (+ i 1)))
              (set! this_size (impc:ir:get-type-size et))
              (set! align (impc:ir:get-alignment et))
              (if (> align largest) (set! largest align))
              (set! offset (modulo size align))
              (if (> offset 0) (set! offset (- align offset)))
              (set! size (+ size this_size offset)))
            ;; finally the whole struct should be aligned
            ;; to the largest internal aligment
            (if (> (modulo size largest) 0)
                (set! size (+ size (- largest (modulo size largest)))))
            size)))))


(define impc:ir:get-type-size
  (lambda (type)
    (if (string? type)
        ;; if this is a named type string
        (if (impc:ti:namedtype-exists? type)
            (if (impc:ir:pointer? type)
                (/ (sys:pointer-size) 8) ;; in bytes not bits
                (impc:ir:get-type-size (impc:ti:get-namedtype-type type)))
            (impc:ir:get-type-size (impc:ir:get-type-from-str type)))
        (let ((t (impc:ir:str-list-check type)))
          (if (impc:ir:pointer? t) (/ (sys:pointer-size) 8) ;; in bytes not bits
              (cond ((member t (list *impc:ir:fp64* *impc:ir:si64* *impc:ir:ui64*)) 8) ; 8 byte stuff
                    ((member t (list *impc:ir:fp32* *impc:ir:si32* *impc:ir:ui32*)) 4) ; 4 byte stuff
                    ((member t (list *impc:ir:si16* *impc:ir:ui16*)) 2) ; 2 byte stuff
                    ((member t (list *impc:ir:char* *impc:ir:si8* *impc:ir:ui8* *impc:ir:i1*)) 1) ; 1 bytes stuff
                    ((= t *impc:ir:closure*) (* (impc:ir:get-type-size "i8*") 3))
                    ((= t *impc:ir:array*) (* (impc:ir:get-type-size (caddr type)) (cadr type)))
                    ((= t *impc:ir:vector*) (* (impc:ir:get-type-size (caddr type)) (cadr type)))
                    ((= t *impc:ir:tuple*)
                     (impc:ir:get-tuple-type-size type)
                     ;; (llvm:get-struct-size (impc:ir:get-type-str type))
                     )
                    (else (impc:compiler:print-bad-type-error type "bad type in get-size"))))))))

;; handy for checking that the type size calculations are getting done
;; correctly.  typename-list should be a list of typenames (as strings)
(define impc:ir:check-type-size-calculations
  (lambda (typename-list)
    (for-each (lambda (type)
                (if (<> (impc:ir:get-type-size type)
                        (llvm:get-named-struct-size type))
                    (println
                     'type: type
                     'impc: (impc:ir:get-type-size type)
                     'llvm: (llvm:get-named-struct-size type))))
              typename-list)
    #t))

(define impc:ir:objectsize-intrinsic
  (lambda (object-name rettype)
    (format "@llvm.objectsize.~a(i8* ~a, i1 true)" object-name rettype)))


(define impc:ir:pointer--
  (lambda (type . ptr-depth)
    (if (null? ptr-depth)
        (set! ptr-depth 1)
        (set! ptr-depth (car ptr-depth)))
    (if (string? type) ;; this used to check for tuple? as well
        (substring type 0 (- (string-length type) ptr-depth))
        (if (or (impc:ir:closure? type)
                (impc:ir:array? type)
                (impc:ir:vector? type)
                (impc:ir:tuple? type))
            (let ((nl (cl:copy-list (if (string? type) (impc:ir:get-type-from-str type) type))))
              (set-car! nl (- (impc:ir:str-list-check type) (* *impc:ir:pointer* ptr-depth)))
              nl)
            (- (impc:ir:str-list-check type) (* *impc:ir:pointer* ptr-depth))))))


(define impc:ir:pointer++
  (lambda (type . ptr-depth)
    (if (null? ptr-depth)
        (set! ptr-depth 1)
        (set! ptr-depth (car ptr-depth)))
    (if (string? type) ;; this used to check for tuple? as well
        (string-append type (make-string ptr-depth #\*))
        (if (or (impc:ir:closure? type)
                (impc:ir:array? type)
                (impc:ir:vector? type)
                (impc:ir:tuple? type))
            (let ((nl (cl:copy-list (if (string? type) (impc:ir:get-type-from-str type) type))))
              (set-car! nl (+ (impc:ir:str-list-check type) (* *impc:ir:pointer* ptr-depth)))
              nl)
            (+ (impc:ir:str-list-check type) (* *impc:ir:pointer* ptr-depth))))))

(define impc:ir:type?
  (lambda (type)
    (if (string? type)
        (if (and (char=? (string-ref type 0) #\%)
                 (impc:ti:namedtype-exists?
                      (substring (impc:ir:get-base-type type) 1
                                 (string-length (impc:ir:get-base-type type)))))
            #t
            (impc:ir:type? (impc:ir:get-type-from-str type)))
        (cond ((null? type) #f)
              ((and (number? type)
                    ;; (or (< type 0) (< (modulo type *impc:ir:pointer*) *impc:ir:closure*)) ;; this should be true but is actually more trouble than it's worth at this stage
                    (< type 1001))
               #t)
              ((and (list? type)
                    (number? (car type))
                    (or (impc:ir:closure? type)
                        (impc:ir:tuple? type))
                    (cl:every (lambda (x) x)
                              (map (lambda (a) (impc:ir:type? a)) (cdr type))))
               #t)
              ((and (list? type)
                    (number? (car type))
                    (or (impc:ir:array? type)
                        (impc:ir:vector? type))
                    (impc:ir:type? (caddr type)))
               #t)
              (else #f)))))


(define impc:ir:types-equal?
  (lambda (a b)
    (if (string? a)
        (if (impc:ti:get-named-type (impc:ir:get-base-type (impc:ir:clean-named-type a)))
            (let* ((nt (impc:ti:get-named-type (impc:ir:get-base-type (impc:ir:clean-named-type a))))
                   (ptrdepth (impc:ir:get-ptr-depth a))
                   (strtype (impc:ir:pointer++ nt ptrdepth)))
              (set! a (impc:ir:get-type-from-str strtype)))
            (set! a (impc:ir:get-type-from-str a))))
    (if (string? b)
        (if (impc:ti:get-named-type (impc:ir:get-base-type (impc:ir:clean-named-type b)))
            (let* ((nt (impc:ti:get-named-type (impc:ir:get-base-type (impc:ir:clean-named-type b))))
                   (ptrdepth (impc:ir:get-ptr-depth b))
                   (strtype (impc:ir:pointer++ nt ptrdepth)))
              (set! b (impc:ir:get-type-from-str strtype)))
            (set! b (impc:ir:get-type-from-str b))))
    ;; (println 'equal? a b)
    (equal? a b)))

(define impc:ir:other?
  (lambda (type)
    (let ((t (impc:ir:str-list-check type)))
      (if (string? t) #f
          (if (= t *impc:ir:other*) #t #f)))))

(define impc:ir:pointer?
  (lambda (type)
    (let ((t (impc:ir:str-list-check type)))
      (if (string? t) (> (impc:ir:get-ptr-depth t) 0)
          (if (>= t *impc:ir:other*) #f
              (if (>= t *impc:ir:pointer*) #t #f))))))

(define impc:ir:scalar?
  (lambda (type)
    (not (impc:ir:pointer? type))))

(define impc:ir:tuple?
  (lambda (type)
    (if (list? type)
        (if (< (length type) 2) #f
            (if (impc:ir:tuple? (car type)) #t #f))
        (let ((t (impc:ir:str-list-check type)))
          (if (symbol? t) #f ;; symbol will be poly type
              (if (string? t)
                  (impc:ti:namedtype-exists? (impc:ir:get-base-type t))
                  (if (= (modulo t *impc:ir:pointer*) *impc:ir:tuple*)
                      #t #f)))))))

(define impc:ir:array?
  (lambda (type)
    (if (list? type)
        (if (< (length type) 2) #f
            (if (impc:ir:array? (car type)) #t #f))
        (let ((t (impc:ir:str-list-check type)))
          (if (string? t) #f
              (if (= (modulo t *impc:ir:pointer*) *impc:ir:array*)
                  #t #f))))))

(define impc:ir:vector?
  (lambda (type)
    (if (list? type)
        (if (< (length type) 2) #f
            (if (impc:ir:vector? (car type)) #t #f))
        (let ((t (impc:ir:str-list-check type)))
          (if (string? t) #f
              (if (= (modulo t *impc:ir:pointer*) *impc:ir:vector*)
                  #t #f))))))

(define impc:ir:closure?
  (lambda (type)
    (if (list? type)
        (if (< (length type) 2) #f
            (if (impc:ir:closure? (car type)) #t #f))
        (let ((t (impc:ir:str-list-check type)))
          (if (string? t) #f
              (if (= (modulo t *impc:ir:pointer*) *impc:ir:closure*)
                  #t #f))))))

(define impc:ir:complex-type?
  (lambda (type)
    (cond ((impc:ir:closure? type) #t)
          ((impc:ir:tuple? type) #t)
          ((impc:ir:array? type) #t)
          ((impc:ir:vector? type) #t)
          (else #f))))

(define impc:ir:signed?
  (lambda (type)
    (let* ((t (impc:ir:str-list-check type)))
      (if (string? t) #f
          (if (>= t *impc:ir:other*) #f
              (if (member (modulo t *impc:ir:pointer*)
                          (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:si8*))
                  #t #f))))))

(define impc:ir:floating-point?
  (lambda (type)
    (let ((t (impc:ir:str-list-check type)))
      (if (string? t) #f
          (if (>= t *impc:ir:other*) #f
              (if (member t ;;(modulo t *impc:ir:pointer*)
                          (list *impc:ir:fp64* *impc:ir:fp32*))
                  #t #f))))))

(define impc:ir:fixed-point?
  (lambda (type)
    (if (null? type)
        (error))
    (let ((t (impc:ir:str-list-check type)))
      (if (string? t) #f
          (if (member t ;;(modulo t *impc:ir:pointer*)
                      (list *impc:ir:si64* *impc:ir:si32* *impc:ir:si16* *impc:ir:si8*
                            *impc:ir:ui64* *impc:ir:ui32* *impc:ir:ui16* *impc:ir:ui8*
                            *impc:ir:char*
                            *impc:ir:i1*))
              #t #f)))))

(define impc:ir:boolean?
  (lambda (type)
    (let ((t (impc:ir:str-list-check type)))
      (if (string? t) #f
          (if (member (modulo t *impc:ir:pointer*)
                      (list *impc:ir:i1*))
              #t #f)))))


(define impc:ir:number?
  (lambda (type)
    (or (impc:ir:floating-point? type)
        (impc:ir:fixed-point? type))))


(define impc:ir:void?
  (lambda (type)
    (let ((t (impc:ir:str-list-check type)))
      ;; (println 'type: type 't: t)
      (if (string? t) #f
          (if (= t *impc:ir:void*) #t #f)))))

(define impc:ir:strip-space
  (lambda (str)
    (string-strip str)))

(define impc:ir:make-function-str
  (lambda (t . with-env-added?)
    (let* ((os (make-string 0))
           (args (cdr t)))
      (if (car with-env-added?)
          (emit (string-append (impc:ir:get-type-str (car t))
                               " (i8*, i8*"
                               (if (null? args)
                                   ""
                                   ", "))
                os)
          (emit  (impc:ir:get-type-str (car t)) " (" os))
      (dotimes (i (length args))
        (if (> i 0) (emit ", " os))
        (if (symbol? (list-ref args i))
            (impc:compiler:print-could-not-resolve-type-error (list-ref args i)))
        (emit (impc:ir:get-type-str (list-ref args i)) os))
      (emit ")" os)
      (impc:ir:strip-space os))))


(define impc:ir:make-struct-str
  (lambda (t)
    (let* ((os (make-string 0))
           (args t))
      (emit "{"os)
      (dotimes (i (length args))
        (if (> i 0) (emit ", " os))
        (emit (impc:ir:get-type-str (cdr (list-ref args i))) os))
      (emit "}" os)
      (impc:ir:strip-space os))))


(define impc:ir:make-struct-str-env
  (lambda (t)
    (let* ((os (make-string 0))
           (args t))
      (emit "{"os)
      (dotimes (i (length args))
        (if (> i 0) (emit ", " os))
        (emit  (impc:ir:get-type-str (cdr (list-ref args i))) "*" os))
      (emit "}" os)
      (impc:ir:strip-space os))))


(define impc:ir:make-arglist-str
  (lambda (args . with-symbol?)
    (let* ((os (make-string 0)))
      (dotimes (i (length args))
        (if (> i 0) (emit ", " os))
        (let ((arg (list-ref args i)))
                                        ;(print 'arg: arg)
          (emit (impc:ir:get-type-str (cdr arg)) os)
          (if (car with-symbol?)
              (emit  " %" (symbol->string (car arg)) os))))
      (impc:ir:strip-space os))))


(define impc:ir:make-string
  (lambda (ast)
    (let* ((os (make-string 0))
           (cnt 0))
      (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
            (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
            os)
                                        ;(emit (impc:ir:gname "zone" "%mzone*") " = call %mzone* @llvm_peek_zone_stack()\n" os)
      (emit (impc:ir:gname "string" "i8*") " = call i8* @llvm_zone_malloc(%mzone* "
            (car (impc:ir:gname "zone")) ", i64 " (number->string (+ 1 (string-length ast))) ")\n" os)
      (define strname (car (impc:ir:gname)))
      (for-each (lambda (char)
                  (emit (string-append (impc:ir:gname "val" "i8*") " = "
                                       "getelementptr i8, i8* " strname
                                       ", i32 " (number->string cnt) "\n") os)
                  (emit (string-append "store i8 " (number->string (char->integer char))
                                       ", i8* " (car (impc:ir:gname)) "\n") os)
                  (set! cnt (+ cnt 1)))
                (append (string->list ast) (list (integer->char 0))))
      (impc:ir:gname "string" (car (impc:ir:gname "string")) (cadr (impc:ir:gname "string")))
      (impc:ir:strip-space os))))

(define impc:ir:make-const-string
  (lambda (ast)
    (let* ((os (make-string 0))
           (lgthstr1 (regex:replace-all ast "\\\\[0-9][0-9]" "x"))
           (lgthstr2 (if (and *impc:aot:current-output-port* (not *impc:compiler:aot:dll*))
                         (regex:replace-all lgthstr1 "[\n]" "x") ;(if (string=? (sys:platform) "Windows") "xx" "x"))
                         lgthstr1))
           (lgth (number->string (+ (string-length lgthstr2) 1))) ;; unix & windows above just used to determine string length
           (strtyp (string-append "[" lgth " x i8]*"))
           (strname (string-append "@gs" (if (string? *impc:compiler:global-module-name*) *impc:compiler:global-module-name* "")
                                   (if #f ;;(< (string-length ast) 1024)
                                       (cname-encode ast)
                                       (number->string *impc:ir:gstrcnt*))))
           (strsym '()))
      (if (not (llvm:get-llvm-alias ast))
          (let ((compile-str (string-append strname
                                            (if (sys:mcjit-enabled)
                                                (string-append " = hidden constant [" lgth " x i8] c\"")
                                                (string-append " = private unnamed_addr constant [" lgth " x i8] c\""))
                                            ast "\\00\"")))
            (llvm:compile-ir compile-str)
            (set! strsym strname)
            (llvm:add-llvm-alias ast strsym)
            (if #t ;; (>= (string-length ast) 1024)
                (set! *impc:ir:gstrcnt* (+ *impc:ir:gstrcnt* 1))))
          (set! strsym (llvm:get-llvm-alias ast)))
      (emit (string-append (impc:ir:gname "var" "i8*") " = bitcast " strtyp " " strsym " to i8*\n") os)
      (impc:ir:strip-space os))))



;; This looks scary but it's basically all just
;; making and filling an environment structure
;; for a particular closure
(define impc:ir:compile:make-closureenv
  (lambda (ast types)
    ;; (println 'make-closure-env 'ast: ast 'types: types)
    (let* ((os2 (make-string 0))
           (os1 (make-string 0))
           (name (list-ref ast 2))
           (allocate-mem? (list-ref ast 1))
           (rettype (list-ref ast 3))
           (env (list-ref ast 4))
           (args (list-ref ast 5))
           (code (list-ref ast 6)))
      (define func-type-str (impc:ir:make-function-str (list* rettype (map (lambda (x) (cdr x)) args)) #t))

      (define closure-struct-str
        (string-append "{ i8*, i8*, " func-type-str "*}"))

      (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
            (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
            os2)
      ;; (emit (impc:ir:gname "zone" "%mzone*") " = call %mzone* @llvm_peek_zone_stack()\n" os2)
      (emit "call void @llvm_zone_mark(%mzone* " (car (impc:ir:gname "zone")) ")\n" os2)
      ;; malloc closure structure
      (emit "; malloc closure structure\n" os2)
      (cond ((eq? (car ast) '__make-closure-h)
             (emit (impc:ir:gname "clsptr" "i8*") " = call i8* @malloc("
                   *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size closure-struct-str)) ")\n" os2))
            ((and (eq? (car ast) '__make-closure-s) (not *WINDOWS_ALLOC_BUG*))
             (emit (impc:ir:gname "clsptr" "i8*") " = alloca i8, "
                   *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size closure-struct-str))
                   ", align 16\n" os2))
            (else
             (emit (impc:ir:gname "clsptr" "i8*") " = call i8* @llvm_zone_malloc("
                   "%mzone* " (car (impc:ir:gname "zone")) ", i64 "
                   (number->string (impc:ir:get-type-size closure-struct-str)) ")\n" os2)))

      (emit (impc:ir:gname "closure" (string-append closure-struct-str "*"))
            " = bitcast i8* " (car (impc:ir:gname "clsptr"))
            " to " closure-struct-str "*\n" os2)
      ;; malloc evironment structure
      (emit "\n; malloc environment structure\n" os2)
      (define estruct (impc:ir:make-struct-str-env env))
      (cond ((eq? (car ast) '__make-closure-h)
             (emit (impc:ir:gname "envptr" "i8*") " = call i8* @malloc("
                   *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size estruct)) ")\n" os2))
            ((and (eq? (car ast) '__make-closure-s) (not *WINDOWS_ALLOC_BUG*))
             (emit (impc:ir:gname "envptr" "i8*") " = alloca i8, "
                   *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size estruct))
                   ", align 16\n" os2))
            (else
             (emit (impc:ir:gname "envptr" "i8*") " = call i8* @llvm_zone_malloc("
                   "%mzone* " (car (impc:ir:gname "zone")) ", i64 " (number->string (impc:ir:get-type-size estruct)) ")\n" os2)))
      (emit (impc:ir:gname "environment" (string-append estruct "*"))
            " = bitcast i8* " (car (impc:ir:gname "envptr"))
            " to " estruct "*\n" os2)
      ;; make new closure_address_table
      (emit "\n; malloc closure address table\n" os2)
      (emit (impc:ir:gname "addytable" "%clsvar*") " = call %clsvar* @new_address_table()\n" os2)
      (define table (impc:ir:gname))
      (define ptridx 0)
      (dotimes (i (length env))
        (let* ((e (list-ref env i))
               (varname (if (regex:match? (symbol->string (car e)) "__sub$")
                            (cadr (regex:matched (symbol->string (car e)) "(.*)__sub$"))
                            (symbol->string (car e))))
                                        ;(name-str (impc:ir:make-string varname))
               (name-str (impc:ir:make-const-string varname))
               (name (impc:ir:gname))
                                        ;(type-str (impc:ir:make-string (impc:ir:get-type-str (cdr e))))
               (type-str (impc:ir:make-const-string (impc:ir:get-type-str (cdr e))))
               (type (impc:ir:gname)))
          (emit name-str os2)
          (emit type-str os2)
          (emit (impc:ir:gname "addytable" "%clsvar*")
                " = call %clsvar* @add_address_table("
                "%mzone* " (car (impc:ir:gname "zone")) ", "
                (cadr name) " " (car name) ", "
                "i32 " (number->string ptridx) ", "
                (cadr type) " " (car type) ", "
                (cond ((eq? (car ast) '__make-closure-h) "i32 1, ")
                      ((and (eq? (car ast) '__make-closure-s) (not *WINDOWS_ALLOC_BUG*)) "i32 2, ")
                      (else "i32 3, "))
                "%clsvar* " (car table) ")\n"
                os2)
          (set! table (impc:ir:gname))
          (set! ptridx (+ ptridx (/ (sys:pointer-size) 8))))) ; need it as bytes
      (emit (impc:ir:gname "address-table" "i8*") " = bitcast %clsvar* " (car table) " to i8*\n" os2)
      ;; add data to environment structure
      (emit "; add data to environment\n" os1)
      (dotimes (i (length env))
        (let* ((e (list-ref env i))
               (alloc? (not (regex:match? (symbol->string (car e)) "__sub$"))))
          ;; first fixup mangled name if not allocing
          (if (not alloc?) (set! e (cons (string->symbol (car (regex:split (symbol->string (car e)) "__sub$")))
                                         (cdr e))))
          (define t (begin (impc:ir:gname (string-append (symbol->string (car e)) "EnvPtr")
                                          (string-append (impc:ir:get-type-str (cdr e)) "*"))
                           (impc:ir:gname)))

          (emit "; don't need to alloc for env var " (symbol->string (car e)) "\n" os1)
          (emit (impc:ir:gname "tmp_envptr" (string-append (cadr t) "*")) " = getelementptr "
                estruct ", " estruct "* " (car (impc:ir:gname "environment")) ", "
                "i32 0, i32 " (number->string i) "\n" os1)
          ;;(emit (impc:ir:gname "tmpttff" "i8*") " = bitcast " (cadr t) " %" (symbol->string (car e)) "Ptr to i8*\n" os1)
          ;;(emit "call ccc void @llvm_print_i32(i32 " (number->string i) ")\n" os1)
          ;;(emit "call ccc void @llvm_print_pointer(i8* " (car (impc:ir:gname)) ")\n" os1)
          (emit "store " (cadr t) " %" (symbol->string (car e)) "Ptr"
                ", "
                (cadr t) "* " (car (impc:ir:gname "tmp_envptr")) "\n\n" os1)))

      (emit "\n" os1)

      ;; insert stuff into closure
      (emit "\n; insert table, function and environment into closure struct\n" os2)
      (emit (impc:ir:gname "closure.table" "i8**") " = getelementptr " closure-struct-str ", " closure-struct-str "* "
            (car (impc:ir:gname "closure")) ", i32 0, i32 0\n" os2)
      (emit "store i8* " (car (impc:ir:gname "address-table")) ", i8** "
            (car (impc:ir:gname)) "\n" os2)
      (emit (impc:ir:gname "closure.env" "i8**") " = getelementptr " closure-struct-str ", " closure-struct-str "* "
            (car (impc:ir:gname "closure")) ", i32 0, i32 1\n" os2)
      (emit "store i8* " (car (impc:ir:gname "envptr")) ", i8** "
            (car (impc:ir:gname)) "\n" os2)
      (emit (impc:ir:gname "closure.func" (string-append func-type-str "**"))
            " = getelementptr " closure-struct-str ", " closure-struct-str "* " (car (impc:ir:gname "closure"))
            ", i32 0, i32 2\n" os2)
      (emit "store " func-type-str "* @" name ", " func-type-str "** " (car (impc:ir:gname)) "\n" os2)
      (impc:ir:gname "closure" (car (impc:ir:gname "closure")) (cadr (impc:ir:gname "closure")))
      ;; force set size of clsptr to the complete size of the closure!
      ;; this allows us to easily copy the entire closure
      (emit (impc:ir:gname "closure_size" "i64") " = call i64 @llvm_zone_mark_size(%mzone* " (car (impc:ir:gname "zone")) ")\n" os2)
      (emit "call void @llvm_zone_ptr_set_size(i8* " (car (impc:ir:gname "clsptr")) ", i64 " (car (impc:ir:gname)) ")\n" os2)

      (impc:ir:gname "closure" (car (impc:ir:gname "closure")) (cadr (impc:ir:gname "closure")))
      ;; add an additional pointer wrapper for closure
      (cond ((eq? (car ast) '__make-closure-h)
             (emit (impc:ir:gname "wrapper_ptr" "i8*") " = call i8* @malloc(" *impc:ir:size_t_str* " "
                   *impc:ir:pointer_size_bytes_str* ")\n" os2))
            ((and (eq? (car ast) '__make-closure-s) (not *WINDOWS_ALLOC_BUG*))
             (emit (impc:ir:gname "wrapper_ptr" "i8*") " = alloca i8, "
                   " i32 " *impc:ir:pointer_size_bytes_str*
                   ", align 16\n" os2))
            (else
             (emit (impc:ir:gname "wrapper_ptr" "i8*") " = call i8* @llvm_zone_malloc(%mzone* " (car (impc:ir:gname "zone")) ", i64 "
                   *impc:ir:pointer_size_bytes_str* ")\n" os2)))
      (emit (impc:ir:gname "closure_wrapper" (string-append (cadr (impc:ir:gname "closure")) "*"))
            " = bitcast i8* " (car (impc:ir:gname "wrapper_ptr")) " to " (cadr (impc:ir:gname "closure")) "*\n" os2)
      (emit "store " (cadr (impc:ir:gname "closure")) " " (car (impc:ir:gname "closure")) ", "
            (cadr (impc:ir:gname "closure")) "* " (car (impc:ir:gname "closure_wrapper")) "\n" os2)
      ;; last gname should be closure_wrapper (a pointer to a closure - i.e. [double,double]**)
      (cons (impc:ir:strip-space os2)
            (impc:ir:strip-space os1)))))

(define impc:ir:compile:make-closure
  (lambda (ast types)
    ;;(println 'ast: ast)
    (let* ((os (make-string 0))
           (name (list-ref ast 2))
           (allocate-mem? (list-ref ast 1))
           (rettype (list-ref ast 3))
           (result '())
           (env (list-ref ast 4))
           (args (list-ref ast 5))
           (code (list-ref ast 6)))
      ;;(println 'making-closure--------------------------------------> )
      ;;(println 'name: name)
      ;;(println 'allocate: allocate-mem?)
      ;;(println 'rettype: rettype)
      ;;(println 'env: env)
      ;;(println 'args: args)
      ;;(println 'code: code)
      ;; first we make the function code
      ;; define fastcc function with return type
      (emit  "define dllexport fastcc " (impc:ir:get-type-str rettype) " @" name "(" os)
                                        ;(if (not (null? env)) (emit "i8* %_impenv" os))
      (emit "i8* %_impz," os)
      (emit "i8* %_impenv" os)
      (if (not (null? args)) (emit  ", " (impc:ir:make-arglist-str args #t) os))
      ;; close off function opening
      (emit ") nounwind {\n" os)
      (emit "entry:\n" os)
      ;;(emit "; setup zone\n" os)
      ;;(emit "%_zone = bitcast i8* %_impz to %mzone*\n" os)

      ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; ;; new for impz stuff
      (emit "%_impzPtr = alloca i8*\n" os)
      (emit "store i8* %_impz, i8** %_impzPtr\n" os)
      ;; (emit (impc:ir:gname "zone" "%mzone*") " = bitcast i8* %_impz to %mzone*\n" os)
      ;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

      (emit (impc:ir:gname "zone" "%mzone*") " = bitcast i8* %_impz to %mzone*\n" os)
      ;; (emit (impc:ir:gname "zone" "%mzone*") " = call %mzone* @llvm_peek_zone_stack()\n" os)

      ;; first we need to pull evironment values
      (if (not (null? env))
          (begin (emit "; setup environment\n" os)
                 (emit (string-append "%impenv = bitcast i8* %_impenv to "
                                      (impc:ir:make-struct-str-env env) "*\n") os)
                 (dotimes (i (length env))
                   (let ((e (list-ref env i)))
                     ;; need to strip __sub's
                     (if (regex:match? (symbol->string (car e)) "__sub$")
                         (set! e (cons (string->symbol (car (regex:split (symbol->string (car e)) "__sub$")))
                                       (cdr e))))
                                        ;(print 'e: e)
                     (emit (string-append "%" (symbol->string (car e)) "Ptr_ = getelementptr "
                                          (impc:ir:make-struct-str-env env) ", " (impc:ir:make-struct-str-env env) "* %impenv, "
                                          "i32 0, i32 " (number->string i) "\n") os)
                     (emit (string-append "%" (symbol->string (car e)) "Ptr = load "
                                          (impc:ir:get-type-str (cdr e)) "*, "
                                          (impc:ir:get-type-str (cdr e)) "** %"
                                          (symbol->string (car e)) "Ptr_\n") os)))))
      ;; next we pull the function arguments
      (emit "\n; setup arguments\n" os)
      (dotimes (i (length args))
        (let* ((a (list-ref args i)))
          (set! *impc:ir:sym-name-stack* (cons (car a) *impc:ir:sym-name-stack*))
          (if (> allocate-mem? 0)
              (begin ;; (println 'yes: allocate-mem? 'mem: ast)
                ;; figure out type size
                (cond ((= allocate-mem? 1)
                       (emit "%dat_" (symbol->string (car a)) " = call i8* @malloc("
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ")\n" os))
                      ((and (= allocate-mem? 2) (not *WINDOWS_ALLOC_BUG*))
                       (emit "%dat_" (symbol->string (car a)) " = alloca i8, "
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ", align 16\n" os))
                      (else
                       (emit "%dat_" (symbol->string (car a)) " = call i8* @llvm_zone_malloc("
                             "%mzone* " (car (impc:ir:gname "zone")) ", "
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ")\n" os)))
                (emit "%" (symbol->string (car a)) "Ptr = bitcast i8* %dat_" (symbol->string (car a)) " to " (impc:ir:get-type-str (cdr a)) "*\n" os))
              (emit  "%" (symbol->string (car a)) "Ptr = alloca " (impc:ir:get-type-str (cdr a)) "\n" os))
          (emit (string-append "store " (impc:ir:get-type-str (cdr a)) " %" (symbol->string (car a))
                               ", " (impc:ir:get-type-str (cdr a)) "* %" (symbol->string (car a)) "Ptr\n") os)))
      (emit "\n" os)
      ;; compile body
      ;; (println '_compin: *impc:ir:sym-name-stack*)
      (set! *impc:ir:ls_var* (cons (list) *impc:ir:ls_var*))
      (define body-str (impc:ir:compiler code types))
      (define result (impc:ir:gname))
      ;(println '*impc:ir:ls_var* *impc:ir:ls_var*)
      (if (not (null? (car *impc:ir:ls_var*)))
          (begin (emit "; promote local stack var allocations\n" os)
                 (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
                       (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
                       os)
                 (map (lambda (v)
                        (if *WINDOWS_ALLOC_BUG*
                            (begin
                              (emit (impc:ir:gname "lspvar" "i8*") " = call i8* @llvm_zone_malloc("
                                    "%mzone* " (car (impc:ir:gname "zone")) ", "
                                    *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr v))) ")\n" os)
                                   (emit (car v) " = bitcast " (cadr (impc:ir:gname "lspvar")) " " (car (impc:ir:gname "lspvar")) " to " (impc:ir:get-type-str (cdr v)) "*\n" os))
                            (begin (emit (car v) " = alloca " (cdr v) "\n" os))))
                      (car *impc:ir:ls_var*))))
      (set! *impc:ir:ls_var* (cdr *impc:ir:ls_var*))
      (set! *impc:ir:sym-name-stack* (list-tail *impc:ir:sym-name-stack* (length args)))
      ;; (println 'compout: *impc:ir:sym-name-stack*)
      (emit "\n" os)
      (emit body-str os)
      ;; return whole static function signature (not just return of function sig)
      (impc:ir:gname "result" (car result) (cadr result))
      ;;(emit (impc:ir:compiler code types) os)
      ;;(emit  "ret " (impc:ir:get-type-str rettype) " " (car (impc:ir:gname)) "\n" os)
      (emit "}" os)
      (impc:ir:strip-space os))))


(define impc:ir:compile:make-static
  (lambda (ast types)
    ;;(println 'ast: ast)
    (let* ((os (make-string 0))
           (name (list-ref ast 2))
           (allocate-mem? (list-ref ast 1))
           (rettype (list-ref ast 3))
           (result '())
           (fulltype (cdr (assoc-strcmp (string->symbol name) types)))
           (env (list-ref ast 4))
           (args (list-ref ast 5))
           (mynewtype (string-append (impc:ir:get-type-str rettype) " (" (string-join (map (lambda (x) (impc:ir:get-type-str (cdr x))) args) ", ") ")*"))
           (code (list-ref ast 6)))
      ; (println 'making-static--------------------------------------> )
      ; (println 'name: name)
      ; (println 'allocate: allocate-mem?)
      ; (println 'fulltype: fulltype)
      ; (println 'rettype: rettype)
      ; (println 'env: env)
      ; (println 'args: args)
      ; (println 'code: code)
      ; (println 'mynewtype: mynewtype)
      ; (println 'newtype2 (impc:ir:pretty-print-type mynewtype))

      ;; first we make the function code
      ;; define fastcc function with return type
      (emit  "define dllexport ccc " (impc:ir:get-type-str rettype) " @" name "(" os)
      (if (not (null? args)) (emit (impc:ir:make-arglist-str args #t) os))
      ;; close off function opening
      (emit ") nounwind inlinehint {\n" os)
      (emit "entry:\n" os)

      ;; mem zone
      (emit (impc:ir:gname "zone" "%mzone*") " = call ccc %mzone* @llvm_peek_zone_stack()\n" os)
      (emit "%_impz = bitcast %mzone* " (car (impc:ir:gname "zone")) " to i8*\n" os)
      (emit "%_impzPtr = alloca i8*\n" os)
      (emit "store i8* %_impz, i8** %_impzPtr\n" os)

      ;; next we pull the function arguments
      (emit "\n; setup arguments\n" os)
      (dotimes (i (length args))
        (let* ((a (list-ref args i)))
          (set! *impc:ir:sym-name-stack* (cons (car a) *impc:ir:sym-name-stack*))
          (if (> allocate-mem? 0)
              (begin ;; (println 'yes: allocate-mem? 'mem: ast)
                ;; figure out type size
                (cond ((= allocate-mem? 1)
                       (emit "%dat_" (symbol->string (car a)) " = call i8* @malloc("
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ")\n" os))
                      ((and (= allocate-mem? 2) (not *WINDOWS_ALLOC_BUG*))
                       (emit "%dat_" (symbol->string (car a)) " = alloca i8, "
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ", align 16\n" os))
                      (else
                       (emit "%dat_" (symbol->string (car a)) " = call i8* @llvm_zone_malloc("
                             "%mzone* " (car (impc:ir:gname "zone")) ", "
                             *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr a))) ")\n" os)))
                (emit "%" (symbol->string (car a)) "Ptr = bitcast i8* %dat_" (symbol->string (car a)) " to " (impc:ir:get-type-str (cdr a)) "*\n" os))
              (emit  "%" (symbol->string (car a)) "Ptr = alloca " (impc:ir:get-type-str (cdr a)) "\n" os))
          (emit (string-append "store " (impc:ir:get-type-str (cdr a)) " %" (symbol->string (car a))
                               ", " (impc:ir:get-type-str (cdr a)) "* %" (symbol->string (car a)) "Ptr\n") os)))
      (emit "\n" os)
      ;; compile body
      ;; (println '_compin: *impc:ir:sym-name-stack*)
      (set! *impc:ir:ls_var* (cons (list) *impc:ir:ls_var*))
      (define body-str (impc:ir:compiler code types))
      (define result (impc:ir:gname))
                                        ;(println '*impc:ir:ls_var* *impc:ir:ls_var*)
      (if (not (null? (car *impc:ir:ls_var*)))
          (begin (emit "; promote local stack var allocations\n" os)
                 (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
                       (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
                       os)
                 (map (lambda (v)
                        (if *WINDOWS_ALLOC_BUG*
                            (begin
                              (emit (impc:ir:gname "lspvar" "i8*") " = call i8* @llvm_zone_malloc("
                                    "%mzone* " (car (impc:ir:gname "zone")) ", "
                                    *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr v))) ")\n" os)
                                   (emit (car v) " = bitcast " (cadr (impc:ir:gname "lspvar")) " " (car (impc:ir:gname "lspvar")) " to " (impc:ir:get-type-str (cdr v)) "*\n" os))
                            (begin (emit (car v) " = alloca " (cdr v) "\n" os))))
                      (car *impc:ir:ls_var*))))
      (set! *impc:ir:ls_var* (cdr *impc:ir:ls_var*))
      (set! *impc:ir:sym-name-stack* (list-tail *impc:ir:sym-name-stack* (length args)))
      ;; (println 'compout: *impc:ir:sym-name-stack*)
      (emit "\n" os)
      (emit body-str os)

      (impc:ir:gname "result" (impc:ir:get-type-str fulltype))  ;; (car result) (cadr result))
      ;;(emit (impc:ir:compiler code types) os)
      ;;(emit  "ret " (impc:ir:get-type-str rettype) " " (car (impc:ir:gname)) "\n" os)
      (emit "}" os)
      (impc:ir:strip-space os))))



(define impc:ir:compile:make-env
  (lambda (ast types)
    ;; (println 'ast: ast 'types types)
    (let* ((os (make-string 0))
           (lambda-envs '())
           (result '())
           (env-zone-tmp '())
           (res
            (map (lambda (p)
                   (set! *impc:ir:sym-name-stack* (cons (caar p) *impc:ir:sym-name-stack*))
                   ;;(println '__envin: *impc:ir:sym-name-stack*)
                   ;; (println 'p2: (cadr p))
                   (let* ((symstr (symbol->string (caar p)))
                          (symtype (cdr (assoc-strcmp (caar p) types)))
                          (value (impc:ir:compiler (cadr p) types symtype))
                          (typestr (cadr (impc:ir:gname)))
                          (e (impc:ir:gname)))
                     ;; (println 'symstr: symstr 'symtype: symtype)
                     ;; (println 'typestr: typestr)
                     (if (and (number? (cadr p)) ;; if numeric constant force to type of symbol
                              (impc:ir:number? (cdr (assoc-strcmp (caar p) types)))
                              (impc:ir:number? (impc:ir:get-type-from-str typestr)))
                         (set! typestr (impc:ir:get-type-str (cdr (assoc-strcmp (caar p) types)))))
                     ;; type check
                     ;; (println 'tt1: (impc:ir:get-type-from-str typestr) 'tt2: (cdr (assoc-strcmp (caar p) types)))
                     (if (not (equal? (impc:ir:get-type-from-str typestr) ;; check to see if the two types are equal?
                                      (cdr (assoc-strcmp (caar p) types))))
                         (impc:compiler:print-type-mismatch-error
                          (impc:ir:pretty-print-type typestr)
                          (impc:ir:pretty-print-type (cdr (assoc-strcmp (caar p) types)))
                          (caar p)))
                                        ;(println 'value: value 'typestr: typestr) ;'cadrp (cadr p))
                                        ;(emit (impc:ir:gname "zone" "%mzone*") " = call %mzone* @llvm_peek_zone_stack()\n" os)
                                        ;(emit "call ccc void @llvm_print_i32(i32 111)\n" os)
                     (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
                           (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
                           os)
                     (emit  "\n; let assign value to symbol " symstr "\n" os)
                     ;; (emit "call ccc void @llvm_print_i32(i32 222)\n" os)

                     (if (or (= (cadr ast) 3)
                             *WINDOWS_ALLOC_BUG*)
                         (begin
                                        ;(emit "call ccc void @llvm_print_i32(i32 2222)\n" os)
                           (emit "%dat_" symstr " = call i8* @llvm_zone_malloc("
                                 "%mzone* " (car (impc:ir:gname "zone")) ", "
                                 *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cadr e))) ")\n" os)
                                        ;(emit "call ccc void @llvm_print_i32(i32 22222)\n" os)

                           (emit "%" symstr "Ptr = bitcast i8* %dat_" symstr " to " typestr "*\n" os))
                         (begin

                                        ;(emit "%dat_" symstr " = call i8* @win_alloc(i64 "
                                        ;      (number->string (impc:ir:get-type-size (impc:ir:get-type-from-str (cadr e)))) ")\n" os)
                                        ;(emit "%" symstr "Ptr = bitcast i8* %dat_" symstr "Ptr to " typestr "*\n" os)
                                        ; (println 'typestr: typestr)
                           (emit "%" symstr "Ptr = alloca " typestr "\n" os)
                           ))

                                        ;(emit "call ccc void @llvm_print_i32(i32 333)\n" os)
                     ;; (if (pair? value)
                     ;;    (emit (car value) os)
                     ;;    (emit value os))
                     (list symstr typestr value e)))
                 (caddr ast))))
                                        ;(emit "call ccc void @llvm_print_i32(i32 444)\n" os)
      ;; (println '____________A> ast)
      (map (lambda (p r)
             (let ((symstr (car r))
                   (typestr (cadr r))
                   (value (caddr r))
                   (e (cadddr r)))
               (if (pair? value)
                   (emit (car value) os)
                   (emit value os))

               ;; this bitcast should be the same type on both sides
               (emit "\n; let value assignment\n" os)
                                        ; (emit "call ccc void @llvm_print_i32(i32 555)\n" os)

               (emit (string-append "%" symstr " = select i1 true, " typestr " "
                                    (if (and (number? (cadr p))
                                             (= *impc:ir:fp32* (impc:ir:get-type-from-str typestr)))
                                        (llvm:convert-float (car e)) ;(impc:ir:gname)))
                                        (car e)) ;(impc:ir:gname)))
                                    ", " typestr " "
                                    (if (and (number? (cadr p))
                                             (= *impc:ir:fp32* (impc:ir:get-type-from-str typestr)))
                                        (llvm:convert-float (car e)) ; (impc:ir:gname)))
                                        (car e)) ;(impc:ir:gname)))
                                    "\n") os)
               (emit (string-append "store " typestr " %" symstr ", "
                                    typestr "* %" symstr "Ptr\n\n") os)
               (if (pair? value)
                   (set! lambda-envs (cons (cdr value) lambda-envs)))))
           (caddr ast) res)

      ;; fill in and lambda environments now
      (map (lambda (a)
             (emit a os))
           lambda-envs)
                                        ; (emit "call ccc void @llvm_print_i32(i32 999)\n" os)
      ;; (println '____________B> ast)
      ;; compile body
      (set! *impc:ir:ls_var* (cons (list) *impc:ir:ls_var*))
      (define envbody-str (impc:ir:compiler (cdddr ast) types))
      (define result (impc:ir:gname))
                                        ;(println '*impc:ir:ls_var* *impc:ir:ls_var*)
      (if (not (null? (car *impc:ir:ls_var*)))
          (begin (emit "; promote local stack var allocations\n" os)
                 (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
                       (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
                       os)
                 (map (lambda (v)
                        (if *WINDOWS_ALLOC_BUG*
                            (begin
                              (emit (impc:ir:gname "lspvar" "i8*") " = call i8* @llvm_zone_malloc("
                                    "%mzone* " (car (impc:ir:gname "zone")) ", "
                                    *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size (cdr v))) ")\n" os)
                              (emit (car v) " = bitcast " (cadr (impc:ir:gname "lspvar")) " " (car (impc:ir:gname "lspvar")) " to " (impc:ir:get-type-str (cdr v)) "*\n" os))
                            (begin (emit (car v) " = alloca " (cdr v) "\n" os))))
                      (car *impc:ir:ls_var*))))
      (set! *impc:ir:ls_var* (cdr *impc:ir:ls_var*))
      (set! *impc:ir:sym-name-stack* (list-tail *impc:ir:sym-name-stack* (length (caddr ast))))
      ;; (println '_envout: ast) ;;*impc:ir:sym-name-stack*)
      (emit envbody-str os)
      (impc:ir:gname "result" (car result) (cadr result))
      ;;(emit (impc:ir:compiler (cdddr ast) types) os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:closure-from-getter
  (lambda (name)
    (if (not (impc:ti:closure-exists? name))
        (impc:compiler:print-missing-identifier-error name 'closure)
        (let* ((os (make-string 0))
               (type (cons (+ *impc:ir:pointer* *impc:ir:pointer* *impc:ir:closure*)
                           (map (lambda (x) (impc:ir:get-type-from-str x))
                                (impc:ti:get-closure-arg-types name)))))
          (emit  (impc:ir:gname "closure" "i8*") " = call i8* @" name "_getter()\n" os)
          (emit (string-append (impc:ir:gname "closure" (impc:ir:get-type-str type)) " = bitcast i8* "
                               (car (impc:ir:gname 1)) " to " (impc:ir:get-type-str type) "\n") os)
          (impc:ir:strip-space os)))))


(define impc:ir:compiler:closure-ref
  (lambda (ast types)
    ;; arg 1 must be a closure
    ;; arg 2 must be a string
    ;; arg 3 must be a string
    (let* ((os (make-string 0))
                                        ;(closure-str (impc:ir:compiler (cadr ast) types))
           (closure-str (if (and (symbol? (cadr ast))
                                 (impc:ti:closure-exists? (symbol->string (cadr ast))))
                            (impc:ir:compiler:closure-from-getter (symbol->string (cadr ast)))
                            (impc:ir:compiler (cadr ast) types)))
           (closure (impc:ir:gname))
           ;; (name-str (impc:ir:compiler (caddr ast) types))
           ;; (name (impc:ir:gname))
           (type-str (impc:ir:compiler (cadddr ast) types))
           (type (impc:ir:gname)))
      (emit "\n; closure ref \n" os)
      (emit closure-str os)
      ;; (emit name-str os)
      (emit type-str os)
      (emit (string-append (impc:ir:gname "tablePtr" (cadr closure)) " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 0\n") os)
      (emit (string-append (impc:ir:gname "tmp" "%clsvar**") " = bitcast i8** "
                           (car (impc:ir:gname 1)) " to %clsvar**\n") os)
      (emit (string-append (impc:ir:gname "table" "%clsvar*")
                           " = load %clsvar*, %clsvar** " (car (impc:ir:gname 1)) "\n") os)
      (emit (string-append (impc:ir:gname "ePtr" "i8**") " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 1\n") os)
      (define ePtr (impc:ir:gname))
      (emit (string-append (impc:ir:gname "e" "i8*")
                           " = load i8*, i8** " (car (impc:ir:gname "ePtr")) "\n") os)
      (define e (impc:ir:gname))
      (emit (string-append (impc:ir:gname "offset" "i32")
                           " = call i32 @get_address_offset(i64 "
                           (string-hash (caddr ast)) ", %clsvar* " (car (impc:ir:gname "table")) ")\n") os)
      (define offset (impc:ir:gname))
      (emit (string-append (impc:ir:gname "valPtr" "i8*") " = getelementptr "
                           (impc:ir:pointer-- (cadr e)) ", "
                           (cadr e) " " (car e) ", i32 " (car offset) "\n") os)
      (emit  (impc:ir:gname "val" "i8**") " = bitcast i8* " (car (impc:ir:gname 1)) " to i8**\n" os)
      (emit  (impc:ir:gname "val" "i8*") " = load i8*, i8** " (car (impc:ir:gname 1)) "\n" os)
      (emit (string-append (impc:ir:gname "val" (string-append (cadddr ast) "*")) " = bitcast i8* " (car (impc:ir:gname 1)) " to "
                           (string-append (cadddr ast) "*\n")) os)
      (emit  (impc:ir:gname "val" (cadddr ast)) " = load " (cadddr ast) ", " (cadddr ast) "* " (car (impc:ir:gname 1)) "\n" os)
      (impc:ir:strip-space os))))

(define impc:ir:compiler:closure-set
  (lambda (ast types)
    ;; arg 1 must be a closure
    ;; arg 2 must be a string
    ;; arg 3 must be a string
    ;; arg 4 must be of type!
    (let* ((os (make-string 0))
           (closure-str (if (and (symbol? (cadr ast))
                                 (impc:ti:closure-exists? (symbol->string (cadr ast))))
                            (impc:ir:compiler:closure-from-getter (symbol->string (cadr ast)))
                            (impc:ir:compiler (cadr ast) types)))
           (closure (impc:ir:gname))
           ;; (name-str (impc:ir:compiler (caddr ast) types))
           ;; (name (impc:ir:gname))
           (type-str (impc:ir:compiler (cadddr ast) types))
           (type (impc:ir:gname))
           (val-str (impc:ir:compiler (car (cddddr ast)) types (impc:ir:get-type-from-str (cadddr ast))))
           (val (impc:ir:gname)))
      (emit "\n; closure set! \n" os)
      (emit closure-str os)
      ;; (emit name-str os)
      (emit type-str os)
      (emit val-str os)

      (emit (impc:ir:gname "tablePtr" (cadr closure)) " = getelementptr "
            (impc:ir:pointer-- (cadr closure)) ", "
            (cadr closure) " " (car closure) ", i32 0, i32 0\n" os)
      (emit (impc:ir:gname "tmp" "%clsvar**") " = bitcast i8** "
            (car (impc:ir:gname 1)) " to %clsvar**\n" os)
      (emit (impc:ir:gname "table" "%clsvar*")
            " = load %clsvar*, %clsvar** " (car (impc:ir:gname 1)) "\n" os)
      (emit (impc:ir:gname "ePtr" "i8**") " = getelementptr " (cadr closure) " "
            (impc:ir:pointer-- (cadr closure)) ", "
            (car closure) ", i32 0, i32 1\n" os)
      (define ePtr (impc:ir:gname))
      (emit (string-append (impc:ir:gname "e" "i8*")
                           " = load i8*, i8** " (car (impc:ir:gname "ePtr")) "\n") os)
      (define e (impc:ir:gname))
      (emit (string-append (impc:ir:gname "offset" "i32")
                           " = call i32 @get_address_offset(i64 "
                           (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ")\n") os)
      (define offset (impc:ir:gname))
      (emit (string-append (impc:ir:gname "valPtr" "i8*") " = getelementptr "
                           (impc:ir:pointer-- (cadr e)) ", "
                           (cadr e) " " (car e) ", i32 " (car offset) "\n") os)
      (emit  (impc:ir:gname "val" "i8**") " = bitcast i8* " (car (impc:ir:gname 1)) " to i8**\n" os)
      (emit  (impc:ir:gname "val" "i8*") " = load i8*, i8** " (car (impc:ir:gname 1)) "\n" os)
      (emit (string-append (impc:ir:gname "val" (string-append (cadddr ast) "*")) " = bitcast i8* " (car (impc:ir:gname 1)) " to "
                           (string-append (cadddr ast) "*\n")) os)
      (emit  "store " (cadr val) " " (car val) ", " (cadr (impc:ir:gname)) " " (car (impc:ir:gname)) "\n" os)
      (emit  (impc:ir:gname "result" (cadr val)) " = load " (impc:ir:pointer-- (cadr (impc:ir:gname 1))) ", " (cadr (impc:ir:gname 1)) " " (car (impc:ir:gname 1)) "\n" os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:closure-ref
  (lambda (ast types . hint?)
    ;; arg 1 must be a closure
    ;; arg 2 must be a string
    ;; arg 3 MAY be a type string or NULL
    (let* ((os (make-string 0))
           (num (number->string (llvm:count++)))
           (closure-str (if (and (symbol? (cadr ast))
                                 (impc:ti:closure-exists? (symbol->string (cadr ast))))
                            (impc:ir:compiler:closure-from-getter (symbol->string (cadr ast)))
                            (impc:ir:compiler (cadr ast) types)))
           (closure (impc:ir:gname))
           (type-str (impc:ir:compiler (if (null? (cadddr ast))
                                           (if (null? hint?)
                                               (log-error 'Compiler 'Error: 'could 'not 'discern 'ref 'type 'for
                                                            (string-append (symbol->string (cadr ast)) "." (caddr ast))
                                                            'please 'provide 'explicit 'type 'i.e. '(f.name:<type>))
                                               (impc:ir:get-type-str (car hint?)))
                                           (cadddr ast))
                                       types))
           (type (impc:ir:gname))
           ;; (name-str (impc:ir:compiler (caddr ast) types))
           ;; (name (impc:ir:gname))
           (valtype (if (null? (cadddr ast)) (impc:ir:get-type-str (car hint?)) (cadddr ast))))
      (emit "\n; closure ref \n" os)
      ;; (emit "call ccc void @llvm_print_i32(i32 123)\n" os)
      (emit closure-str os)
      ;; (emit name-str os)
      (emit type-str os)

      ;; first deref closure
      (emit (impc:ir:gname "closure" (impc:ir:get-type-str (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr closure)))))
            " = load " (impc:ir:pointer-- (cadr closure)) ", " (cadr closure) " " (car closure) "\n" os)
      (set! closure (impc:ir:gname "closure"))

      ;; get address table
      (emit (string-append (impc:ir:gname "tablePtr" (cadr closure)) " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 0\n") os)
      (emit (string-append (impc:ir:gname "tmp" "%clsvar**") " = bitcast i8** "
                           (car (impc:ir:gname 1)) " to %clsvar**\n") os)
      (emit (string-append (impc:ir:gname "table" "%clsvar*")
                           " = load %clsvar*, %clsvar** " (car (impc:ir:gname 1)) "\n") os)
      (emit (string-append (impc:ir:gname "ePtr" "i8**") " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 1\n") os)

      ;; get closure environment
      (define ePtr (impc:ir:gname))
      (emit (impc:ir:gname "e" "i8*") " = load i8*, i8** " (car (impc:ir:gname "ePtr")) "\n" os)
      (define e (impc:ir:gname))
      (emit (impc:ir:gname "offset" "i32") " = call i32 @get_address_offset(i64 "
            (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ")\n" os)
      (define offset (impc:ir:gname))

      (emit (impc:ir:gname "valPtr" "i8*") " = getelementptr "
            (impc:ir:pointer-- (cadr e)) ", "
            (cadr e) " " (car e) ", i32 " (car offset) "\n" os)
      (emit  (impc:ir:gname "val" "i8**") " = bitcast i8* " (car (impc:ir:gname 1)) " to i8**\n" os)
      (emit  (impc:ir:gname "val" "i8*") " = load i8*, i8** " (car (impc:ir:gname 1)) "\n" os)
      ;; (emit "call ccc void @llvm_print_pointer(i8* " (car (impc:ir:gname)) ")\n" os)
      (emit (impc:ir:gname "val" (string-append valtype "*")) " = bitcast i8* " (car (impc:ir:gname 1)) " to "
            (string-append valtype "*\n") os)


      ;; type check
      (emit (impc:ir:gname "check" "i1") " = call i1 @check_address_type(i64 " (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ", i8* " (car type) ")\n" os)
      (emit  "br i1 " (car (impc:ir:gname "check")) ", label %then" num ", label %else" num "\n" os)

      ;; do then
      (emit "\nthen" num ":\n" os)
      (emit  (impc:ir:gname "then_result" valtype) " = load " (impc:ir:pointer-- (cadr (impc:ir:gname "val"))) ", " (cadr (impc:ir:gname "val")) " " (car (impc:ir:gname "val")) "\n" os)
      (emit  "br label %cont" num "\n" os)

      ;; do else
      (emit "\nelse" num ":\n" os)
      (emit  (impc:ir:gname "else_result" valtype) " = load " (impc:ir:pointer-- (cadr (impc:ir:gname "val"))) ", " (cadr (impc:ir:gname "val")) " " (car (impc:ir:gname "val")) "\n" os)
      (emit "br label %cont" num "\n" os)

      ;; continue
      (emit "\ncont" num ":\n" os)
                                        ;(impc:ir:gname "val" (car val) (cadr val))
      (emit (impc:ir:gname "result" valtype) " = phi " valtype
            " [ " (car (impc:ir:gname "then_result")) ", %then" num " ], "
            " [ " (car (impc:ir:gname "else_result")) ", %else" num " ]\n" os)
      ;;(emit "call ccc void @llvm_print_i32(i32 1234567)\n" os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:closure-set
  (lambda (ast types)
    ;; arg 1 must be a closure
    ;; arg 2 must be a string
    ;; arg 3 must be a value
    ;; arg 4 MAY be a type string or NULL
    (let* ((os (make-string 0))
           (num (number->string (llvm:count++)))
           (closure-str (if (and (symbol? (cadr ast))
                                 (impc:ti:closure-exists? (symbol->string (cadr ast))))
                            (impc:ir:compiler:closure-from-getter (symbol->string (cadr ast)))
                            (impc:ir:compiler (cadr ast) types)))
           (closure (impc:ir:gname))
           ;; (name-str (impc:ir:compiler (caddr ast) types))
           ;; (name (impc:ir:gname))
           (val-str (if (null? (car (cddddr ast)))
                        (impc:ir:compiler (cadddr ast) types)
                        (impc:ir:compiler (cadddr ast) types
                                          (impc:ir:get-type-from-str (car (cddddr ast))))))
           (val (impc:ir:gname))
           (type-str (impc:ir:compiler (if (null? (car (cddddr ast)))
                                           (cadr val)
                                           (car (cddddr ast)))
                                       types))
           (type (impc:ir:gname)))
      (emit "\n; closure set! \n" os)
      (emit closure-str os)
      ;; (emit name-str os)
      (emit type-str os)
      (emit val-str os)

      ;; first deref closure
      (emit (impc:ir:gname "closure" (impc:ir:get-type-str (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr closure)))))
            " = load " (impc:ir:pointer-- (cadr closure)) ", " (cadr closure) " " (car closure) "\n" os)
      (set! closure (impc:ir:gname "closure"))


      ;; get address table
      (emit (string-append (impc:ir:gname "tablePtr" (cadr closure)) " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 0\n") os)
      (emit (string-append (impc:ir:gname "tmp" "%clsvar**") " = bitcast i8** "
                           (car (impc:ir:gname 1)) " to %clsvar**\n") os)
      (emit (string-append (impc:ir:gname "table" "%clsvar*")
                           " = load %clsvar*, %clsvar** " (car (impc:ir:gname 1)) "\n") os)
      (emit (string-append (impc:ir:gname "ePtr" "i8**") " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 1\n") os)

      ;; get closure environment
      (define ePtr (impc:ir:gname))
      (emit (impc:ir:gname "e" "i8*") " = load i8*, i8** " (car (impc:ir:gname "ePtr")) "\n" os)
      (define e (impc:ir:gname))
      (emit (impc:ir:gname "offset" "i32") " = call i32 @get_address_offset(i64 "
            (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ")\n" os)
      (define offset (impc:ir:gname))


      (emit (impc:ir:gname "valPtr" "i8*") " = getelementptr "
            (impc:ir:pointer-- (cadr e)) ", "
            (cadr e) " " (car e) ", i32 " (car offset) "\n" os)
      (emit  (impc:ir:gname "val" "i8**") " = bitcast i8* " (car (impc:ir:gname 1)) " to i8**\n" os)
      (emit  (impc:ir:gname "val" "i8*") " = load i8*, i8** " (car (impc:ir:gname 1)) "\n" os)
      (emit (impc:ir:gname "val" (string-append (cadr val) "*")) " = bitcast i8* " (car (impc:ir:gname 1)) " to "
            (string-append (cadr val) "*\n") os)

      ;; type check
      (emit (impc:ir:gname "check" "i1") " = call i1 @check_address_type(i64 " (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ", i8* " (car type) ")\n" os)
      (emit  "br i1 " (car (impc:ir:gname "check")) ", label %then" num ", label %else" num "\n" os)

      ;; do then
      (emit "\nthen" num ":\n" os)
      (emit  "store " (cadr val) " " (car val) ", " (cadr (impc:ir:gname "val")) " " (car (impc:ir:gname "val")) "\n" os)
      (emit  "br label %cont" num "\n" os)

      ;; do else
      (emit "\nelse" num ":\n" os)
      (emit "br label %cont" num "\n" os)

      ;; continue
      (emit "\ncont" num ":\n" os)
      (impc:ir:gname "val" (car val) (cadr val))

                                        ;(emit (impc:ir:gname "result" (cadr (impc:ir:gname "then_result"))) " = phi "
                                        ;      (cadr (impc:ir:gname "then_result"))
                                        ;      " [ " (car (impc:ir:gname "then_result")) ", %then" num " ], "
                                        ;      " [ " (car (impc:ir:gname "else_result")) ", %else" num " ]\n" os)

      (impc:ir:strip-space os))))

(define impc:ir:compiler:closure-refcheck
  (lambda (ast types . hint?)
    (let* ((os (make-string 0))
           (num (number->string (llvm:count++)))
           ;; (name-str (impc:ir:compiler (caddr ast) types))
           ;; (name (impc:ir:gname))
           (closure-str (if (and (symbol? (cadr ast))
                                 (impc:ti:closure-exists? (symbol->string (cadr ast))))
                            (impc:ir:compiler:closure-from-getter (symbol->string (cadr ast)))
                            (impc:ir:compiler (cadr ast) types)))
           (closure (impc:ir:gname)))
      (emit "\n; closure ref check \n" os)
      (emit closure-str os)
      ;; (emit name-str os)

      ;; first deref closure
      (emit (impc:ir:gname "closure" (impc:ir:get-type-str (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr closure)))))
            " = load " (impc:ir:pointer-- (cadr closure)) ", " (cadr closure) " " (car closure) "\n" os)
      (set! closure (impc:ir:gname "closure"))

      ;; get address table
      (emit (string-append (impc:ir:gname "tablePtr" (cadr closure)) " = getelementptr "
                           (impc:ir:pointer-- (cadr closure)) ", "
                           (cadr closure) " " (car closure) ", i32 0, i32 0\n") os)
      (emit (string-append (impc:ir:gname "tmp" "%clsvar**") " = bitcast i8** "
                           (car (impc:ir:gname 1)) " to %clsvar**\n") os)
      (emit (string-append (impc:ir:gname "table" "%clsvar*")
                           " = load %clsvar*, %clsvar** " (car (impc:ir:gname 1)) "\n") os)
      (emit (impc:ir:gname "val" "i1") " = call i1 @check_address_exists(i64 "
            (number->string (string-hash (caddr ast))) ", %clsvar* " (car (impc:ir:gname "table")) ")\n" os)

      (impc:ir:strip-space os))))



;; returns a ptr's value
(define impc:ir:compiler:pdref
  (lambda (ast types)
    (let* ((os (make-string 0))
           (val-str (impc:ir:compiler (cadr ast) types))
           (val (impc:ir:gname))
           (type (- (impc:ir:get-type-from-str (cadr val)) *impc:ir:pointer*)))
      (if (not (impc:ir:pointer? val))
          (impc:compiler:print-bad-type-error-with-ast val "ptrdef must take a pointer argument" ast))
      (emit val-str os)
      (emit (impc:ir:gname "val" (impc:ir:get-type-str type)) " = load " (impc:ir:pointer-- (cadr val)) ", " (cadr val) " " (car val) "\n" os)
      (impc:ir:strip-space os))))


;; returns a ptr to ptr
(define impc:ir:compiler:pref
  (lambda (ast types)
    (let* ((os (make-string 0))
           (val-str (impc:ir:compiler (cadr ast) types))
           (val (impc:ir:gname)))
      (emit val-str os)
      (if *WINDOWS_ALLOC_BUG*
          (begin
            (emit (impc:ir:gname "dat" "i8*") " = call i8* @llvm_zone_malloc(%mzone* " (car (impc:ir:gname "zone")) ", i64 "
                  *impc:ir:pointer_size_bytes_str* ")\n" os)
            (emit (impc:ir:gname "val" (string-append (cadr val) "*"))
                  " = bitcast i8* " (car (impc:ir:gname "dat"))
                  " to " (cadr val) "*\n" os))
          (begin
            (emit (impc:ir:gname "val" (string-append (cadr val) "*"))
                  " = alloca " (cadr val) "\n" os)))
      (emit "store " (cadr val) " " (car val) ", " (cadr val) "* " (car (impc:ir:gname)))
      (impc:ir:strip-space os))))

;; (impc:ir:gcnt [increment])
;; (impc:ir:gcnt) ;; get current cnt
;; (impc:ir:gcnt 2) ;; increment current cnt by 2
(define impc:ir:gcnt
  (let ((cnt 0))
    (lambda args
      (if (not (null? args))
          (set! cnt (+ (car args) cnt)))
      cnt)))

;; impc:ir:gname
;; usage:
;; (gname [previous name]) ;; find distance to this
;; (gname "fred" type) ;; set current name
;; (gname "fred" "%fredxxx" type) ;; set current
;; (gname) ;; get current name
;; (gname 2) ;; get name 2 previous
;; (gname -2) ;; revert to name 2 previous
(define impc:ir:gname
  (lambda args
    (if (null? args)
        (list (impc:ir:getname "current")
              (impc:ir:gettype "current"))
        (if (> (length args) 1)
            (if (> (length args) 2)
                (impc:ir:addtodict (car args) (cadr args) (caddr args))
                (let ((str (if (or (number? (string->atom (car args)))
                                   (regex:match? (car args) "^0x"))
                               (car args)
                               (if (regex:match? (car args) "^@")
                                   (car args)
                                   (string-append "%" (car args)
                                                  (number->string (llvm:count++)))))))
                  (impc:ir:addtodict (car args) str (cadr args))
                  str))
            (if (number? (car args))
                (if (<> (abs (car args)) 1)
                    (log-error "Only allowed 1 or -1 in impc:ir:gname")
                    (if (< (car args) 0)
                        (begin (impc:ir:addtodict "current"
                                                  (impc:ir:getname "previous")
                                                  (impc:ir:getname "previous"))
                               (list (impc:ir:getname "current")
                                     (impc:ir:gettype "current")))
                        (list (impc:ir:getname "previous")
                              (impc:ir:gettype "previous"))))
                (if (impc:ir:getname (car args))
                    (begin (list (impc:ir:getname (car args))
                                 (impc:ir:gettype (car args))))
                    (log-error "Could not locate name " (car args) "in impc:ir:gname")))))))


(define impc:ir:compile:eval-var
  (lambda (var t)
    (let* ((os (make-string 0)))
      (let ((typestr (impc:ir:get-type-str t)))
        (emit (impc:ir:gname "val" typestr)
              " = load " typestr ", " typestr
              "* %" (symbol->string var) "Ptr\n" os)
        (impc:ir:strip-space os)))))


(define impc:ir:compile:eval-gvar
  (lambda (var)
    (let* ((os (make-string 0))
           (type (impc:ti:get-globalvar-type (symbol->string var)))
           (type2 (impc:ir:pointer-- type))
           (typestr (impc:ir:get-type-str type2)))
      (if (and (or (impc:ir:array? type2)
                   (impc:ir:vector? type2)
                   (impc:ir:tuple? type2))
               (= (impc:ir:get-ptr-depth type2) 0))
          (emit (impc:ir:gname "val" (impc:ir:get-type-str type))
                " = select i1 true, "
                (impc:ir:get-type-str type) " @" (symbol->string var) ", "
                (impc:ir:get-type-str type) " @" (symbol->string var) "\n" os)
          (emit (string-append (impc:ir:gname "val" typestr)
                               " = load " typestr ", " typestr
                               "* @" (symbol->string var) "\n") os))
      (impc:ir:strip-space os))))


(define impc:ir:compile:push_new_zone
  (lambda (ast types)
    (let* ((os (make-string 0))
           (size-str (impc:ir:compiler (cadr ast) types))
           (size (impc:ir:gname)))
      ;;(println 'size: size)
      (if (<> (impc:ir:get-type-from-str (cadr size)) *impc:ir:si64*)
          (impc:compiler:print-needs-zone-size-error 'push_new_zone))

      (emit size-str os) ;; write size str

      (emit (impc:ir:gname "zone" "%mzone*")
            " = call %mzone* @llvm_zone_create(i64 " (car size) ")\n" os)
      (emit "call void @llvm_push_zone_stack(%mzone* " (car (impc:ir:gname)) ")\n" os)
      (emit (impc:ir:gname "zone_ptr" "i8*") " = bitcast %mzone* " (car (impc:ir:gname "zone")) " to i8*\n" os)
      (emit "store i8* " (car (impc:ir:gname "zone_ptr")) ", i8** %_impzPtr\n" os)

      (let ((zone (impc:ir:gname "zone")))
        (impc:ir:gname "ret" (car zone) (cadr zone)))
      (impc:ir:strip-space os))))

(define impc:ir:compile:push_zone
  (lambda (ast types)
    (let* ((os (make-string 0))
           (zone-str (impc:ir:compiler (cadr ast) types))
           (zone (impc:ir:gname)))
      (emit zone-str os)
      (emit "call void @llvm_push_zone_stack(%mzone* " (car zone) ")\n" os)
      (emit (impc:ir:gname "zone_ptr" "i8*") " = bitcast %mzone* " (car zone) " to i8*\n" os)
      (emit "store i8* " (car (impc:ir:gname "zone_ptr")) ", i8** %_impzPtr\n" os)
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      (impc:ir:strip-space os))))

(define impc:ir:compile:create_zone
  (lambda (ast types)
    (let* ((os (make-string 0))
           (size-str (impc:ir:compiler (cadr ast) types))
           (size (impc:ir:gname)))
      ;;(println 'size: size)
      (if (<> (impc:ir:get-type-from-str (cadr size)) *impc:ir:si64*)
          (impc:compiler:print-needs-zone-size-error 'create_zone))
      (emit size-str os) ;; write size str
      (emit (impc:ir:gname "ret" "%mzone*")
            " = call %mzone* @llvm_zone_create(i64 " (car size) ")\n" os)
      (impc:ir:strip-space os))))

(define impc:ir:compile:pop_zone
  (lambda (ast types)
    (let* ((os (make-string 0)))
      (emit (impc:ir:gname "oldzone" "%mzone*") " = call %mzone* @llvm_pop_zone_stack()\n" os)
      (emit (impc:ir:gname "newzone" "%mzone") " = call %mzone* @llvm_peek_zone_stack()\n" os)
      (emit (impc:ir:gname "zone_ptr" "i8*") " = bitcast %mzone* " (car (impc:ir:gname "newzone")) " to i8*\n" os)
      (emit "store i8* " (car (impc:ir:gname "zone_ptr")) ", i8** %_impzPtr\n" os)
      (let ((zone (impc:ir:gname "oldzone")))
        (impc:ir:gname "ret" (car zone) (cadr zone)))
      (impc:ir:strip-space os))))

(define impc:ir:compile:apply-closure
  (lambda (ast types ftype-provided? . args)
    ;; (println 'apply-closure ast 'ts: types 'symstack: *impc:ir:sym-name-stack*)
    ;; (if ftype-provided? (println 'ftype: (car args)))
    (let* ((functiontype (if ftype-provided?
                             (cdr (impc:ir:get-type-from-str (cadar (car args))))
                             (if (and (assoc-strcmp (car ast) types)
                                      (impc:ir:closure? (cdr (assoc-strcmp (car ast) types)))
                                      (= 2 (impc:ir:get-ptr-depth (cdr (assoc-strcmp (car ast) types)))))
                                 (cddr (assoc-strcmp (car ast) types))
                                 (if (impc:ir:closure? (cdr (assoc-strcmp (car ast) types)))
                                     (impc:compiler:print-bad-type-error (car ast) "remember that closures must be pointers")
                                     (impc:compiler:print-bad-type-error (car ast) "bad type for closure")))))
           ;;(recursive-call (if (eq? (car ast) (car *impc:ir:sym-name-stack*)) #t #f))
           (recursive-call (if (member (car ast) *impc:ir:sym-name-stack*) #t #f))
           (os (make-string 0))
           (ftype (impc:ir:make-function-str functiontype #t))
           (clstype (string-append "{i8*, i8*, " ftype "*}*"))
           (vars (map (lambda (arg hint)
                        (emit (impc:ir:compiler arg types hint) os)
                        (impc:ir:gname))
                      (cdr ast)
                      (cdr functiontype))))
      ;; (println 'recursive-call! recursive-call (car *impc:ir:sym-name-stack*) (car ast))
      (emit "\n; apply closure \n" os)
      (define v '())
      (if ftype-provided?
          (begin (emit (impc:ir:gname "val" clstype)
                       " = load " clstype "," clstype "* " (caar (car args)) "\n" os)
                 (set! v (car (impc:ir:gname "val"))))
          (begin (emit (impc:ir:gname "vval" (string-append clstype "*"))
                       " = load " clstype "*, " clstype "** %"
                       (symbol->string (car ast)) "Ptr\n" os)
                 (emit (impc:ir:gname "val" clstype)
                       " = load " clstype "," clstype "* " (car (impc:ir:gname 1)) "\n" os)
                 (set! v (car (impc:ir:gname "val")))))
      (emit (string-append (impc:ir:gname "fPtr" clstype)
                           " = getelementptr " (impc:ir:pointer-- clstype) ", " clstype " " v ", i32 0, i32 2\n") os)
      (emit (string-append (impc:ir:gname "ePtr" clstype) " = getelementptr "
                           (impc:ir:pointer-- clstype) ", " clstype " " v ", i32 0, i32 1\n") os)
      (emit (string-append (impc:ir:gname "f" (string-append ftype "*"))
                           " = load " ftype "*, " ftype "** " (car (impc:ir:gname "fPtr")) "\n") os)
      (emit (string-append (impc:ir:gname "e" "i8*")
                           " = load i8*, i8** " (car (impc:ir:gname "ePtr")) "\n") os)

      (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
            (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
            os)
                                        ;(emit (impc:ir:gname "zone" "%mzone*") " = call %mzone* @llvm_peek_zone_stack()\n" os)
      (emit  (impc:ir:gname "z" "i8*") " = bitcast %mzone* " (car (impc:ir:gname "zone")) " to i8*\n" os)
      (define zone (car (impc:ir:gname)))
      (emit (string-append (if (impc:ir:void? (car functiontype))
                               (begin (impc:ir:gname "result" "void") "")
                               (string-append (impc:ir:gname "result" (impc:ir:get-type-str (car functiontype))) " = "))
                           (if recursive-call "tail " "")
                           ;;"tail call fastcc "
                           "call fastcc "
                           (impc:ir:get-type-str (car functiontype)) " "
                           (car (impc:ir:gname "f")) "(i8* " zone ", i8* "
                           (car (impc:ir:gname "e"))
                           (apply string-append (map (lambda (var)
                                                       (string-append ", " (cadr var) " " (car var)))
                                                     vars))
                           ")\n") os)
      ;;(println 'os: os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:loop
  (lambda (ast types)
    (let* ((os (make-string 0))
           (loop-num (llvm:count++))
           (loop-label (string-append "loop" (number->string loop-num) ":"))
           (closeloop-label (string-append "closeloop" (number->string loop-num) ":"))
           (after-label (string-append "after" (number->string loop-num) ":"))
           (loop (string-append "%loop" (number->string loop-num)))
           (closeloop (string-append "%closeloop" (number->string loop-num)))
           (cmp (string-append "%cmp" (number->string loop-num)))
           (after (string-append "%after" (number->string  loop-num)))
           (iterator (string-append "%" (symbol->string (caar ast)))) ; "Loop" (number->string loop-num)))
           (iterator-type (impc:ir:get-type-str (cdr (assoc-strcmp (caar ast) types))))
           (numstr (impc:ir:compiler (cadar ast) types (cdr (assoc-strcmp (caar ast) types))))
           (num (impc:ir:gname)) ;(ir:eval (cadar ast) os stack sym-table))
           (bodystr (impc:ir:compiler (cdr ast) types)))
      (emit "; setup loop\n" os)
                                        ;(print num 'numstr numstr)
      (emit numstr os)
      (emit  iterator "Ptr = alloca " iterator-type "\n" os)
      (emit (string-append "store " iterator-type (if (impc:ir:fixed-point? (cadr num))
                                                      " 0, "
                                                      " 0.0, ")
                           iterator-type "* " iterator "Ptr\n") os)
      (emit  "br label " loop "\n" os)
      (emit  "\n" loop-label "\n" os)
      (emit bodystr os)
      (emit (string-append "%loop_cnt" (number->string loop-num)
                           " = load " iterator-type ", " iterator-type "* " iterator "Ptr\n") os)
      (emit (string-append "%next" (number->string loop-num)
                           (if (impc:ir:fixed-point? (cadr num))
                               " = add "
                               " = fadd ")
                           iterator-type " %loop_cnt" (number->string loop-num)
                           (if (impc:ir:fixed-point? (cadr num))
                               ", 1\n"
                               ", 1.0\n"))
            os)
      (emit (string-append "store " iterator-type " %next" (number->string loop-num)
                           ", " iterator-type "* " iterator "Ptr\n") os)
      (emit (string-append cmp " = "
                           (if (impc:ir:fixed-point? (cadr num))
                               "icmp ult "
                               "fcmp ult ")
                           (cadr num) " "
                           "%next" (number->string loop-num) ", " (car num) "\n") os)
      (emit  "br i1 " cmp ", label " loop ", label " after "\n" os)
      (emit  "\n" after-label "\n" os)
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      (impc:ir:strip-space os))))



(define impc:ir:compiler:loop
  (lambda (ast types)
    (let* ((os (make-string 0))
           (loop-num (llvm:count++))
           (loop-label (string-append "loop" (number->string loop-num) ":"))
           (closeloop-label (string-append "closeloop" (number->string loop-num) ":"))
           (after-label (string-append "after" (number->string loop-num) ":"))
           (loop (string-append "%loop" (number->string loop-num)))
           (closeloop (string-append "%closeloop" (number->string loop-num)))
           (cmp (string-append "%cmp" (number->string loop-num)))
           (after (string-append "%after" (number->string  loop-num)))
           (iterator (string-append "%" (symbol->string (caar ast)))) ; "Loop" (number->string loop-num)))
           (iterator-type (impc:ir:get-type-str (cdr (assoc-strcmp (caar ast) types))))
           (startstr (impc:ir:compiler (cadar ast) types (impc:ir:get-type-from-str iterator-type)))
           (start (impc:ir:gname))
           (start-value? (> (length (car ast)) 2))
           (numstr (impc:ir:compiler (if start-value?
                                         (caddar ast)
                                         (cadar ast))
                                     types
                                     (cdr (assoc-strcmp (caar ast) types))))
           (num (impc:ir:gname)) ;(ir:eval (cadar ast) os stack sym-table))
           (bodystr (impc:ir:compiler (cdr ast) types)))
      (emit "; setup loop\n" os)
                                        ;(print num 'numstr numstr)
      (emit numstr os)
      (if start-value? (emit startstr os))

      (if (not (equal? (cdr (assoc-strcmp (caar ast) types))
                       (impc:ir:get-type-from-str (cadr num))))

          ;; (log-error 'Compiler 'Error: 'type 'conflict 'in 'dotimes: iterator-type (cadr num) ': (car ast))
          (impc:compiler:print-type-mismatch-error iterator-type (cadr num) (car ast)))

      (if (and start-value?
               (not (equal? (cdr (assoc-strcmp (caar ast) types))
                            (impc:ir:get-type-from-str (cadr start)))))
          (impc:compiler:print-type-mismatch-error iterator-type (cadr num) (car ast)))

      (if start-value?
          (emit (string-append "store " (cadr start) " " (car start) ", "
                               iterator-type "* " iterator "Ptr\n") os)
          (emit (string-append "store " iterator-type (if (impc:ir:fixed-point? (cadr num))
                                                          " 0, "
                                                          " 0.0, ")
                               iterator-type "* " iterator "Ptr\n") os))

      (emit (impc:ir:gname "val" iterator-type)
            " = load " iterator-type ", " iterator-type "* " iterator "Ptr\n" os)

      (emit (impc:ir:gname "num" (cadr num))
            (if (impc:ir:fixed-point? (cadr num))
                " = add "
                " = fadd ")
            iterator-type " " (car num) ", "
            (car (impc:ir:gname "val")) "\n" os)

      (emit (impc:ir:gname "comp" "i1") " = "
            (if (impc:ir:fixed-point? (cadr num))
                "icmp ult "
                "fcmp ult ")
            (cadr num) " " (car num) ", "
            (if (impc:ir:fixed-point? (cadr num))
                "1\n"
                "1.0\n") os)

      (emit  "br i1 " (car (impc:ir:gname)) ", label " after ", label " loop "\n" os)

      (set! num (impc:ir:gname "num"))
                                        ; (emit  "br i1 false, label " after ", label " loop "\n" os)
                                        ;(emit  "br label " loop "\n" os)

      (emit  "\n" loop-label "\n" os)
      (emit bodystr os)
      (emit (string-append "%loop_cnt" (number->string loop-num)
                           " = load " iterator-type ", " iterator-type "* " iterator "Ptr\n") os)
      (emit (string-append "%next" (number->string loop-num)
                           (if (impc:ir:fixed-point? (cadr num))
                               " = add "
                               " = fadd ")
                           iterator-type " %loop_cnt" (number->string loop-num)
                           (if (impc:ir:fixed-point? (cadr num))
                               ", 1\n"
                               ", 1.0\n"))
            os)
      (emit (string-append "store " iterator-type " %next" (number->string loop-num)
                           ", " iterator-type "* " iterator "Ptr\n") os)
      (emit (string-append cmp " = "
                           (if (impc:ir:fixed-point? (cadr num))
                               "icmp ult "
                               "fcmp ult ")
                           (cadr num) " "
                           "%next" (number->string loop-num) ", " (car num) "\n") os)
      (emit  "br i1 " cmp ", label " loop ", label " after "\n" os)
      (emit  "\n" after-label "\n" os)
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:while-loop
  (lambda (ast types)
    (let* ((os (make-string 0))
           (loop-num-string (number->string (llvm:count++)))
           (loop (string-append "%loop" loop-num-string))
           (after (string-append "%after" loop-num-string)))
      (emit "; while loop\n" os)
      ;; initial test
      (emit (impc:ir:compiler (car ast) types) os)
      (emit "br i1 " (car (impc:ir:gname))
            ", label " loop
            ", label " after
            "\n" os)

      ;; loop body
      (emit  "\nloop" loop-num-string ":\n" os)
      (emit (impc:ir:compiler (cdr ast) types) os)

      ;; re-test loop condition
      (emit (impc:ir:compiler (car ast) types) os)
      (emit "br i1 " (car (impc:ir:gname))
            ", label " loop
            ", label " after
            "\n" os)
      (emit  "\nafter" loop-num-string ":\n" os)
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      ;; (println 'output 'string:) (println os)
      (impc:ir:strip-space os))))


;; THIS VERSION DOESN'T COPY ANYTHING!
;; (define impc:ir:compiler:set!
;;   (lambda (ast types)
;;     (let* ((os (make-string 0))
;;            (t (if (assoc-strcmp (cadr ast) types) (cdr (assoc-strcmp (cadr ast) types)) #f))
;;            (s2 (if t
;;                    (impc:ir:compiler (caddr ast) types t)
;;                    (impc:ir:compiler (caddr ast) types)))
;;            (vv (impc:ir:gname))
;;            (type (impc:ir:get-type-from-str (cadr vv))))
;;       (emit "; do set!\n" os)
;;       (emit s2 os)
;;       (if (impc:ti:globalvar-exists? (symbol->string (cadr ast))) ;; are we are setting a global variable?
;;           (emit (string-append "store " (cadr vv) " " (car vv) ", " (cadr vv) "* @"
;;                                (symbol->string (cadr ast)) "\n") os)
;;           (if (member (cadr ast) *impc:ir:sym-name-stack*)
;;               (emit (string-append "store " (cadr vv) " " (car vv) ", " (cadr vv) "* %"
;;                                    (symbol->string (cadr ast)) "Ptr\n") os)
;;               (impc:compiler:print-missing-identifier-error (cadr ast) 'variable)))
;;       ;; ir:gname should be vv
;;       (impc:ir:strip-space os))))

(define impc:ir:compiler:set!
  (lambda (ast types)
    (let* ((os (make-string 0))
           (global? (impc:ti:globalvar-exists? (symbol->string (cadr ast)))) ;; are we are setting a global variable?
           (gtype (if global? (impc:ir:pointer-- (impc:ti:get-globalvar-type (symbol->string (cadr ast)))) #f))
           (t (if global? gtype
                  (if (assoc-strcmp (cadr ast) types)
                      (cdr (assoc-strcmp (cadr ast) types))
                      #f)))
           (s2 (if t
                   (impc:ir:compiler (caddr ast) types t)
                   (impc:ir:compiler (caddr ast) types)))
           (vv (impc:ir:gname))
           (type (impc:ir:get-type-from-str (cadr vv))))
      (emit "; do set!\n" os)
      (emit s2 os)
      (if global? ;; (impc:ti:globalvar-exists? (symbol->string (cadr ast))) ;; are we are setting a global variable?
          (emit (string-append "store " (cadr vv) " " (car vv) ", " (cadr vv) "* @"
                               (symbol->string (cadr ast)) "\n") os)
          (if (member (cadr ast) *impc:ir:sym-name-stack*)
              (emit (string-append "store " (cadr vv) " " (car vv) ", " (cadr vv) "* %"
                                   (symbol->string (cadr ast)) "Ptr\n") os)
              (impc:compiler:print-missing-identifier-error (cadr ast) 'variable)))
      ;; ir:gname should be vv
      (impc:ir:strip-space os))))


;; makes an array 'literal'
(define impc:ir:compiler:make-array
  (lambda (ast types hint?)
    ;; (println 'make-array-literal: hint?)
    (let* ((os (make-string 0))
           (tt #f))
      (let* ((elts (map (lambda (x t)
                          (let ((res (cons (impc:ir:compiler x types (if tt tt t))
                                           (impc:ir:gname))))
                            (if (and (not tt) (not t))
                                (set! tt (impc:ir:get-type-from-str (cadr (impc:ir:gname)))))
                            res))
                        (cdr ast)
                        (if (and (not (null? hint?))
                                 (list? hint?)
                                 (list? (car hint?))
                                 (equal? (caar hint?) 15))
                            (make-list (length (cdr ast)) (caddr (car hint?)))
                            (make-list (length (cdr ast)) #f))))
             (num-elts (length elts))
             (fullt (string-append "[" (number->string num-elts) " x " (cadr (cdar elts)) "]")))
        (emit "; stack alloc array literal")
        (emit (caar elts) os)
        (emit (impc:ir:gname "arrayl" fullt) " = insertvalue " fullt " undef, " (cadr (cdar elts)) " " (car (cdar elts)) ", 0\n" os)
        (emit "; set array literal elts")
        (for-each (lambda (x idx)
                    (emit (car x) os)
                    (let ((last (impc:ir:gname "arrayl")))
                      (emit (impc:ir:gname "arrayl" fullt)
                            " = insertvalue " fullt " " (car last)
                            ", " (caddr x) " " (cadr x) ", " (number->string idx) "\n" os)))
                  (cdr elts)
                  (range 1 (+ 1 num-elts)))
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:array-ref
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (tt '()))
      ;; type tests
      (if (not (impc:ir:array? ttype))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "invalid array type" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (impc:ir:get-type-str t) "array index must be an integer" ast))
      (if (and (integer? (caddr ast)) (> (+ 1 (caddr ast)) (cadr ttype)))
          (impc:compiler:print-index-oob-error 'array ast))
      (if (and (not (impc:ir:pointer? ttype))
               (not (number? (caddr ast))))
          (impc:compiler:print-compiler-error "Value Arrays can only be accessed by literal integer offets.  You could try using an array reference instead?" ast))
      (emit index-str os)
      (emit var-str os)
      (emit "; array ref\n" os)
      (if (not (impc:ir:pointer? ttype)) ;; must be an array if we're not a pointer
          ;; (log-error 'Compiler 'Error: 'array-ref 'must 'take 'a 'pointer 'to 'an 'array 'not (cadr var))
          (emit (string-append (impc:ir:gname "val" (impc:ir:get-type-str (caddr ttype))) " = extractvalue "
                               (cadr var) " " (car var) ", " (car idx) "\n") os)
          (begin (emit (string-append (impc:ir:gname "_val" (string-append (impc:ir:get-type-str (caddr ttype)) "*"))
                                      " = getelementptr " (impc:ir:pointer-- (cadr var)) ", " (cadr var) " " (car var)
                                      ", i32 0, " (cadr idx) " " (car idx) "\n") os)
                 (set! tt (impc:ir:get-type-str (caddr ttype)))
                 (emit (impc:ir:gname "val" tt) " = load " tt ", " tt "* " (car (impc:ir:gname "_val")) "\n" os)))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:array-ref-ptr
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var))))
      ;; type tests
      (if (not (impc:ir:array? ttype))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "invalid array type" ast))
      (if (> (impc:ir:get-ptr-depth ttype) 1)
          (impc:compiler:print-compiler-error "pointer depth too great for array-set!" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
      (if (and (integer? (caddr ast)) (> (+ 1 (caddr ast)) (cadr ttype)))
          (impc:compiler:print-index-oob-error 'array ast))
      (emit index-str os)
      (emit var-str os)
      (emit "; array ref\n" os)
      (if (not (impc:ir:pointer? ttype)) ;; must be an array if we're not a pointer
          (impc:compiler:print-bad-type-error-with-ast (cadr ttype) "array-ref-ptr must take a pointer to an array" ast)
          (emit (string-append (impc:ir:gname "val" (string-append (impc:ir:get-type-str (caddr ttype)) "*"))
                               " = getelementptr " (impc:ir:pointer-- (cadr var)) ", " (cadr var) " " (car var)
                               ", i32 0, " (cadr idx) " " (car idx) "\n") os))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:array-set
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (val-str (impc:ir:compiler (cadddr ast) types
                                      (if (impc:ir:array? ttype)
                                          (caddr ttype)
                                          (impc:ir:pointer-- (cadr var)))))
           (val (impc:ir:gname)))
      ;; type tests
      (if (not (impc:ir:array? ttype))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "invalid array type" ast))
      (if (> (impc:ir:get-ptr-depth ttype) 1)
          (impc:compiler:print-compiler-error "pointer depth too great for aset!" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
      (if (not (equal? (impc:ir:get-type-from-str (cadr val)) ;(impc:ir:get-type-from-str (cadr var))
                       (if (impc:ir:array? ttype)
                           (caddr ttype)
                           (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr var))))))
          (impc:compiler:print-type-mismatch-error (cadr val) (cadr var) (car ast)))
      (if (and (integer? (caddr ast)) (> (+ 1 (caddr ast)) (cadr ttype)))
          (impc:compiler:print-index-oob-error 'array ast))
      ;; type tests done
      (emit index-str os)
      (emit var-str os)
      (emit val-str os)
      (emit "; set array\n" os)
      (if (not (impc:ir:pointer? ttype)) ;; must be an array if we're not a pointer
          (impc:compiler:print-bad-type-error-with-ast (cadr ttype) "aset! must take a pointer to an array" ast)
                                        ;(begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (caddr ttype))) " = insertvalue "
                                        ;     (cadr var) " " (car var) ", " (cadr val) " " (car val) ", " (car idx) "\n" os))
          (begin (emit (impc:ir:gname "val" (string-append (impc:ir:get-type-str (caddr ttype)) "*"))
                       " = getelementptr " (impc:ir:pointer-- (cadr var)) ", " (cadr var) " " (car var)
                       ", i32 0, " (cadr idx) " " (car idx) "\n" os)
                 (emit "store " (cadr val) " " (car val) ", "
                       (cadr (impc:ir:gname)) " " (car (impc:ir:gname)) "\n" os)))
      (impc:ir:gname "val" (car val) (cadr val))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:pointer-ref
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (tt '()))
      ;; type tests
      (if (not (impc:ir:pointer? ttype))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "array must take a pointer to an array" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
      (emit index-str os)
      (emit var-str os)
      (emit "; pointer ref\n" os)
      (if (not (impc:ir:pointer? ttype)) ;; must be an array if we're not a pointer
          (emit (string-append (impc:ir:gname "val" (impc:ir:get-type-str (caddr ttype))) " = extractvalue "
                               (cadr var) " " (car var) ", " (car idx) "\n") os)
          (begin (emit (string-append (impc:ir:gname "val" (cadr var)) " = getelementptr "
                                      (impc:ir:pointer-- (cadr var)) ", " (cadr var) " " (car var) ", " (cadr idx) " " (car idx) "\n") os)
                 (set! tt (impc:ir:get-type-str (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr var)))))))
      (if (impc:ir:pointer? ttype)
          (emit (string-append (impc:ir:gname "val" tt) " = load " tt ", " tt "* "
                               (car (impc:ir:gname 1)) "\n") os))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:pointer-ref-ptr
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var))))
      ;; type tests
      (if (not (impc:ir:pointer? ttype))
          (impc:compiler:print-bad-type-error-with-ast ttype "must be a pointer" ast))
      (if (and (= 1 (impc:ir:get-ptr-depth ttype))
               (or (impc:ir:closure? ttype)))
          (impc:compiler:print-bad-type-error-with-ast ttype "must be a pointer" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
      (emit index-str os)
      (emit var-str os)
      (emit "; pointer ref\n" os)
      (emit (string-append (impc:ir:gname "val" (cadr var)) " = getelementptr "
                           (impc:ir:pointer-- (cadr var))
                           ", " (cadr var) " " (car var) ", "
                           (cadr idx) " " (car idx) "\n") os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:pointer-set
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (val-str (impc:ir:compiler (cadddr ast) types
                                      (impc:ir:pointer-- ttype)))
           (val (impc:ir:gname)))
      ;; type tests
      (if (not (impc:ir:pointer? ttype))
          (impc:compiler:print-bad-type-error-with-ast ttype "must be a pointer" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (impc:ir:get-type-from-str (cadr idx))  "index must be an integer" ast))
      ;; (if (and (= 1 (impc:ir:get-ptr-depth ttype))
      ;;          (or (impc:ir:closure? ttype)
      ;;              (impc:ir:array? ttype)
      ;;              (impc:ir:tuple? ttype)))
      ;;     (if (impc:ir:tuple? ttype)
      ;;         (impc:compiler:print-bad-type-error-with-ast (cadr var) (string-append "cannot be a tuple type, maybe you want " (cadr var) "*") ast)
      ;;         (if (impc:ir:array? ttype)
      ;;             (impc:compiler:print-bad-type-error-with-ast (cadr var) (string-append "cannot be an array type, maybe you want " (cadr var) "*") ast)
      ;;             (impc:compiler:print-bad-type-error-with-ast (cadr var) (string-append "cannot be a closure type, maybe you want " (cadr var) "*") ast))))

      (if (not (equal? (impc:ir:get-type-from-str (cadr val))
                       (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr var)))))
          (impc:compiler:print-type-mismatch-error
           (cadr val)
           (impc:ir:pointer-- (impc:ir:get-type-from-str (cadr var))) (car ast)))
      ;; type tests done
      (emit index-str os)
      (emit var-str os)
      (emit val-str os)
      (emit "; set pointer\n" os)
      (emit (string-append (impc:ir:gname "val" (cadr var)) " = getelementptr "
                           (impc:ir:pointer-- (cadr var)) ", " (cadr var) " "
                           (car var) ", " (cadr idx) " " (car idx) "\n") os)
      (emit (string-append "store " (cadr val) " " (car val) ", "
                           (cadr (impc:ir:gname)) " " (car (impc:ir:gname)) "\n") os)
      (impc:ir:gname "val" (car val) (cadr val))
      (impc:ir:strip-space os))))

;; makes an array 'literal'
(define impc:ir:compiler:make-vector
  (lambda (ast types hint?)
    ;; (println 'make-vector-literal: hint?)
    (let* ((os (make-string 0))
           (tt #f))
      (let* ((elts (map (lambda (x t)
                          (let ((res (cons (impc:ir:compiler x types (if tt tt t))
                                           (impc:ir:gname))))
                            (if (and (not tt) (not t))
                                (set! tt (impc:ir:get-type-from-str (cadr (impc:ir:gname)))))
                            res))
                        (cdr ast)
                        (if (and (not (null? hint?))
                                 (list? hint?)
                                 (list? (car hint?))
                                 (equal? (caar hint?) 16))
                            (make-list (length (cdr ast)) (caddr (car hint?)))
                            (make-list (length (cdr ast)) #f))))
             (num-elts (length elts))
             (fullt (string-append "<" (number->string num-elts) " x " (cadr (cdar elts)) ">")))
        (emit "; stack alloc vector literal")
        (emit (caar elts) os)
        (emit (impc:ir:gname "vecl" fullt) " = insertelement " fullt " undef, " (cadr (cdar elts)) " " (car (cdar elts)) ", i32 0\n" os)
        (emit "; set array literal elts")
        (for-each (lambda (x idx)
                    (emit (car x) os)
                    (let ((last (impc:ir:gname "vecl")))
                      (emit (impc:ir:gname "vecl" fullt)
                            " = insertelement " fullt " " (car last)
                            ", " (caddr x) " " (cadr x) ", i32 " (number->string idx) "\n" os)))
                  (cdr elts)
                  (range 1 (+ 1 num-elts)))
        (impc:ir:strip-space os)))))



(define impc:ir:compiler:vector-ref
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types *impc:ir:si32*))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (tt '()))
      ;; type tests
      (if (not (impc:ir:vector? ttype))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "invalid vector type" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast ast 'index 'must 'be 'fixed-point 'not (cadr idx)))
      (emit index-str os)
      (emit var-str os)
      (emit "; vector ref\n" os)
      ;; (println 'ttype: ttype)
      ;; (println 'var: var)
      ;; (println 'idx: idx)
      ;; (println 'ret: (caddr ttype))
      ;; (println 'pointer: (impc:ir:pointer? ttype))
      (if (impc:ir:pointer? ttype) ;; a pointer?
          (emit (string-append (impc:ir:gname "vect" (impc:ir:get-type-str (impc:ir:pointer-- (cadr var)))) " = load " (impc:ir:pointer-- (cadr var)) ", "
                               (cadr var) " " (car var) "\n"
                               (impc:ir:gname "val" (impc:ir:get-type-str (caddr ttype))) " = extractelement "
                               (cadr (impc:ir:gname "vect")) " " (car (impc:ir:gname "vect")) ", i32 " (car idx) "\n") os)
          (emit (impc:ir:gname "val" (impc:ir:get-type-str (caddr ttype))) " = extractelement "
                (cadr var) " " (car var) ", " (cadr idx) " " (car idx) "\n" os))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:vector-set
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types *impc:ir:si32*)) ;; i32
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           (ttype (impc:ir:get-type-from-str (cadr var)))
           (val-str (impc:ir:compiler (cadddr ast) types (caddr ttype)))
           (val (impc:ir:gname)))
      ;; type tests
      (if (not (impc:ir:vector? ttype))
          (impc:compiler:print-bad-type-error-with-ast ttype "invalid vector type" ast))
      (if (> (impc:ir:get-ptr-depth ttype) 1)
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "pointer depth too great for vector-set!" ast))
      ;; type tests done
      (emit index-str os)
      (emit var-str os)
      (emit val-str os)
      (emit "; set vector\n" os)
      (if (impc:ir:pointer? ttype) ;; must be an array if we're not a pointer
          (emit (impc:ir:gname "vect" (impc:ir:get-type-str (impc:ir:pointer-- ttype))) " = load " (impc:ir:pointer-- (cadr var)) ", " (cadr var) " " (car var) "\n"
                (impc:ir:gname "vect2" (cadr (impc:ir:gname "vect"))) " = insertelement " (cadr (impc:ir:gname "vect")) " " (car (impc:ir:gname "vect"))
                ", " (cadr val) " " (car val) ", " (cadr idx) " " (car idx) "\n"
                "store " (cadr (impc:ir:gname "vect2")) " " (car (impc:ir:gname "vect2")) ", " (cadr var) " " (car var) "\n" os)
          (impc:compiler:print-bad-type-error-with-ast ttype "vset! needs to be a pointer to a vector" ast))
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      (impc:ir:strip-space os))))

;;
;; takes a vector and b vector
;; vector a and b must be same type
;; the length of a and b then define
;; the number of args that (vshuffle takes)
;; these args are index values into both a and b
;;
;; i.e. assuming /4,float/* for a and b
;; (vshuffle a b 0 3 4 5)
;; returns a new vector which is made up of
;; 0 -> first element of a
;; 3 -> last element of a
;; 4 -> first element of b
;; 5 -> second element of b
;;
;; (vshuffle a null 0 2 1 3)
;; just shuffles a only
;;
(define impc:ir:compiler:vector-shuffle
  (lambda (ast types)
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types *impc:ir:si32*)) ;; i32
           (a-str (impc:ir:compiler (cadr ast) types))
           (aval (impc:ir:gname))
           (_at (impc:ir:get-type-from-str (cadr aval)))
           (b-str (impc:ir:compiler (caddr ast) types))
           (bval (impc:ir:gname))
           (_bt (impc:ir:get-type-from-str (cadr bval)))
           (args (cdddr ast)))
      ;; type tests
      (if (and (number? _bt) (<> _bt 108))
          (if (or (not (impc:ir:vector? _at))
                  (not (impc:ir:vector? _bt))
                  (<> (cadr _at) (cadr _bt)))
              (log-error 'Compiler 'Error: 'Shuffle 'Type 'Mismatch: _at 'and _bt 'must 'be 'same 'type 'vectors)))
      ;; total shuffle elements must match vector length
      (if (<> (length (cdddr ast))
              (cadr _at))
          (log-error 'Compiler 'Error: 'Number 'of 'shuffle 'elements 'must 'match 'vector 'size: (cadr _at)))
      ;; type tests done
      (emit "; shuffle vector\n" os)
      (emit a-str os)
      (emit b-str os)
      ;; dereference any vector pointers
      (if (impc:ir:pointer? (cadr aval))
          (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr aval)))) " = load " (impc:ir:pointer-- (cadr aval)) ", " (cadr aval) " " (car aval) "\n" os)
                 (set! aval (impc:ir:gname))))
      (if (and (list? _bt)
               (impc:ir:pointer? (cadr bval)))
          (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr bval)))) " = load " (impc:ir:pointer-- (cadr bval)) ", " (cadr bval) " " (car bval) "\n" os)
                 (set! bval (impc:ir:gname))))
      (emit (impc:ir:gname "vect" (impc:ir:get-type-str (impc:ir:pointer-- _at)))
            " = shufflevector "
            (cadr aval) " " (car aval) ", "
            (cadr aval) " " (if (number? _bt) "undef" (car bval)) ", "
            (string-append "<" (number->string (cadr _at)) " x i32> <i32 " (number->string (car args))
                           (apply string-append (map (lambda (a) (string-append ", i32 " (number->string a)))
                                                     (cdr args)))
                           ">") os)
      (impc:ir:strip-space os))))

(define impc:ir:compiler:num-of-elts
  (lambda (ast types)
    (let* ((t (assoc-strcmp (cadr ast) types)))
      (if (or (null? t)
              (and (not (impc:ir:array? (cdr t)))
                   (not (impc:ir:vector? (cdr t)))))
          (impc:compiler:print-compiler-error "num-of-elts must take a variable of array or vector type not: " (cdr ast)))
      (impc:ir:gname (number->string (cadr (cdr t))) "i64")
      "")))

;; returns the size of the object (first argument)
;; optional second argument is a dereference object
;; which should be an number starting at 0 (for no dereference) and increasing for each level of dereference...
;; returns the size as an i64
(define impc:ir:compiler:obj-size
  (lambda (ast types)
    (let* ((d (if (null? (cddr ast)) 0 (caddr ast)))
           (t (assoc-strcmp (cadr ast) types)))
       (if (null? t)
            (impc:compiler:print-compiler-error "first argument to obj-size must be a valid variable"))
       (if (not (integer? d))
            (impc:compiler:print-compiler-error "second argument to obj-size must be an integer number of dereferences"))
       (if (= d 0)
           (impc:ir:gname (number->string (impc:ir:get-type-size (cdr t))) "i64")
           (impc:ir:gname (number->string (impc:ir:get-type-size (impc:ir:pointer-- (cdr t) d))) "i64"))
       "")))

(define impc:ir:compiler:ref
  (lambda (ast types)
    (let* ((t (assoc-strcmp (cadr ast) types)))
      (if (null? t)
          (impc:compiler:print-compiler-error "single argument to ref must be a valid variable"))
      (impc:ir:gname (string-append (symbol->string (cadr ast)) "Ptr")
                     (string-append "%" (symbol->string (cadr ast)) "Ptr")
                     (impc:ir:get-type-str (impc:ir:pointer++ (cdr t))))
      "")))

(define impc:ir:compiler:zone-alloc-without-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let*      ;((t (impc:ir:convert-from-pretty-types (cadr ast))))
          ((t (impc:ir:pointer-- (car hint?))))
        (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
              (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
              os)
        (emit (impc:ir:gname "dat" "i8*") " = call i8* @llvm_zone_malloc(%mzone* " (car (impc:ir:gname "zone")) ", "
              *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size t)) ")\n" os)
        (emit "call i8* @memset(i8* " (car (impc:ir:gname "dat")) ", i32 0, "
              *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size t)) ")\n" os)
        (emit (impc:ir:gname "val" (string-append (impc:ir:get-type-str t) "*"))
              " = bitcast i8* " (car (impc:ir:gname "dat"))
              " to " (impc:ir:get-type-str t) "*\n" os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:zone-alloc-with-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let* ((idx-str (impc:ir:compiler (cadr ast) types))
             (idx (impc:ir:gname))
             (t (impc:ir:get-type-from-str (cadr idx)))
             (tt (impc:ir:pointer-- (car hint?)))
             (typesize (number->string (impc:ir:get-type-size tt))))
        ;;(impc:ir:convert-from-pretty-types (car hint?)))))
        ;; (tt (if (null? (cddr ast))
        ;;       (impc:ir:pointer-- (impc:ir:convert-from-pretty-types (car hint?)))
        ;;       (impc:ir:convert-from-pretty-types (caddr ast)))))
        (if (not (impc:ir:fixed-point? t))
            (impc:compiler:print-bad-type-error-with-ast (impc:ir:get-type-str t) "alloc size must be an integer" ast))
        (emit idx-str os)
        (if (not (member t (list *impc:ir:si64* *impc:ir:ui64*)))
            (begin (emit (string-append (impc:ir:gname "tmp" "i64") " = zext " (impc:ir:get-type-str t) " "
                                        (car idx) " to i64\n") os)
                   (set! idx (impc:ir:gname))))
        (emit (impc:ir:gname "val" "i8*") " = getelementptr " (impc:ir:get-type-str t) ", " (impc:ir:get-type-str t) "* null, i32 1\n" os)
        ;; (emit (impc:ir:gname "typesize" *impc:ir:size_t_str*) " = ptrtoint " (impc:ir:get-type-str t) "* "
        ;;       (car (impc:ir:gname 1)) " to " *impc:ir:size_t_str* "\n" os)
        ;;
        ;; (emit (impc:ir:gname "zonesize" "i64") " = mul "
        ;;       (cadr (impc:ir:gname "typesize")) " " (car (impc:ir:gname "typesize")) ", "
        ;;       (car idx) "\n" os)
        (emit (impc:ir:gname "zonesize" "i64") " = mul " (cadr idx) " " typesize ", " (car idx) "\n" os)

        (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
              (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
              os)
        (emit
         (impc:ir:gname "dat" "i8*") " = call i8* @llvm_zone_malloc(%mzone* " (car (impc:ir:gname "zone")) ", i64 "
         (car (impc:ir:gname "zonesize"))
         ")\n" os)
        (emit "call i8* @memset(i8* " (car (impc:ir:gname "dat")) ", i32 0, i64 " (car (impc:ir:gname "zonesize")) ")\n" os)
        (emit (impc:ir:gname "val" (string-append (impc:ir:get-type-str tt) "*"))
              " = bitcast i8* " (car (impc:ir:gname "dat"))
              " to " (impc:ir:get-type-str tt) "*\n" os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:zone-alloc
  (lambda (ast types hint?)
    (if (= (length ast) 1)
        (impc:ir:compiler:zone-alloc-without-size ast types hint?)
        (impc:ir:compiler:zone-alloc-with-size ast types hint?))))


(define impc:ir:compiler:heap-alloc-without-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let* ;;((t (impc:ir:convert-from-pretty-types (cadr ast))))
          ((t (impc:ir:pointer-- (car hint?))))
        (emit  (impc:ir:gname "dat" "i8*") " = call i8* @malloc(" *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size t)) ")\n" os)
        (emit "call i8* @memset(i8* " (car (impc:ir:gname "dat")) ", i32 0, " *impc:ir:size_t_str* " " (number->string (impc:ir:get-type-size t)) ")\n" os)
        (emit (impc:ir:gname "val" (string-append (impc:ir:get-type-str t) "*"))
              " = bitcast i8* " (car (impc:ir:gname "dat"))
              " to " (impc:ir:get-type-str t) "*\n" os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:heap-alloc-with-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let* ((idx-str (impc:ir:compiler (cadr ast) types))
             (idx (impc:ir:gname))
             (t (impc:ir:get-type-from-str (cadr idx)))
             (tt (impc:ir:pointer-- (car hint?)))
             (typesize (number->string (impc:ir:get-type-size tt))))
        ;;(impc:ir:convert-from-pretty-types (car hint?)))))
        ;;(tt (impc:ir:convert-from-pretty-types (caddr ast))))
        (if (not (impc:ir:fixed-point? t))
            (impc:compiler:print-bad-type-error (impc:ir:get-type-str t) "alloc size must be an integer"))
        (emit idx-str os)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (if (not (member t (list *impc:ir:si64* *impc:ir:ui64*)))
            (begin (emit (string-append (impc:ir:gname "tmp" "i64") " = zext " (impc:ir:get-type-str t) " "
                                        (car idx) " to i64\n") os)
                   (set! idx (impc:ir:gname))))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (emit (impc:ir:gname "val" "i8*") " = getelementptr " (impc:ir:get-type-str t) ", " (impc:ir:get-type-str t) "* null, i32 1\n" os)
        ;; (emit (impc:ir:gname "typesize" *impc:ir:size_t_str*) " = ptrtoint " (impc:ir:get-type-str t) "* "
        ;;       (car (impc:ir:gname 1)) " to " *impc:ir:size_t_str* "\n" os)
        ;;
        ;; (emit (impc:ir:gname "zonesize" "i64") " = mul "
        ;;       (cadr (impc:ir:gname "typesize")) " " (car (impc:ir:gname "typesize")) ", "
        ;;       (car idx) "\n" os)
        (emit (impc:ir:gname "zonesize" "i64") " = mul " (cadr idx) " " typesize ", " (car idx) "\n" os)

        (if (string=? *impc:ir:size_t_str* "i32")
            (begin
              (emit (impc:ir:gname "sizeb" "i32") " = trunc i64 " (car (impc:ir:gname "zonesize")) " to i32\n" os)
              (emit (string-append (impc:ir:gname "dat" "i8*") " = call i8* @malloc(" *impc:ir:size_t_str* " "
                                   (car (impc:ir:gname "sizeb"))
                                   ")\n") os))
            (emit (string-append (impc:ir:gname "dat" "i8*") " = call i8* @malloc(" *impc:ir:size_t_str* " "
                                 (car (impc:ir:gname "zonesize"))
                                 ")\n") os))
        (emit "call i8* @memset(i8* " (car (impc:ir:gname "dat")) ", i32 0, i64 " (car (impc:ir:gname "zonesize")) ")\n" os)
        (emit (string-append (impc:ir:gname "val" (string-append (impc:ir:get-type-str tt) "*"))
                             " = bitcast i8* " (car (impc:ir:gname "dat"))
                             " to " (impc:ir:get-type-str tt) "*\n") os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:heap-alloc
  (lambda (ast types hint?)
    (if (= (length ast) 1)
        (impc:ir:compiler:heap-alloc-without-size ast types hint?)
        (impc:ir:compiler:heap-alloc-with-size ast types hint?))))


(define impc:ir:compiler:stack-alloc-with-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let* ((idx-str (impc:ir:compiler (cadr ast) types))
             (idx (impc:ir:gname))
             (t (impc:ir:get-type-str (impc:ir:pointer-- (car hint?)))))
        (emit idx-str os)
        (emit (string-append (impc:ir:gname "dat" (string-append t "*")) " = alloca " t ", " (cadr idx) " " (car idx) ", align 16\n") os)
        (impc:ir:strip-space os)))))

(define impc:ir:compiler:stack-alloc-without-size
  (lambda (ast types hint?)
    (let* ((os (make-string 0)))
      (let* ;((t (impc:ir:get-type-str (impc:ir:convert-from-pretty-types (cadr ast)))))
          ((t (impc:ir:get-type-str (impc:ir:pointer-- (car hint?)))))
        (emit (string-append (impc:ir:gname "dat" (string-append t "*")) " = alloca " t ", align 16\n") os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:stack-alloc
  (lambda (ast types hint?)
    (if *WINDOWS_ALLOC_BUG*
        (if (= (length ast) 1)
            (impc:ir:compiler:zone-alloc-without-size ast types hint?)
            (impc:ir:compiler:zone-alloc-with-size ast types hint?))
        (if (= (length ast) 1)
            (impc:ir:compiler:stack-alloc-without-size ast types hint?)
            (impc:ir:compiler:stack-alloc-with-size ast types hint?)))))



;; makes a tuple 'literal'
(define impc:ir:compiler:make-tuple
  (lambda (ast types hint?)
    ;; (println 'make-tuple-ir hint?)
    (let* ((os (make-string 0)))
      (let* ((elts (map (lambda (x t)
                          (cons (impc:ir:compiler x types t)
                                (impc:ir:gname)))
                        (cdr ast)
                        (if (and (not (null? hint?))
                                 (list? hint?)
                                 (list? (car hint?))
                                 (equal? (caar hint?) 14))
                            (cdr (car hint?))
                            (make-list (length (cdr ast)) #f))))
             (num-elts (length elts))
             (fullt (string-append "{" (caddr (car elts))
                                   (apply string-append (map (lambda (x) (string-append ", " (caddr x))) (cdr elts)))
                                   "}")))
        (emit "; stack alloc tuple literal")
        (emit (caar elts) os)
        (emit (impc:ir:gname "tuplel" fullt) " = insertvalue " fullt " undef, " (cadr (cdar elts)) " " (car (cdar elts)) ", 0\n" os)
        (emit "; set tuple literal elts")
        (for-each (lambda (x idx)
                    (emit (car x) os)
                    (let ((last (impc:ir:gname "tuplel")))
                      (emit (impc:ir:gname "tuplel" fullt)
                            " = insertvalue " fullt " " (car last)
                            ", " (caddr x) " " (cadr x) ", " (number->string idx) "\n" os)))
                  (cdr elts)
                  (range 1 (+ 1 num-elts)))
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:tuple-ref
  (lambda (ast types)
    ;; arg 1 for tuples must be a symbol
    ;; arg 2 for typles must be a number
    ;; this should make it easy for us!
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
                                        ;(atuple-type (impc:ir:get-type-from-str (cadr var)))
           (tuple-type (or (impc:ti:get-namedtype-type (cadr var))
                           (impc:ir:get-type-from-str (cadr var))))
           (ttype (impc:ir:get-type-str tuple-type))
           (element-type (list-ref (cdr tuple-type) (caddr ast))))
      ;; type tests
      (if (not (impc:ir:tuple? (impc:ir:get-type-from-str (cadr var))))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "must be a tuple" ast))
      (if (not (integer? (caddr ast)))
          (impc:compiler:print-bad-type-error (caddr ast) "tref index must be an integer"))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
                                        ;(emit index-str os)
      (emit var-str os)
      (emit "; tuple ref\n" os)
      (define ttstr (impc:ir:get-type-str element-type))
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; do a check for recursive type!
      ;; PROBABLY DON'T NEED THIS NOW WE HAVE NAMED TYPES?
      ;; (if (and (atom? element-type)
      ;;    (< element-type -1))
      ;;     (let* ((tuples-ptr-depth (floor (/ (car tuple-type) (* 1 *impc:ir:pointer*))))
      ;;      (ptr-depth (- (floor (/ element-type (* -1 *impc:ir:pointer*))) tuples-ptr-depth))
      ;;      (tt tuple-type))
      ;;       (dotimes (i ptr-depth)
      ;;   (set! tt (impc:ir:pointer++ tt)))
      ;;       (set! ttstr (impc:ir:get-type-str tt))))
      ;; this code here to support basic type recursion (only depth \2)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (if (> (impc:ir:get-ptr-depth tuple-type) 1)
          (impc:compiler:print-bad-type-error tuple-type "trying to ref from a tuple pointer" ast)
          (if (< (impc:ir:get-ptr-depth tuple-type) 1)
              (emit (string-append (impc:ir:gname "val" ttstr) " = extractvalue "
                                   (cadr var) " " (car var) ", " (car idx) "\n") os)
              (begin (emit (string-append (impc:ir:gname "val" (string-append ttstr "*")) " = getelementptr "
                                          (impc:ir:pointer-- (cadr var)) ", "
                                          (cadr var) " " (car var) ", i64 0, i32 " (car idx) "\n") os)
                     (emit (string-append (impc:ir:gname "val" ttstr) " = load " ttstr ", " ttstr "* "
                                          (car (impc:ir:gname 1)) "\n") os))))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:tuple-ref-ptr
  (lambda (ast types)
                                        ;(println 'tref-ptr 'ast ast 'types types)
    ;; arg 1 for tuples must be a symbol
    ;; arg 2 for typles must be a number
    ;; this should make it easy for us!
    (let* ((os (make-string 0))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
                                        ;(tuple-type (impc:ir:get-type-from-str (cadr var)))
           (tuple-type (let ((r (impc:ir:get-type-from-str (cadr var))))
                         (or (impc:ti:get-namedtype-type r) r)))
                                        ;(ttype (impc:ir:get-type-str tuple-type))
           (element-type (list-ref (cdr tuple-type) (caddr ast))))
      ;; type tests
      (if (not (impc:ir:tuple? (impc:ir:get-type-from-str (cadr var))))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "must be a tuple" ast))
      (if (not (integer? (caddr ast)))
          (impc:compiler:print-bad-type-error (caddr ast) "tref index must be an integer"))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))
                                        ;(emit index-str os)
      (emit var-str os)
      (emit "; tuple ref\n" os)
      (define ttstr (impc:ir:get-type-str element-type))
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; do a check for recursive type!
      ;; PROBABLY DON'T NEED THIS NOW WE HAVE NAMED TYPES?
      ;; (if (and (atom? element-type)
      ;;    (< element-type -1))
      ;;     (let ((tuples-ptr-depth (floor (/ (car tuple-type) (* 1 *impc:ir:pointer*))))
      ;;     (ptr-depth (- (floor (/ element-type (* -1 *impc:ir:pointer*))) tuples-ptr-depth))
      ;;     (tt tuple-type))
      ;;       (dotimes (i ptr-depth)
      ;;   (set! tt (impc:ir:pointer++ tt)))
      ;;       (set! ttstr (impc:ir:get-type-str tt))))
      ;; this code here to support basic type recursion (only depth \2)
   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (if (<> (impc:ir:get-ptr-depth tuple-type) 1)
          (impc:compiler:print-bad-type-error-with-ast tuple-type "bad tuple type" ast))
      (emit (string-append (impc:ir:gname "val" (string-append ttstr "*")) " = getelementptr "
                           (impc:ir:pointer-- (cadr var)) ", "
                           (cadr var) " " (car var) ", i64 0, i32 " (car idx) "\n") os)
      (impc:ir:strip-space os))))


;; indexing into structures is limited to i32 indexes!!
(define impc:ir:compiler:tuple-set
  (lambda (ast types)
    ;; (println 'ast ast 'type types)
    ;; arg 1 for tuples must be a symbol
    ;; arg 2 for tuples must be a number
    ;; this should make it easy for us!
    (let* ((os (make-string 0))
           (var-str (impc:ir:compiler (cadr ast) types))
           (var (impc:ir:gname))
           ;;(tuple-type (impc:ir:get-type-from-str (cadr var)))
           (tuple-type (or (impc:ti:get-namedtype-type (cadr var))
                           (impc:ir:get-type-from-str (cadr var))))
           (element-type (list-ref (cdr tuple-type) (caddr ast)))
           (index-str (impc:ir:compiler (caddr ast) types))
           (idx (impc:ir:gname))
           (val-str (impc:ir:compiler (cadddr ast) types element-type))
           (val (impc:ir:gname)))
      ;;(println 'var: var 'idx: idx 'val: val 'elementtype: element-type)
      ;; type tests
      (if (not (impc:ir:tuple? (impc:ir:get-type-from-str (cadr var))))
          (impc:compiler:print-bad-type-error-with-ast (cadr var) "tuple must be a pointer" ast))
      (if (not (impc:ir:fixed-point? (impc:ir:get-type-from-str (cadr idx))))
          (impc:compiler:print-bad-type-error-with-ast (cadr idx) "index must be an integer" ast))

      ;; ;; check to see if we have type equivelency but not type equality
      ;; ;; i.e. check to see if a given 'named type' is equivelent to the
      ;; ;; requied tuple type (of vica-versa) if it is we will need to bitcast.
      (if (not (impc:ir:types-equal? element-type (cadr val)))
          (impc:compiler:print-type-conflict-error (impc:ir:pretty-print-type element-type)
                                                   (impc:ir:pretty-print-type (cadr val))
                                                   ast))
      ;; type tests done
      (emit index-str os)
      (emit var-str os)
      (emit val-str os)
      (emit "; set tuple\n" os)
      (define ttstr (impc:ir:get-type-str element-type))
      ;; (println '(cadr var) (cadr var) '(car var) (car var) '(cadr val) (cadr val) '(car val) (car val) '(car idx) (car idx))
      (if (<> (impc:ir:get-ptr-depth tuple-type) 1)
          (impc:compiler:print-bad-type-error-with-ast tuple-type "cannot set element into tuple type" ast))
      (emit (string-append (impc:ir:gname "val" (string-append ttstr "*")) " = getelementptr "
                           (impc:ir:pointer-- (cadr var)) ", "
                           (cadr var) " " (car var) ", i64 0, i32 " (car idx) "\n") os)
      (emit (string-append "store " (cadr val) " " (car val) ", "
                           (cadr (impc:ir:gname)) " " (car (impc:ir:gname)) "\n") os)
      (impc:ir:gname "val" (car val) (cadr val))
      (impc:ir:strip-space os))))

;; ret-> (return statement)
(define impc:ir:compiler:ret
  (lambda (ast types . hint?)
    ;; (println 'ast: ast)
    ;; (println 'types: types)
    ;; (println 'hint?: hint?)
    ;; (println 'ping: (assoc-strcmp (caddr ast) types))
    ;; (println 'return-> (cadr (assoc-strcmp (cadr ast) types)))
    (let* ((hinttype? (cadr (cdr (assoc-strcmp (cadr ast) types))))
           (str (impc:ir:compiler (caddr ast) types hinttype?)) ;(if (null? hint?) hinttype? (car hint?))))
           (val (impc:ir:gname))
           (os (make-string 0)))
      (emit str os)
      (if (impc:ir:void? (cadr (impc:ir:gname)))
          (emit "ret void\n" os)
          (let ((type (cadr (cdr (assoc-strcmp (cadr ast) types)))))
                                        ;(println 'type: type)
            (if (and (not (equal? (impc:ir:get-type-from-str (cadr (impc:ir:gname))) type))
                     (not (equal? (cadr ast) (caddr ast)))) ;; this line is a weird catch for outer let??
                (emit (impc:ir:gname "retval" (impc:ir:get-type-str type)) " = bitcast " (cadr val) " " (car val) " to " (impc:ir:get-type-str type) "\n" os))
            (emit "ret " (cadr (impc:ir:gname)) " " (car (impc:ir:gname)) "\n" os)))
      ;;(println 'os2: os)
      (impc:ir:strip-space os))))




(define impc:ir:compiler:llvm_varargs
  (lambda (ast types)
    (let ((args (map (lambda (a)
                       (cons (impc:ir:compiler a types)
                             (impc:ir:gname)))
                     (cdr ast)))
          (va (impc:ir:gname "val" "i32")))
      (cond ((equal? (car ast) 'printf)
             (if (<> (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                     (impc:ir:pointer++ *impc:ir:si8*))
                 (impc:compiler:print-bad-type-error-with-ast
                  (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                  "first argument must be a format string" ast)))
            ((member (car ast) '(fprintf fscanf))
             (if (<> (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                     (impc:ir:pointer++ *impc:ir:si8*))
                 (impc:compiler:print-bad-type-error-with-ast
                  (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                  "first argument must be stdc FILE*" ast))
             (if (<> (impc:ir:get-type-from-str (car (cdr (cdr (cadr args)))))
                     (impc:ir:pointer++ *impc:ir:si8*))
                 (impc:compiler:print-bad-type-error-with-ast
                  (impc:ir:get-type-from-str (car (cdr (cdr (cadr args)))))
                  "second argument must be a format string" ast)))
            ((member (car ast) '(sprintf sscanf))
             (if (<> (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                     (impc:ir:pointer++ *impc:ir:si8*))
                 (impc:compiler:print-bad-type-error-with-ast
                  (impc:ir:get-type-from-str (car (cdr (cdr (car args)))))
                  "first argument must be allocated memory" ast))
             (if (<> (impc:ir:get-type-from-str (car (cdr (cdr (cadr args)))))
                     (impc:ir:pointer++ *impc:ir:si8*))
                 (impc:compiler:print-bad-type-error-with-ast
                  (impc:ir:get-type-from-str (car (cdr (cdr (cadr args)))))
                  "second argument must be a format string" ast)))
            (else (impc:compiler:print-bad-type-error "" "Bad VARARGS func!")))
      (if (equal? (car ast) 'printf)
          (string-append (apply string-append (map (lambda (a) (car a)) args))
                         "\n" va " = call i32 (i8*, ...) @printf("
                         (caddr (car args)) " " (cadr (car args))
                         (apply string-append (map (lambda (a)
                                                     (string-append ", "
                                                                    (caddr a)
                                                                    " " (cadr a)))
                                                   (cdr args)))
                         ")\n")
          (string-append (apply string-append (map (lambda (a) (car a)) args))
                         "\n" va " = call i32 (i8*,i8*, ...) @"
                         (symbol->string (car ast)) "("
                         (caddr (car args)) " " (cadr (car args)) ", "
                         (caddr (cadr args)) " " (cadr (cadr args))
                         (apply string-append (map (lambda (a)
                                                     (string-append ", "
                                                                    (caddr a)
                                                                    " " (cadr a)))
                                                   (cddr args)))
                         ")\n")))))


(define impc:ir:compiler:cmp
  (let ((fcmps '("ugt" "ult" "une" "ueq"))
                                        ;(fcmps '("ogt" "olt" "one" "oeq"))
        (icmps '("sgt" "slt" "ne" "eq")))
    (lambda (v ast types . hint?)
                                        ;(println 'types: types)
      (let* ((type-hint (let ((value (assoc-strcmp (cl:find-if symbol? (cdr ast)) types)))
                          (if value
                              (cdr value)
                              (if (null? hint?)
                                  '()
                                  (car hint?)))))
             (a (impc:ir:compiler (cadr ast) types))
             (aval (impc:ir:gname))
             (t (impc:ir:get-type-from-str (cadr aval)))
             (b (impc:ir:compiler (caddr ast) types t))
             (bval (impc:ir:gname))
             (os (make-string 0))
             (type (cadr aval)))
        ;; sanity checks
        (if (not (or (and (impc:ir:number? (cadr aval))
                          (impc:ir:number? (cadr bval)))
                     (and (impc:ir:pointer? (cadr aval))
                          (impc:ir:pointer? (cadr bval)))
                     (and (impc:ir:vector? (cadr aval))
                          (impc:ir:vector? (cadr bval)))))
            (impc:compiler:print-type-conflict-error (cadr aval) (cadr bval) ast))

        (if (and (impc:ir:number? (cadr aval))
                 (<> (impc:ir:get-type-from-str (cadr aval))
                     (impc:ir:get-type-from-str (cadr bval))))
            (if (number? (cadr ast))
                (set-car! (cdr aval) (cadr bval))
                (if (number? (caddr ast))
                    (set-car! (cdr bval) (cadr aval))
                    (impc:compiler:print-type-conflict-error (cadr aval) (cadr bval) ast))))

        (emit a os)
        (emit b os)
                                        ;(println (cadr aval) '>> (cadr bval) '>> type '>> hint?)
        ;; do llvm float constant check
        (if (and (number? type)
                 (= *impc:ir:fp32* (impc:ir:get-type-from-str type)))
            (begin (if (number? (cadr ast)) (set-car! aval (llvm:convert-float (car aval))))
                   (if (number? (caddr ast)) (set-car! bval (llvm:convert-float (car bval))))))

        ;; do llvm double constant check
        (if (and (number? type)
                 (= *impc:ir:fp64* (impc:ir:get-type-from-str type)))
            (begin (if (number? (cadr ast)) (set-car! aval (number->string (* 1.0 (cadr ast)))))
                   (if (number? (caddr ast)) (set-car! bval (number->string (* 1.0 (caddr ast)))))))

        ;; dereference any vector pointers
        (if (and (impc:ir:pointer? (cadr aval))
                 (impc:ir:vector? (cadr aval)))
            (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr aval)))) " = load " (impc:ir:pointer-- (cadr aval)) ", " (cadr aval) " " (car aval) "\n" os)
                   (set! aval (impc:ir:gname))))
        (if (and (impc:ir:pointer? (cadr bval))
                 (impc:ir:vector? (cadr bval)))
            (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr bval)))) " = load " (impc:ir:pointer-- (cadr bval)) ", " (cadr bval) " " (car bval) "\n" os)
                   (set! bval (impc:ir:gname))))
        (if (and (impc:ir:vector? (cadr bval))
                 (impc:ir:pointer? type))
            (set! type (impc:ir:get-type-str (impc:ir:pointer-- type))))

        (let* ((typet (impc:ir:get-type-from-str (cadr aval)))
               (typetest (if (impc:ir:vector? typet) ;(impc:ir:number? typet)
                             (caddr typet)
                             typet)))
          (if (impc:ir:vector? typet)
              (set! typet (list (car typet) (cadr typet) *impc:ir:i1*))
              (set! typet *impc:ir:i1*))
                                        ;(println 'typet: typet 'v: v (list-ref icmps v) (list-ref fcmps v))
                                        ;(println 'a: aval 'b: bval)
          ;; need this to transpose float values
          (if (or (impc:ir:fixed-point? typetest)
                  (impc:ir:pointer? typetest))
              (emit (string-append (impc:ir:gname "cmp" (impc:ir:get-type-str typet)) " = icmp " (list-ref icmps v)
                                   " " type " " (car aval)
                                   ", " (car bval) "\n") os)
              (emit (string-append (impc:ir:gname "cmp" (impc:ir:get-type-str typet)) " = fcmp " (list-ref fcmps v)
                                   " " type " " (car aval)
                                   ", " (car bval) "\n") os)))
                                        ;(println 'os: os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:modulo
  (lambda (ast types . hint?)
                                        ;(print 'modulo: 'ast: ast 'hint: hint?)
    (let* ((type-hint (let ((value (assoc-strcmp (cl:find-if symbol? (cdr ast)) types)))
                        (if value
                            (cdr value)
                            (if (null? hint?)
                                '()
                                (car hint?)))))
           (a (if (null? type-hint)
                  (impc:ir:compiler (cadr ast) types)
                  (impc:ir:compiler (cadr ast) types type-hint)))
           (aval (impc:ir:gname))
           (b (if (null? type-hint)
                  (impc:ir:compiler (caddr ast) types)
                  (impc:ir:compiler (caddr ast) types type-hint)))
           (bval (impc:ir:gname))
           (os (make-string 0))
           (type (if (null? type-hint)
                     (cadr aval)
                     (impc:ir:get-type-str type-hint))))
      ;; sanity check
      (if (not (and (impc:ir:number? (cadr aval))
                    (impc:ir:number? (cadr bval))))
          (impc:compiler:print-type-conflict-error (cadr aval) (cadr bval) ast))
      (emit a os)
      (emit b os)
                                        ;(print (car aval) '>> (car bval) '>> type)
      ;; do llvm float constant check
      (if (= *impc:ir:fp32* (impc:ir:get-type-from-str type))
          (begin (if (number? (cadr ast)) (set-car! aval (llvm:convert-float (car aval))))
                 (if (number? (caddr ast)) (set-car! bval (llvm:convert-float (car bval))))))
      ;; do llvm double constant check
      (if (= *impc:ir:fp64* (impc:ir:get-type-from-str type))
          (begin (if (number? (cadr ast)) (set-car! aval (number->string (* 1.0 (cadr ast)))))
                 (if (number? (caddr ast)) (set-car! bval (number->string (* 1.0 (caddr ast)))))))

      ;; need this to transpose float values
      (if (impc:ir:fixed-point? (impc:ir:get-type-from-str type))
          (emit (string-append (impc:ir:gname "val" type) " = srem"
                               " " type " " (car aval)
                               ", " (car bval) "\n") os)
          (emit (string-append (impc:ir:gname "val" type) " = frem"
                               " " type " " (car aval)
                               ", " (car bval) "\n") os))
      (impc:ir:strip-space os))))

(define impc:ir:compiler:math-intrinsics
  (let ((mls '(("double" . "f64") ("float" . "f32")
               ("<2 x double>" . "v2f64") ("<4 x float>" . "v4f32")
               ("<4 x double>" . "v4f64") ("<8 x float>" . "v8f32")
               ("<8 x double>" . "v8f64") ("<16 x float>" . "v16f32"))))
    (lambda (ast types . hint?)
      ;; (println 'math: ast types hint?)
      (let* ((args (- (length ast) 1))
             (astr (impc:ir:compiler (cadr ast) types (if (null? hint?) #f (car hint?))))
             (aval (impc:ir:gname))
             (bstr (if (member (car ast) '(pow powi fma))
                       (impc:ir:compiler (caddr ast) types (if (null? hint?) #f (car hint?)))
                       ""))
             (bval (if (< args 2) #f (impc:ir:gname)))
             (cstr (if (member (car ast) '(fma))
                       (impc:ir:compiler (cadddr ast) types (if (null? hint?) #f (car hint?)))
                       ""))
             (cval (if (< args 3) #f (impc:ir:gname)))
             (os (make-string 0)))
        ;; (println 'intrinsice ast aval bval cval)
        ;; sanity checks
        (if (not (or (impc:ir:number? (cadr aval))
                     (impc:ir:vector? (cadr aval))))
            (impc:compiler:print-bad-type-error (cadr aval) ast))
        (if (and bval
                 (not (or (and (impc:ir:number? (cadr aval))
                               (impc:ir:number? (cadr bval)))
                          (and (impc:ir:vector? (cadr aval))
                               (impc:ir:vector? (cadr bval))))))
            (impc:compiler:print-type-conflict-error (cadr aval)
                                                     (cadr bval)
                                                     ast))
        ;; equal types?
        (if bval
            (if (not (equal? (cadr aval) (cadr bval)))
                (if (or (number? (cadr ast))
                        (number? (caddr ast)))
                    (if (number? (cadr ast))
                        (begin
                          (set! astr (impc:ir:compiler `(bitconvert ,(cadr ast) ,(string->symbol (cadr bval))) types))
                          (set! aval (impc:ir:gname)))
                        (begin
                          (set! bstr (impc:ir:compiler `(bitconvert ,(caddr ast) ,(string->symbol (cadr aval))) types))
                          (set! bval (impc:ir:gname))))
                    (impc:compiler:print-type-conflict-error (cadr aval)
                                                             (cadr bval)
                                                             ast))))
        ;;(println 'bbbbbbb)
        (if (and cval (not (equal? (cadr aval) (cadr cval))))
            (impc:compiler:print-type-conflict-error (cadr aval)
                                                     (cadr cval)
                                                     ast))
        (emit astr os)
        (emit bstr os)
        (emit cstr os)
        (emit (string-append (impc:ir:gname "val" (cadr aval)) " = call "
                             (cadr aval) " @llvm." (symbol->string (car ast)) "." (cdr (assoc (cadr aval) mls))
                             "(" (cadr aval) " " (car aval)
                             (if bval (string-append ", " (cadr bval) " " (car bval)) "")
                             (if cval (string-append ", " (cadr cval) " " (car cval)) "")
                             ")\n")
              os)
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:math
  (let ((fcmps '("fadd" "fsub" "fmul" "fdiv" "frem"))
        (icmps '("add" "sub" "mul" "sdiv" "srem")))
    (lambda (v ast types . hint?)
      ;;(println 'types: types)
      ;;(println 'math: 'ast: ast 'hint: hint?)
      (let* ((type-hint (let ((value (assoc-strcmp (cl:find-if symbol? (cdr ast)) types)))
                          (if value
                              (cdr value)
                              (if (null? hint?)
                                  '()
                                  (car hint?)))))
             (a (if (null? type-hint)
                    (impc:ir:compiler (cadr ast) types)
                    (impc:ir:compiler (cadr ast) types type-hint)))
             (aval (impc:ir:gname))
             (b (if (null? type-hint) ;; use a to provide hint for b
                    (impc:ir:compiler (caddr ast) types
                                      (impc:ir:get-type-from-str (cadr (impc:ir:gname))))
                    (impc:ir:compiler (caddr ast) types type-hint)))
             (bval (impc:ir:gname))
             (os (make-string 0))
             (type (if (null? type-hint)
                       (cadr aval)
                       (impc:ir:get-type-str type-hint))))

        ;; sanity checks
        (if (not (or (and (impc:ir:number? (cadr aval))
                          (impc:ir:number? (cadr bval)))
                     (and (impc:ir:vector? (cadr aval))
                          (impc:ir:vector? (cadr bval)))))
            (impc:compiler:print-type-conflict-error (cadr aval) (cadr bval) ast))

        (if (and (impc:ir:number? (cadr aval))
                 (<> (impc:ir:get-type-from-str (cadr aval))
                     (impc:ir:get-type-from-str (cadr bval))))
            (if (number? (cadr ast))
                (set-car! (cdr aval) (cadr bval))
                (if (number? (caddr ast))
                    (set-car! (cdr bval) (cadr aval))
                    (impc:compiler:print-type-conflict-error (cadr aval) (cadr bval) ast))))

        (set! type (if (null? type-hint) (cadr aval) (impc:ir:get-type-str type-hint)))
        (emit a os)
        (emit b os)
                                        ;(print (car aval) '>> (car bval) '>> type)
        ;; do llvm float constant check
        (if (and (number? type)
                 (= *impc:ir:fp32* (impc:ir:get-type-from-str type)))
            (begin (if (number? (cadr ast)) (set-car! aval (llvm:convert-float (car aval))))
                   (if (number? (caddr ast)) (set-car! bval (llvm:convert-float (car bval))))))
        ;; do llvm double constant check
        (if (and (number? type)
                 (= *impc:ir:fp64* (impc:ir:get-type-from-str type)))
            (begin (if (number? (cadr ast)) (set-car! aval (number->string (* 1.0 (cadr ast)))))
                   (if (number? (caddr ast)) (set-car! bval (number->string (* 1.0 (caddr ast)))))))
        ;; dereference any vector pointers
        (if (and (impc:ir:pointer? (cadr aval))
                 (impc:ir:vector? (cadr aval)))
            (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr aval)))) " = load " (impc:ir:pointer-- (cadr aval)) ", " (cadr aval) " " (car aval) "\n" os)
                   (set! aval (impc:ir:gname))))
        (if (and (impc:ir:pointer? (cadr bval))
                 (impc:ir:vector? (cadr bval)))
            (begin (emit (impc:ir:gname "val" (impc:ir:get-type-str (impc:ir:pointer-- (cadr bval)))) " = load " (impc:ir:pointer-- (cadr bval)) ", " (cadr bval) " " (car bval) "\n" os)
                   (set! bval (impc:ir:gname))))
        (if (and (impc:ir:vector? (cadr bval))
                 (impc:ir:pointer? type))
            (set! type (impc:ir:get-type-str (impc:ir:pointer-- type))))

        (let* ((typet (impc:ir:get-type-from-str type))
               (typetest (if (impc:ir:number? typet) typet
                             (caddr typet))))
          ;; (println 'mathcheck: typetest)
          ;; need this to transpose float values
          (if (impc:ir:fixed-point? typetest)
              (emit (string-append (impc:ir:gname "val" type) " = " (list-ref icmps v)
                                   " " type " " (car aval)
                                   ", " (car bval) "\n") os)
              (emit (string-append (impc:ir:gname "val" type) " = " (list-ref fcmps v)
                                   " " type " " (car aval)
                                   ", " (car bval) "\n") os)))

        ;; JUST ADD THIS TO HAVE VECTOR MATH RETURN VECTOR PTRS
        ;; ;; if vector math operations then copy the result into a new
        ;; ;; vector pointer (zone allocated)
        ;; (if (impc:ir:vector? (cadr aval))
        ;;  (let* ((mathval (impc:ir:gname "val"))
        ;;         (mathtype (impc:ir:get-type-from-str (cadr mathval)))
        ;;         (zallocsize (impc:ir:get-type-size mathtype)))
        ;;    (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
        ;;    (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
        ;;    os)
        ;;    (emit (impc:ir:gname "newdat" "i8*") " = call i8* @llvm_zone_malloc(%mzone* "
        ;;    (car (impc:ir:gname "zone")) ", i64 " (number->string zallocsize) ")\n" os)
        ;;    (emit (impc:ir:gname "oldvect" (string-append (cadr mathval) "*")) " = alloca " (cadr mathval) "\n" os)
        ;;    (emit "store " (cadr mathval) " " (car mathval) ", " (cadr (impc:ir:gname "oldvect")) " " (car (impc:ir:gname "oldvect")) "\n" os)
        ;;    (emit (impc:ir:gname "olddat" "i8*") " = bitcast " (cadr (impc:ir:gname "oldvect")) " " (car (impc:ir:gname "oldvect")) " to i8*\n" os)
        ;;    (emit "call i8* @memcpy(i8* " (car (impc:ir:gname "newdat")) ", i8* " (car (impc:ir:gname "olddat")) ", i64 " (number->string zallocsize) ")\n" os)
        ;;    (emit (impc:ir:gname "newvect" (string-append (cadr mathval) "*")) " = bitcast i8* " (car (impc:ir:gname "newdat")) " to " (string-append (cadr mathval) "*") "\n" os)))
        (impc:ir:strip-space os)))))


(define impc:ir:compiler:bitwise
  (lambda (v ast types . hint?)
    (let* ((bitops '("and" "or" "xor" "shl" "lshr"))
           (os (make-string 0))
           (a (impc:ir:compiler (cadr ast) types))
           (aval (impc:ir:gname))
           (b (impc:ir:compiler (caddr ast) types))
           (bval (impc:ir:gname))
           (type (cadr aval)))
      (emit a os)
      (emit b os)
      (emit (string-append (impc:ir:gname "val" type)
                           " = " (list-ref bitops v)
                           " " type " " (car aval) ", " (car bval) "\n") os)
      ;;(println 'bitwise 'ast: ast)
      ;;(println 'bitwise 'ir: os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:bitcast
  (lambda (ast types . hint?)
    ;; (println 'bitcast-hint: hint? ast (cddr ast))
    (if (and (null? (car hint?))
             (null? (cddr ast)))
        (impc:compiler:print-could-not-resolve-type-error ast "try forcing the cast"))
    (let* ((os (make-string 0))
           (a (impc:ir:compiler (cadr ast) types))
           (at (impc:ir:gname))
           (type-str (if (null? (cddr ast))
                         (impc:ir:get-type-str (car hint?))
                         (impc:ir:get-type-str (impc:ir:convert-from-pretty-types (caddr ast))))))
      (emit a os)
      (emit (string-append (impc:ir:gname "val" type-str)
                           " = bitcast " (cadr at) " " (car at) " to " type-str "\n") os)
      (impc:ir:strip-space os))))

;; currently only supports 64bit!
(define impc:ir:compiler:bitconvert
  (lambda (ast types . hint?)
    (if (and (null? (car hint?))
             (null? (cddr ast)))
        (impc:compiler:print-could-not-resolve-type-error ast "try forcing the conversion"))
    (let* ((os (make-string 0))
           (a (impc:ir:compiler (cadr ast) types))
           (at (impc:ir:gname))
           (type-str (if (null? (cddr ast))
                         (impc:ir:get-type-str (car hint?))
                         (impc:ir:get-type-str (impc:ir:convert-from-pretty-types (caddr ast))))))
      (emit a os)
      (let ((from (impc:ir:get-type-from-str (cadr at)))
            (to (impc:ir:get-type-from-str type-str)))
        ;; (println 'convert: from '-> to)
        (cond ((and (number? to) (= to *impc:ir:void*))
               (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*)))
              ((and (impc:ir:pointer? from) ;; must be pointer -> pointer
                    (impc:ir:pointer? to))  ;; do standard bitcast
               (emit (string-append (impc:ir:gname "val" type-str)
                                    " = bitcast " (cadr at) " " (car at) " to " type-str "\n") os))
              ((equal? from to) ;; if to and from are same type do standard bitcast
               (emit (string-append (impc:ir:gname "val" type-str)
                                    " = bitcast " (cadr at) " " (car at) " to " type-str "\n") os))
              ((impc:ir:pointer? from) ;; to must be value
               ;; first convert pointer to int
               (emit (impc:ir:gname "val1" "i64") " = ptrtoint " (impc:ir:get-type-str from) " " (car at) " to i64\n" os)
               ;; now convert i64 into correct final type
               (cond ((= to *impc:ir:fp64*) (emit (impc:ir:gname "val" type-str) " = sitofp i64 " (car (impc:ir:gname "val1")) " to double\n" os))
                     ((= to *impc:ir:fp32*) (emit (impc:ir:gname "val" type-str) " = sitofp i64 " (car (impc:ir:gname "val1")) " to float\n" os))
                     ((= to *impc:ir:si64*) (emit (impc:ir:gname "val" type-str) " = bitcast i64 " (car (impc:ir:gname "val1")) " to i64\n" os))
                     ((= to *impc:ir:si32*) (emit (impc:ir:gname "val" type-str) " = trunc i64 " (car (impc:ir:gname "val1")) " to i32\n" os))
                     ((= to *impc:ir:si16*) (emit (impc:ir:gname "val" type-str) " = trunc i64 " (car (impc:ir:gname "val1")) " to i16\n" os))
                     ((= to *impc:ir:si8*) (emit (impc:ir:gname "val" type-str) " = trunc i64 " (car (impc:ir:gname "val1")) " to i8\n" os))
                     ((= to *impc:ir:i1*) (emit (impc:ir:gname "val" type-str) " = trunc i64 " (car (impc:ir:gname "val1")) " to i1\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((impc:ir:pointer? to) ;; from must be a value
               ;; first convert from to i64
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val1" "i64") " = fptosi double " (car at) " to i64\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val1" "i64") " = fptosi float " (car at) " to i64\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val1" "i64") " = bitcast i64 " (car at) " to i64\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val1" "i64") " = sext i32 " (car at) " to i64\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val1" "i64") " = sext i16 " (car at) " to i64\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val1" "i64") " = sext i8 " (car at) " to i64\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val1" "i64") " = zext i1 " (car at) " to i64\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to)))
               (emit (impc:ir:gname "val" type-str) " = inttoptr i64 " (car (impc:ir:gname "val1")) " to " type-str "\n" os))
              ((= to *impc:ir:fp64*)
               (cond ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "double") " = fpext float " (car at) " to double\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "double") " = sitofp i64 " (car at) " to double\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "double") " = sitofp i32 " (car at) " to double\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "double") " = sitofp i16 " (car at) " to double\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "double") " = sitofp i8 " (car at) " to double\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "double") " = uitofp i1 " (car at) " to double\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:fp32*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "float") " = fptrunc double " (car at) " to float\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "float") " = sitofp i64 " (car at) " to float\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "float") " = sitofp i32 " (car at) " to float\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "float") " = sitofp i16 " (car at) " to float\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "float") " = sitofp i8 " (car at) " to float\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "float") " = uitofp i1 " (car at) " to float\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:si64*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "i64") " = fptosi double " (car at) " to i64\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "i64") " = fptosi float " (car at) " to i64\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "i64") " = sext i32 " (car at) " to i64\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "i64") " = sext i16 " (car at) " to i64\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "i64") " = sext i8 " (car at) " to i64\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "i64") " = zext i1 " (car at) " to i64\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:si32*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "i32") " = fptosi double " (car at) " to i32\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "i32") " = fptosi float " (car at) " to i32\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "i32") " = trunc i64 " (car at) " to i32\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "i32") " = sext i16 " (car at) " to i32\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "i32") " = sext i8 " (car at) " to i32\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "i32") " = zext i1 " (car at) " to i32\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:si16*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "i16") " = fptosi double " (car at) " to i16\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "i16") " = fptosi float " (car at) " to i16\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "i16") " = trunc i64 " (car at) " to i16\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "i16") " = sext i32 " (car at) " to i16\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "i16") " = sext i8 " (car at) " to i16\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "i16") " = zext i1 " (car at) " to i16\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:si8*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "i8") " = fptosi double " (car at) " to i8\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "i8") " = fptosi float " (car at) " to i8\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "i8") " = trunc i64 " (car at) " to i8\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "i8") " = trunc i32 " (car at) " to i8\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "i8") " = trunc i16 " (car at) " to i8\n" os))
                     ((= from *impc:ir:i1*) (emit (impc:ir:gname "val" "i8") " = zext i1 " (car at) " to i8\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))
              ((= to *impc:ir:i1*)
               (cond ((= from *impc:ir:fp64*) (emit (impc:ir:gname "val" "i1") " = fptoui double " (car at) " to i1\n" os))
                     ((= from *impc:ir:fp32*) (emit (impc:ir:gname "val" "i1") " = fptoui float " (car at) " to i1\n" os))
                     ((= from *impc:ir:si64*) (emit (impc:ir:gname "val" "i1") " = trunc i64 " (car at) " to i1\n" os))
                     ((= from *impc:ir:si32*) (emit (impc:ir:gname "val" "i1") " = trunc i32 " (car at) " to i1\n" os))
                     ((= from *impc:ir:si16*) (emit (impc:ir:gname "val" "i1") " = trunc i16 " (car at) " to i1\n" os))
                     ((= from *impc:ir:si8*) (emit (impc:ir:gname "val" "i1") " = trunc i8 " (car at) " to i1\n" os))
                     (else (impc:compiler:print-unsupported-conversion-error from to))))))
      (impc:ir:strip-space os))))


(define impc:ir:compiler:null
  (lambda (ast types)
    (let* ((os (make-string 0))
           (a (impc:ir:compiler (cadr ast) types))
           (at (impc:ir:gname)))
      (emit a os)
      (emit  (impc:ir:gname "val" "i1") " = icmp eq " (cadr at) " " (car at) ", null\n" os)
      (impc:ir:strip-space os))))


;; if that finishes with ret clauses (i.e. doesn't return a value)
(define impc:ir:compiler:ifret
  (lambda (ast types)
    (let* ((os (make-string 0))
           (elset (if (null? (cdddr ast)) #f #t))
           (num (number->string (llvm:count++))))
                                        ;(println 'ifretast: ast)
      ;; first do compare expression
      (emit (impc:ir:compiler (cadr ast) types) os)
      ;; then break on compare
      (emit (string-append "br i1 " (car (impc:ir:gname)) ", label %then" num ", "
                           (if elset "label %else" "label %then")
                           num "\n") os)
      ;; do then
      (emit  "\nthen" num ":\n" os)
      (emit (impc:ir:compiler (caddr ast) types) os)

      (define a (impc:ir:gname))
      ;; do else if requried
      (if elset
          (begin (emit  "\nelse" num ":\n" os)
                 (emit (impc:ir:compiler (cadddr ast) types) os)))
      ;; finally consolidate return type of if statement
      (define b (if elset (impc:ir:gname) #f))

      (if (and elset
               (not (equal? (impc:ir:get-type-from-str (cadr a))
                            (impc:ir:get-type-from-str (cadr b)))))
          (impc:compiler:print-if-type-conflict-error (cadr a) (cadr b)))
      (impc:ir:strip-space os))))


;; if that might need to return a value
(define impc:ir:compiler:if
  (lambda (ast types . hint?)
    ;; (println 'ast: ast)
    (let* ((os (make-string 0))
           (elset (if (or (null? (cdddr ast))
                          (null? (cadddr ast)))
                      #f #t))
           (num (number->string (llvm:count++))))
      ;; first do compare expression
      (emit (impc:ir:compiler (cadr ast) types) os)
      ;; then break on compare
      (emit (string-append "br i1 " (car (impc:ir:gname)) ", label %then" num ", "
                           "label %else" num "\n") os)
      ;; do then
      (emit  "\nthen" num ":\n" os)
      (if (not (null? hint?))
          (emit (impc:ir:compiler (caddr ast) types (car hint?)) os)
          (emit (impc:ir:compiler (caddr ast) types) os))
      (if (not (impc:ir:void? (cadr (impc:ir:gname))))
          (emit (string-append "store " (cadr (impc:ir:gname)) " " (car (impc:ir:gname))
                               ", " (cadr (impc:ir:gname)) "* %ifptr" num "\n") os))
      (emit  "br label %ifcont" num "\n" os)
      (define a (impc:ir:gname))
      ;; do else if requried
      (if elset
          (begin (emit  "\nelse" num ":\n" os)
                 (if (not (null? hint?))
                     (emit (impc:ir:compiler (cadddr ast) types (car hint?)) os)
                     (emit (impc:ir:compiler (cadddr ast) types) os))
                 (if (not (impc:ir:void? (cadr (impc:ir:gname))))
                     (emit (string-append "store " (cadr (impc:ir:gname)) " " (car (impc:ir:gname))
                                          ", " (cadr (impc:ir:gname)) "* %ifptr" num "\n") os))
                 (emit  "br label %ifcont" num "\n" os))
          (begin (emit  "\nelse" num ":\n" os)
                 (emit  "br label %ifcont" num "\n" os)))

      ;; finally consolidate return type of if statement
      (define b (if elset (impc:ir:gname) #f))

      (if (and elset
               (not (equal? (impc:ir:get-type-from-str (cadr a))
                            (impc:ir:get-type-from-str (cadr b)))))
          (impc:compiler:print-if-type-conflict-error (cadr a) (cadr b)))

      (emit  "\nifcont" num ":\n" os)
      (if (not (impc:ir:void? (cadr a)))
          (begin (emit  (impc:ir:gname "ifres" (cadr a)) " = load " (cadr a) ", " (cadr a) "* %ifptr" num "\n\n" os)
                 ;; make sure ifptr gets stack allocated at the TOP
                 ;; of the closure by adding it to *impc:ir:ls_var*
                 (set! *impc:ir:ls_var* (cons (cons (cons (string-append "%ifptr" num)
                                                          (cadr a))
                                                    (car *impc:ir:ls_var*))
                                              (cdr *impc:ir:ls_var*)))
                 (impc:ir:strip-space os))
          ;; finally append %ifptr alloca to front of string
                                        ;(string-append "\n; alloca if pointer\n"
                                        ;      "%ifptr" num " = alloca " (cadr a) "\n"
                                        ;      (impc:ir:strip-space os)))
          (impc:ir:strip-space os)))))


;;
;; Compiler callback wraps a functions arguments into a struct
;; which is heap allocated (i.e. malloc).  Additionally a special
;; _callback function (created for every closure on bind-func)
;; is also added to the struct.  The struct is then sent to
;; the standard scheme scheduler which then passes the
;; struct to the embedded _callback function at the correct time.
;;
(define impc:ir:compiler:callback
  (lambda (ast types)
    (let* ((os (make-string 0))
           (timestr (impc:ir:compiler (cadr ast) types))
           (time (impc:ir:gname))
           (fname (symbol->string (caddr ast)))
           (ftypes (if (assoc-strcmp (caddr ast) types)
                       (map (lambda (a) (impc:ir:get-type-str a)) (cddr (assoc-strcmp (caddr ast) types)))
                       (impc:ti:get-closure-arg-types fname)))
           (callback_func_name_str (impc:ir:compiler (string-append fname "_callback") types))
           (callback_func_name (impc:ir:gname))
           (closure_db_call (llvm:get-function (string-append fname "_callback")))
           (cbzonestr (impc:ir:compiler (cadddr ast) types))
           (cbzone (impc:ir:gname))
           (astargs (cddddr ast))
           (args (map (lambda (a hint)
                        (cons (impc:ir:compiler a types (impc:ir:get-type-from-str hint)) (impc:ir:gname)))
                      astargs
                      (cdr ftypes)))
           (struct_type1 (string-append "{ void(i8*, %mzone*)*, i8*, %mzone*}*"))
           (struct_type2 (if (null? args)
                             ""
                             (string-append "{ " (cadr (cdr (car args)))
                                            (apply string-append  ;; void ptr first to hold "_callback" function
                                                   (map (lambda (a) (string-append ", " (cadr (cdr a)))) (cdr args)))
                                            "}*")))
           (total_size1 (* (/ (sys:pointer-size) 8) 3))
           ;; this is the last usage of impc:ir:get-type-size in llvmir.xtm - need to get rid of it as well
           (total_size2 (apply + (map (lambda (a) (impc:ir:get-type-size (cadr (cdr a)))) args))))
      (if (not (impc:ir:fixed-point? (cadr time)))
          (impc:compiler:print-compiler-error "arg 1 of callback must be an i64 time value"))
      (if (<> (length args) (length (cdr ftypes)))
          (impc:compiler:print-bad-arity-error ast))

      (emit timestr os)
      (emit (impc:ir:gname "dat1_" "i8*") " = call ccc i8* @malloc(" *impc:ir:size_t_str* " " (number->string total_size1) ")\n"
            (impc:ir:gname "struct1_" struct_type1) " = bitcast i8* " (car (impc:ir:gname "dat1_")) " to " struct_type1 "\n"
            os)
      (if (null? args)
          (emit (impc:ir:gname "dat2_" "i8*") " = select i1 true, i8* null, i8* null\n" os)
          (emit (impc:ir:gname "dat2_" "i8*") " = call ccc i8* @malloc(" *impc:ir:size_t_str* " " (number->string total_size2) ")\n"
                (impc:ir:gname "struct2_" struct_type2) " = bitcast i8* " (car (impc:ir:gname "dat2_")) " to " struct_type2 "\n"
                os))

      (emit callback_func_name_str os)

      (emit (impc:ir:gname "funcptr_ptr" "i8*") " = call ccc i8* @llvm_get_function_ptr(i8* " (car callback_func_name) ")\n" os)
      (emit (impc:ir:gname "funcptr" "void(i8*, %mzone*)*") " = bitcast i8* " (car (impc:ir:gname "funcptr_ptr")) " to void(i8*, %mzone*)*\n" os)

      (emit cbzonestr os)

      (emit (apply string-append (map (lambda (a n)
                                        (string-append (car a)
                                                       (impc:ir:gname "ptr" (string-append (cadr (cdr a)) "*")) " = getelementptr "
                                                       (impc:ir:pointer-- struct_type2) ", " struct_type2 " "
                                                       (car (impc:ir:gname "struct2_")) ", i32 0, i32 " (number->string n) "\n"
                                                       "store " (cadr (cdr a)) " " (car (cdr a)) ", "
                                                       (cadr (impc:ir:gname "ptr")) " " (car (impc:ir:gname "ptr")) "\n"))
                                      args
                                      (make-list-with-proc (length args) (lambda (i) i))))
            os)

      ;; now add both {fptr, struct2 and the mzone} to struct1
      (emit (impc:ir:gname "ptr" "void(i8*, %mzone*)**") " = getelementptr " (impc:ir:pointer-- struct_type1) ", " struct_type1 " "
            (car (impc:ir:gname "struct1_")) ", i32 0, i32 0\n"
            "store " (cadr (impc:ir:gname "funcptr")) " " (car (impc:ir:gname "funcptr")) ", "
            (cadr (impc:ir:gname "ptr")) " " (car (impc:ir:gname "ptr")) "\n"
            os)
      (emit (impc:ir:gname "ptr" "i8**") " = getelementptr " (impc:ir:pointer-- struct_type1) ", "  struct_type1 " "
            (car (impc:ir:gname "struct1_")) ", i32 0, i32 1\n"
            "store " (cadr (impc:ir:gname "dat2_")) " " (car (impc:ir:gname "dat2_")) ", "
            (cadr (impc:ir:gname "ptr")) " " (car (impc:ir:gname "ptr")) "\n"
            os)
      (emit (impc:ir:gname "ptr" "%mzone**") " = getelementptr " (impc:ir:pointer-- struct_type1) ", "  struct_type1 " "
            (car (impc:ir:gname "struct1_")) ", i32 0, i32 2\n"
            "store " (cadr cbzone) " " (car cbzone) ", "
            (cadr (impc:ir:gname "ptr")) " " (car (impc:ir:gname "ptr")) "\n"
            os)

      (emit "call ccc void @llvm_schedule_callback(" (cadr time) " " (car time) ", "
            "i8* " (car (impc:ir:gname "dat1_")) ")\n" os)
      (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
      (impc:ir:strip-space os))))

(define impc:ir:compiler:void
  (lambda (ast types)
    (impc:ir:gname "voidmark" (impc:ir:get-type-str *impc:ir:void*))
    ""))

;; this is (possibly?) broken for poly funcs
(define impc:ir:function-calling-convention
  (lambda (function-name)
    (if (not (impc:ti:closure-or-nativefunc-exists? function-name))
        #f
        (if (impc:ti:closure-exists? function-name)
            "fastcc"
            "ccc"))))

;; THIS VERSION FOR _NATIVE CALL CLOSURES!

(define impc:ir:intrinsic-substitution
  (lambda (name)
    (cond
      ((string=? name "memcpy") "llvm.memcpy.p0i8.p0i8.i64")
      (else name))))

(define impc:ir:function-fixup-args
  (lambda (name)
    (cond
      ((string=? name "memcpy") ", i32 1, i1 0")
      (else ""))))

(define impc:ir:compiler:native-call
  (lambda (ast types)
    ;; (println 'ast: ast 'types: types)
    (let* ((os (make-string 0))
           (fname (symbol->string (car ast)))
           (ftypes (or (impc:ti:get-closure-arg-types fname)
                       (impc:ti:get-nativefunc-arg-types fname)))
           (args (map (lambda (a hint)
                        (cons (impc:ir:compiler a types (impc:ir:get-type-from-str hint)) (impc:ir:gname)))
                      (cdr ast)
                      (cdr ftypes))))
      (if (<> (length args) (length (cdr ftypes)))
          (impc:compiler:print-bad-arity-error ast))

      ;; this here for structural typing on function call
      ;; can be commented out without effecting anything else!!
      (if *impc:compiler:allow-structural-calls
          (set! args
                (map (lambda (p ft)
                       (let* ((atype (cadr (cdr p)))
                              (aname (car (cdr p)))
                              (abass (impc:ir:get-type-from-str (impc:ir:get-base-type atype)))
                              (ftbass (impc:ir:get-type-from-str (impc:ir:get-base-type ft))))
                         (if (string? abass) (set! abass (impc:ir:get-type-from-str (impc:ti:get-named-type abass))))
                         (if (string? ftbass) (set! ftbass (impc:ir:get-type-from-str (impc:ti:get-named-type ftbass))))
                         (if (and (not (equal? (impc:ir:get-type-from-str atype)
                                               (impc:ir:get-type-from-str ft)))
                                  (equal? abass ftbass))
                             (cons (string-append
                                    (car p)
                                    (impc:ir:gname "val" ft)
                                    " = bitcast " atype " " aname " to " ft "\n")
                                   (impc:ir:gname))
                             p)))
                     args (cdr ftypes))))

;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; new for impz stuff
      ;; (emit (impc:ir:gname "tzone" "i8*") " = load i8*, i8** %_impzPtr\n"
      ;;       (impc:ir:gname "zone" "%mzone*") " = bitcast i8* " (car (impc:ir:gname "tzone")) " to %mzone*\n"
      ;;       os)
      ;; (if closurecall (emit (impc:ir:gname "tmp_zone" "i8*") " = bitcast %mzone* " (car (impc:ir:gname "zone")) " to i8*\n" os))
;;;;;;;;;;;;;;;;;;;;;;;;;
      (emit (apply string-append (map car args)) os)
      (emit (string-append (if (impc:ir:void? (car ftypes))
                               (begin (impc:ir:gname "res" "void") "")
                               (string-append (impc:ir:gname "res" (car ftypes)) " = "))
                           ;; "tail "
                           "call " (impc:ir:function-calling-convention fname)
                           " " (car ftypes)
                           " @" (impc:ir:intrinsic-substitution fname) "("
                           (apply string-append
                                  (map (lambda (p ft i)
                                         (let ((atype (cadr (cdr p)))
                                               (aname (car (cdr p))))
                                        ;(print p ft i)
                                        ;(if (not (string=? atype ft))
                                           (if (not (equal? (impc:ir:get-type-from-str atype)
                                                            (impc:ir:get-type-from-str ft)))
                                               (impc:compiler:print-type-mismatch-error atype (impc:ir:pretty-print-type ft) ast))
                                           (string-append (if (> i 0) ", " "")
                                                          atype " " aname)))
                                       args (cdr ftypes) (make-list-with-proc (length args) (lambda (i) i))))
                           (impc:ir:function-fixup-args fname)
                           ")\n") os)
      (impc:ir:strip-space os))))


(define impc:ir:compiler:fptrcall
  (lambda (ast types)
    (let* ((os (make-string 0))
           (fptrstr (impc:ir:compiler (cadr ast) types))
           (fptr (impc:ir:gname))
           (ftypes (impc:ir:get-type-from-str (cadr fptr)))
           (ftypestr (string-append (impc:ir:get-type-str (cadr ftypes))
                                    " (" (if (null? (cddr ftypes)) ")*"
                                             (string-append (impc:ir:get-type-str (caddr ftypes))
                                                            (apply string-append (map (lambda (v)
                                                                                        (string-append ", " (impc:ir:get-type-str v)))
                                                                                      (cdddr ftypes)))
                                                            ")*"))))
           (args (map (lambda (a hint)
                        (cons (impc:ir:compiler a types hint) (impc:ir:gname)))
                      (cddr ast)
                      (cddr ftypes))))
      (if (<> (length args) (length (cddr ftypes)))
          (impc:compiler:print-bad-arity-error ast))
      (emit fptrstr os)
      (emit (apply string-append (map (lambda (p) (car p)) args)) os)
      (emit (impc:ir:gname "fptr" ftypestr) " = bitcast " (cadr fptr) " " (car fptr) " to " ftypestr "\n" os)
      ;; (if (= (impc:ir:get-ptr-depth ftypes) 2)
      ;;     (begin (emit (impc:ir:gname "fptr_" (string-append ftypestr "*")) " = bitcast " (cadr fptr) " " (car fptr) " to " ftypestr "*\n" os)
      ;;            (emit (impc:ir:gname "fptr" ftypestr) " = load " (impc:ir:pointer-- (cadr (impc:ir:gname "fptr_"))) ", " (cadr (impc:ir:gname "fptr_")) " " (car (impc:ir:gname "fptr_")) "\n" os))
      ;;     (if (= (impc:ir:get-ptr-depth ftypes) 1)
      ;;         (emit (impc:ir:gname "fptr" ftypestr) " = bitcast " (cadr fptr) " " (car fptr) " to " ftypestr "\n" os)
      ;;         (log-error 'Compiler 'Error: 'bad 'function 'ptr 'type 'in ast 'type: ftypestr)))
      (emit (string-append (if (impc:ir:void? (cadr ftypes))
                               (begin (impc:ir:gname "res" "void") "")
                               (string-append (impc:ir:gname "res" (impc:ir:get-type-str (cadr ftypes))) " = "))
                           "call ccc "
                           (impc:ir:get-type-str (cadr ftypes)) " " (car (impc:ir:gname "fptr")) "("
                           (apply string-append
                                  (map (lambda (p ft i)
                                         (let ((atype (cadr (cdr p)))
                                               (aname (car (cdr p))))
                                           (if (not (equal? (impc:ir:get-type-from-str atype)
                                                            ft)) ;(impc:ir:get-type-from-str ft)))
                                               (impc:compiler:print-type-mismatch-error ft atype ast))
                                           (string-append (if (> i 0) ", " "")
                                                          atype " " aname)))
                                       args (cddr ftypes) (make-list-with-proc (length args) (lambda (i) i))))
                           ")\n") os)
      (impc:ir:strip-space os))))

(define impc:ir:compiler
  (let ((intrinsics '(sin cos ceil floor exp pow log log2 log10 sqrt fabs round trunc nearbyint fma exp2 powi)))
    (lambda (ast types . hint?)
      (if (and (list? hint?)
               (= 1 (length hint?))
               (equal? (car hint?) #f))
          (set! hint? '()))
      ;; (println 'compiler: ast 'types: types 'hint?: hint?)
      (cond ((null? ast) "")
            ((atom? ast)
             (cond ((symbol? ast)
                    (if (or (assoc-strcmp ast types)
                            (impc:ti:globalvar-exists? (symbol->string ast)))
                        (if (assoc-strcmp ast types)
                            (begin
                              (if (not (member ast *impc:ir:sym-name-stack*))
                                  (impc:compiler:print-missing-identifier-error ast 'variable)
                                  (impc:ir:compile:eval-var ast (cdr (assoc-strcmp ast types)))))
                            (impc:ir:compile:eval-gvar ast))
                        (if (impc:ti:closure-exists? (symbol->string ast))
                            (if (impc:ti:nativefunc-exists? (symbol->string ast))
                                (let ((name (symbol->string ast))
                                      (ftypes (impc:ti:get-nativefunc-arg-types (symbol->string ast))))
                                  (string-append (impc:ir:gname "__fptr" "i8*")
                                                 " = bitcast " (car ftypes)
                                                 " (" (string-join (cdr ftypes) ",")
                                                 ")* @" name " to i8*\n"))
                                (impc:ir:compiler:closure-from-getter (symbol->string ast)))
                            (if (impc:ti:nativefunc-exists? (symbol->string ast))
                                (let ((name (symbol->string ast))
                                      (ftypes (impc:ti:get-nativefunc-arg-types (symbol->string ast))))
                                  (string-append (impc:ir:gname "__fptr"
                                                                (string-append (car ftypes) " (" (string-join (cdr ftypes) ",") ")*"))
                                                 " = bitcast " (car ftypes)
                                                 " (" (string-join (cdr ftypes) ",")
                                                 ")* @" name " to " (car ftypes)
                                                 " (" (string-join (cdr ftypes) ",")
                                                 ")*\n"))
                                (impc:compiler:print-missing-identifier-error ast 'variable)))))
                   ((number? ast)
                    ;; (println 'number: 'ast: ast 'hint: hint?)
                    (if (not (null? hint?))
                        (begin (if (and (integer? ast) (impc:ir:floating-point? (car hint?)))
                                   (impc:compiler:print-bad-numeric-value-error ast (impc:ir:pretty-print-type (car hint?))))
                               (if (and (not (integer? ast)) (impc:ir:fixed-point? (car hint?)))
                                   (impc:compiler:print-bad-numeric-value-error ast (impc:ir:pretty-print-type (car hint?))))))
                    (if (and (not (null? hint?))
                             (impc:ir:vector? (car hint?)))
                        (impc:ir:compiler (append '(make-vector) (map (lambda (x) ast) (range (cadar hint?))))
                                          types (car hint?))
                        (begin
                          (if (and (not (null? hint?))
                                   (impc:ir:number? (car hint?)))
                              (if (= *impc:ir:fp32* (car hint?))
                                  (impc:ir:gname (llvm:convert-float (number->string ast)) (impc:ir:get-type-str (car hint?)))
                                  (impc:ir:gname (number->string ast) (impc:ir:get-type-str (car hint?))))
                              (impc:ir:gname (number->string ast) (if (integer? ast) "i64" "double")))
                        "")))
                   ((string? ast)
                    (impc:ir:make-const-string ast))
                   (else (impc:compiler:print-compiler-error "bad or unsupported atom type" ast))))
            ((list? ast)
             (cond ((member (car ast) '(__make-env __make-env-zone))
                    (impc:ir:compile:make-env ast types))
                   ;; ((equal? (car ast) 'memzone) (impc:ir:compile:zone ast types))
                   ((equal? (car ast) 'push_new_zone) (impc:ir:compile:push_new_zone ast types))
                   ((equal? (car ast) 'push_zone) (impc:ir:compile:push_zone ast types))
                   ((equal? (car ast) 'create_zone) (impc:ir:compile:create_zone ast types))
                   ((equal? (car ast) 'pop_zone) (impc:ir:compile:pop_zone ast types))
                   ((member (car ast) '(impc_null))
                    (string-append (impc:ir:gname "null" (if (null? hint?) "i8*" (impc:ir:get-type-str (car hint?))))
                                   " = bitcast i8* null to " (if (null? hint?) "i8*" (impc:ir:get-type-str (car hint?)))
                                   "\n"))
                   ((member (car ast) '(__make-static))
                    (let* ((fstr (impc:ir:compile:make-static ast types)))
                      ;; compile function
                      (if *impc:compiler:print* (println '------------------------------compiling---------------------------->))
                      (if *impc:compiler:print* (print-full-nq fstr))
                      (if *impc:compile*
                          (begin (llvm:remove-function (caddr ast))
                                 (if (not (llvm:compile-ir fstr))
                                     (if *impc:compiler:verbose*
                                         (impc:compiler:print-compiler-error "compiler failed on " fstr)
                                         (impc:compiler:print-compiler-error "compiler failed")))))
                      fstr))
                   ((member (car ast) '(__make-closure __make-closure-z __make-closure-h __make-closure-s))
                    (let* (;(str-pair (impc:ir:compile:make-closure ast types))
                                        ;(fstr (car str-pair))
                                        ;(lstr (cdr str-pair)))
                           (fstr (impc:ir:compile:make-closure ast types))
                           (lstr (impc:ir:compile:make-closureenv ast types)))
                      ;; compile function
                      (if *impc:compiler:print* (println '------------------------------compiling---------------------------->))
                      (if *impc:compiler:print* (print-full-nq fstr))
                      (if *impc:compile*
                          (begin (llvm:remove-function (caddr ast))
                                 (if (not (llvm:compile-ir fstr))
                                     (if *impc:compiler:verbose*
                                         (impc:compiler:print-compiler-error "compiler failed on " fstr)
                                         (impc:compiler:print-compiler-error "compiler failed")))))
                      lstr))
                   ((member (car ast) '(clrun->)) ;; apply function
                    (if (impc:ti:closure-exists? (symbol->string (cadr ast)))
                        (string-append (impc:ir:compiler (cadr ast) types)
                                       (impc:ir:compile:apply-closure (cdr ast) types #t
                                                                      (cons (impc:ir:gname) (cddr ast))))
                        (if (impc:ti:globalvar-exists? (symbol->string (cadr ast))) ;; else is gloval var (i.e. bind-val)
                            (string-append (impc:ir:compiler (cadr ast) types)
                                           (impc:ir:compile:apply-closure (cdr ast) types #t
                                                                          (cons (impc:ir:gname) (cddr ast))))
                            (impc:ir:compile:apply-closure (cdr ast) types #f)))) ;; else closure is in local env
                   ((equal? (car ast) 'set!)
                    (impc:ir:compiler:set! ast types))
                   ((equal? (car ast) 'pref)
                    (impc:ir:compiler:pref ast types))
                   ((equal? (car ast) 'pdref)
                    (impc:ir:compiler:pdref ast types))
                   ((equal? (car ast) 'bitcast)
                    (if (null? hint?)
                        (impc:ir:compiler:bitcast ast types hint?)
                        (impc:ir:compiler:bitcast ast types (car hint?))))
                   ((equal? (car ast) 'bitconvert)
                    (if (null? hint?)
                        (impc:ir:compiler:bitconvert ast types hint?)
                        (impc:ir:compiler:bitconvert ast types (car hint?))))
                   ((equal? (car ast) 'null?)
                    (impc:ir:compiler:null ast types))
                   ((equal? (car ast) 'dotimes)
                    (impc:ir:compiler:loop (cdr ast) types))
                   ((equal? (car ast) 'while)
                    (impc:ir:compiler:while-loop (cdr ast) types))
                   ((equal? (car ast) 'make-array)
                    (impc:ir:compiler:make-array ast types hint?))
                   ((equal? (car ast) 'array-ref)
                    (impc:ir:compiler:array-ref ast types))
                   ((equal? (car ast) 'array-ref-ptr)
                    (impc:ir:compiler:array-ref-ptr ast types))
                   ((equal? (car ast) 'array-set!)
                    (impc:ir:compiler:array-set ast types))
                   ((equal? (car ast) 'make-vector)
                    (impc:ir:compiler:make-vector ast types hint?))
                   ((equal? (car ast) 'vector-set!)
                    (impc:ir:compiler:vector-set ast types))
                   ((equal? (car ast) 'vector-ref)
                    (impc:ir:compiler:vector-ref ast types))
                   ((equal? (car ast) 'vector-shuffle)
                    (impc:ir:compiler:vector-shuffle ast types))
                   ((member (car ast) intrinsics)
                    (if (null? hint?)
                        (impc:ir:compiler:math-intrinsics ast types)
                        (impc:ir:compiler:math-intrinsics ast types (car hint?))))
                   ((equal? (car ast) 'pointer-ref)
                    (impc:ir:compiler:pointer-ref ast types))
                   ((equal? (car ast) 'pointer-ref-ptr)
                    (impc:ir:compiler:pointer-ref-ptr ast types))
                   ((equal? (car ast) 'pointer-set!)
                    (impc:ir:compiler:pointer-set ast types))
                   ((equal? (car ast) 'zone-alloc)
                    (impc:ir:compiler:zone-alloc ast types hint?))
                   ((equal? (car ast) 'heap-alloc)
                    (impc:ir:compiler:heap-alloc ast types hint?))
                   ((equal? (car ast) 'stack-alloc)
                    (impc:ir:compiler:stack-alloc ast types hint?))
                   ((equal? (car ast) 'num-of-elts)
                    (impc:ir:compiler:num-of-elts ast types))
                   ((equal? (car ast) 'obj-size)
                    (impc:ir:compiler:obj-size ast types))
                   ((equal? (car ast) 'ref)
                    (impc:ir:compiler:ref ast types))
                   ((equal? (car ast) 'make-tuple)
                    (impc:ir:compiler:make-tuple ast types hint?))
                   ((equal? (car ast) 'tuple-ref)
                    (impc:ir:compiler:tuple-ref ast types))
                   ((equal? (car ast) 'tuple-ref-ptr)
                    (impc:ir:compiler:tuple-ref-ptr ast types))
                   ((equal? (car ast) 'tuple-set!)
                    (impc:ir:compiler:tuple-set ast types))
                   ((equal? (car ast) 'void)
                    (impc:ir:compiler:void ast types))
                   ((equal? (car ast) 'llvm_callback)
                    (impc:ir:compiler:callback ast types))
                   ((equal? (car ast) 'closure-ref)
                    (if (null? hint?)
                        (impc:ir:compiler:closure-ref ast types)
                        (impc:ir:compiler:closure-ref ast types (car hint?))))
                   ((equal? (car ast) 'closure-set!)
                    (impc:ir:compiler:closure-set ast types))
                   ((equal? (car ast) 'closure-refcheck)
                    (if (null? hint?)
                        (impc:ir:compiler:closure-refcheck ast types)
                        (impc:ir:compiler:closure-refcheck ast types (car hint?))))
                   ((equal? (car ast) 'coerce->)
                    (impc:ir:compiler:coerce (cdr ast) types))
                   ((equal? (car ast) 'modulo)
                    (impc:ir:compiler:modulo ast types))
                   ((member (car ast) '(> < <> =))
                    (if (<> (length ast) 3)
                        (impc:compiler:print-bad-arity-error ast))
                    (if (not (null? hint?))
                        (impc:ir:compiler:cmp (cl:position (car ast) '(> < <> =)) ast types (car hint?))
                        (impc:ir:compiler:cmp (cl:position (car ast) '(> < <> =)) ast types)))
                   ((member (car ast) '(+ - * / %))
                    (if (<> (length ast) 3)
                        (log-error 'Compiler 'Error: ast 'bad 'arity))
                    (if (not (null? hint?))
                        (impc:ir:compiler:math (cl:position (car ast) '(+ - * / %)) ast types (car hint?))
                        (impc:ir:compiler:math (cl:position (car ast) '(+ - * / %)) ast types)))
                   ((member (car ast) '(bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right))
                    (if (<> (length ast) 3)
                        (impc:compiler:print-bad-arity-error ast))
                    (if (not (null? hint?))
                        (impc:ir:compiler:bitwise (cl:position (car ast) '(bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right)) ast types (car hint?))
                        (impc:ir:compiler:bitwise (cl:position (car ast) '(bitwise-and bitwise-or bitwise-eor bitwise-shift-left bitwise-shift-right)) ast types)))
                   ((equal? (car ast) 'if)
                    (if (not (null? hint?))
                        (impc:ir:compiler:if ast types (car hint?))
                        (impc:ir:compiler:if ast types)))
                   ((equal? (car ast) 'ifret)
                    (impc:ir:compiler:ifret ast types))
                   ((and (symbol? (car ast))
                         (or (impc:ti:nativefunc-exists? (symbol->string (car ast)))
                             (impc:ti:closure-exists? (symbol->string (car ast)))))
                    (if (member (car ast) '(printf fprintf sprintf sscanf fscanf))
                        (impc:ir:compiler:llvm_varargs ast types)
                        (impc:ir:compiler:native-call ast types)))
                   ((equal? (car ast) 'ret->) ;; return from function
                    (impc:ir:compiler:ret ast types hint?))
                   ((equal? (car ast) 'fptrcall)
                    (impc:ir:compiler:fptrcall ast types hint?))
                   ((equal? (car ast) 'if)
                    (impc:ir:compiler:if ast types))
                   ((equal? (car ast) 'begin)
                    (let ((ll (map (lambda (expr) (impc:ir:compiler expr types)) (cdr ast))))
                      (apply string-append ll)))
                   ((and (list? (car ast))
                         (equal? (caar ast) 'begin))
                    (string-append (impc:ir:compiler (car ast) types)
                                   (impc:ir:compiler (cdr ast) types)))
                   ((list? (car ast))
                    (string-append (impc:ir:compiler (car ast) types)
                                   (impc:ir:compile:apply-closure (cons 'anonlambdaref (cdr ast)) types #t (cons (impc:ir:gname) (cdr ast)))))
                   (else (string-append (impc:ir:compiler (car ast) types)
                                        (impc:ir:compiler (cdr ast) types)))))
            ((pair? ast)
             (let ((a (impc:ir:compiler (car ast) types))
                   (b (impc:ir:compiler (cdr ast) types)))
               (string-append a b)))))))
